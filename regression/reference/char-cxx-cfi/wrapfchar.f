! wrapfchar.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
#include "shroud/features.h"
!>
!! \file wrapfchar.f
!! \brief Shroud generated wrapper for char library
!<
! splicer begin file_top
! splicer end file_top
module char_mod
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    interface
        subroutine init_test() &
                bind(C, name="CHA_init_test")
            implicit none
        end subroutine init_test
    end interface

    ! ----------------------------------------
    ! Function:  void passChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine pass_char(status) &
                bind(C, name="CHA_passChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine pass_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine c_pass_char_force(status) &
                bind(C, name="CHA_passCharForce")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine c_pass_char_force
    end interface

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Statement: f_function_char
    interface
        subroutine c_return_char(SHT_rv) &
                bind(C, name="CHA_returnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_return_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +charlen(40)+intent(out)
    ! Statement: c_out_char*
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: c_in_char*
    ! start c_pass_char_ptr
    interface
        subroutine c_pass_char_ptr(dest, src) &
                bind(C, name="CHA_passCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr
    end interface
    ! end c_pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +charlen(40)+intent(out)
    ! Statement: f_out_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_cfi
    ! start pass_char_ptr
    interface
        subroutine pass_char_ptr(dest, src) &
                bind(C, name="CHA_passCharPtr_CFI")
            implicit none
            character(len=*), intent(OUT) :: dest
            character(len=*), intent(IN) :: src
        end subroutine pass_char_ptr
    end interface
    ! end pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *s +intent(inout)
    ! Statement: c_inout_char*
    interface
        subroutine c_pass_char_ptr_in_out(s) &
                bind(C, name="CHA_passCharPtrInOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
        end subroutine c_pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *s +intent(inout)
    ! Statement: f_inout_char*_cfi
    interface
        subroutine pass_char_ptr_in_out(s) &
                bind(C, name="CHA_passCharPtrInOut_CFI")
            implicit none
            character(len=*), intent(INOUT) :: s
        end subroutine pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  const char *getCharPtr1
    ! Statement: c_function_char*
    ! start c_get_char_ptr1
    interface
        function c_get_char_ptr1() &
                result(SHT_rv) &
                bind(C, name="CHA_getCharPtr1")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_char_ptr1
    end interface
    ! end c_get_char_ptr1

    ! ----------------------------------------
    ! Function:  const char *getCharPtr1
    ! Statement: f_function_char*_cfi_allocatable
    ! start c_get_char_ptr1_CFI
    interface
        subroutine c_get_char_ptr1_CFI(SHT_rv) &
                bind(C, name="CHA_getCharPtr1_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_char_ptr1_CFI
    end interface
    ! end c_get_char_ptr1_CFI

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrLen +len(30)
    ! Statement: c_function_char*
    ! start c_get_const_char_ptr_len
    interface
        function c_get_const_char_ptr_len() &
                result(SHT_rv) &
                bind(C, name="CHA_getConstCharPtrLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_char_ptr_len
    end interface
    ! end c_get_const_char_ptr_len

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrLen +len(30)
    ! Statement: f_function_char*_cfi_copy
    ! start c_get_const_char_ptr_len_CFI
    interface
        subroutine c_get_const_char_ptr_len_CFI(SHT_rv) &
                bind(C, name="CHA_getConstCharPtrLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_char_ptr_len_CFI
    end interface
    ! end c_get_const_char_ptr_len_CFI

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrAsArg
    ! Statement: c_function_char*
    ! start c_get_const_char_ptr_as_arg
    interface
        function c_get_const_char_ptr_as_arg() &
                result(SHT_rv) &
                bind(C, name="CHA_getConstCharPtrAsArg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_char_ptr_as_arg
    end interface
    ! end c_get_const_char_ptr_as_arg

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrAsArg
    ! Statement: f_function_char*_cfi_arg
    ! start c_get_const_char_ptr_as_arg_CFI
    interface
        subroutine c_get_const_char_ptr_as_arg_CFI(output) &
                bind(C, name="CHA_getConstCharPtrAsArg_CFI")
            implicit none
            character(len=*), intent(OUT) :: output
        end subroutine c_get_const_char_ptr_as_arg_CFI
    end interface
    ! end c_get_const_char_ptr_as_arg_CFI

    ! ----------------------------------------
    ! Function:  const char *getCharPtr4 +deref(raw)
    ! Statement: f_function_char*_raw
    interface
        function get_char_ptr4() &
                result(SHT_rv) &
                bind(C, name="CHA_getCharPtr4")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function get_char_ptr4
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char *getCharPtr5 +deref(pointer)
    ! Statement: c_function_char*
    interface
        function c_get_char_ptr5() &
                result(SHT_rv) &
                bind(C, name="CHA_getCharPtr5")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_char_ptr5
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char *getCharPtr5 +deref(pointer)
    ! Statement: f_function_char*_cfi_pointer
    interface
        subroutine c_get_char_ptr5_CFI(SHT_rv) &
                bind(C, name="CHA_getCharPtr5_CFI")
            implicit none
            character(len=:), intent(OUT), pointer :: SHT_rv
        end subroutine c_get_char_ptr5_CFI
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(in)+len_trim(AAlen)
    ! Statement: c_in_char*
    interface
        subroutine c_explicit1(name) &
                bind(C, name="CHA_explicit1")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
        end subroutine c_explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(in)+len_trim(AAlen)
    ! Statement: f_in_char*_cfi
    interface
        subroutine explicit1(name) &
                bind(C, name="CHA_explicit1_CFI")
            implicit none
            character(len=*), intent(IN) :: name
        end subroutine explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(out)+len(AAtrim)
    ! Statement: c_out_char*
    interface
        subroutine c_explicit2(name) &
                bind(C, name="CHA_explicit2")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
        end subroutine c_explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(out)+len(AAtrim)
    ! Statement: f_out_char*_cfi
    interface
        subroutine explicit2(name) &
                bind(C, name="CHA_explicit2_CFI")
            implicit none
            character(len=*), intent(OUT) :: name
        end subroutine explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine cpass_char(status) &
                bind(C, name="CHA_CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    interface
        subroutine c_creturn_char(SHT_rv) &
                bind(C, name="CHA_CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: c_out_char*
    ! ----------------------------------------
    ! Argument:  const char *src +blanknull
    ! Statement: c_in_char*
    interface
        subroutine c_cpass_char_ptr(dest, src) &
                bind(C, name="CpassCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src +blanknull
    ! Statement: f_in_char*_cfi
    interface
        subroutine cpass_char_ptr(dest, src) &
                bind(C, name="CHA_CpassCharPtr_CFI")
            implicit none
            character(len=*), intent(OUT) :: dest
            character(len=*), intent(IN) :: src
        end subroutine cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: c_out_char*
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: c_in_char*
    interface
        subroutine c_cpass_char_ptr_blank(dest, src) &
                bind(C, name="CHA_CpassCharPtrBlank")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr_blank
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_cfi
    interface
        subroutine cpass_char_ptr_blank(dest, src) &
                bind(C, name="CHA_CpassCharPtrBlank_CFI")
            implicit none
            character(len=*), intent(OUT) :: dest
            character(len=*), intent(IN) :: src
        end subroutine cpass_char_ptr_blank
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Statement: c_function_native
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: c_in_char*
    interface
        function c_cpass_char_ptr_notrim(src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrNotrim")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_notrim
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_cfi
    interface
        function cpass_char_ptr_notrim(src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrNotrim_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(IN) :: src
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_notrim
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  void *addr
    ! Statement: f_in_void*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    interface
        function cpass_char_ptr_capi(addr, src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrCAPI")
            use iso_c_binding, only : C_CHAR, C_INT, C_PTR
            implicit none
            type(C_PTR), value, intent(IN) :: addr
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_capi
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Statement: c_function_native
    ! ----------------------------------------
    ! Argument:  const char *in
    ! Statement: c_in_char*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: c_in_char*
    interface
        function c_cpass_char_ptr_capi2(in, src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrCAPI2")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: in(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_capi2
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *in
    ! Statement: f_in_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    interface
        function cpass_char_ptr_capi2(in, src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrCAPI2_CFI")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(len=*), intent(IN) :: in
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_capi2
    end interface

    ! ----------------------------------------
    ! Function:  int acceptCharArrayIn
    ! Statement: c_function_native
    ! ----------------------------------------
    ! Argument:  char **names +intent(in)
    ! Statement: c_in_char**
    interface
        function c_accept_char_array_in(names) &
                result(SHT_rv) &
                bind(C, name="CHA_acceptCharArrayIn")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(IN) :: names(*)
            integer(C_INT) :: SHT_rv
        end function c_accept_char_array_in
    end interface

    ! ----------------------------------------
    ! Function:  int acceptCharArrayIn
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  char **names +intent(in)
    ! Statement: f_in_char**_cfi
    interface
        function accept_char_array_in(names) &
                result(SHT_rv) &
                bind(C, name="CHA_acceptCharArrayIn_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(IN) :: names(:)
            integer(C_INT) :: SHT_rv
        end function accept_char_array_in
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    subroutine init_test()
        ! splicer begin function.init_test
        call c_init_test()
        ! splicer end function.init_test
    end subroutine init_test
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void passChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! \brief pass a single char argument as a scalar.
    !!
    !<
    subroutine pass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char
        call c_pass_char(status)
        ! splicer end function.pass_char
    end subroutine pass_char
#endif

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! By default no Fortran wrapper is created.
    !! Force one so it can be tested.
    !<
    subroutine pass_char_force(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char_force
        call c_pass_char_force(status)
        ! splicer end function.pass_char_force
    end subroutine pass_char_force

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Statement: f_function_char
    !>
    !! \brief return a char argument (non-pointer)
    !!
    !<
    function return_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.return_char
        call c_return_char(SHT_rv)
        ! splicer end function.return_char
    end function return_char

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +charlen(40)+intent(out)
    ! Statement: f_out_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_cfi
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! In Python, src must not be over 40 characters, defined by charlen.
    !<
    ! start pass_char_ptr
    subroutine pass_char_ptr(dest, src)
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.pass_char_ptr
        call c_pass_char_ptr_CFI(dest, src)
        ! splicer end function.pass_char_ptr
    end subroutine pass_char_ptr
    ! end pass_char_ptr
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *s +intent(inout)
    ! Statement: f_inout_char*_cfi
    !>
    !! \brief toupper
    !!
    !! Change a string in-place.
    !! For Python, return a new string since strings are immutable.
    !<
    subroutine pass_char_ptr_in_out(s)
        character(len=*), intent(INOUT) :: s
        ! splicer begin function.pass_char_ptr_in_out
        call c_pass_char_ptr_in_out_CFI(s)
        ! splicer end function.pass_char_ptr_in_out
    end subroutine pass_char_ptr_in_out
#endif

    ! ----------------------------------------
    ! Function:  const char *getCharPtr1
    ! Statement: f_function_char*_cfi_allocatable
    !>
    !! Return an ALLOCATABLE CHARACTER from char *.
    !<
    ! start get_char_ptr1
    function get_char_ptr1() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_char_ptr1
        call c_get_char_ptr1_CFI(SHT_rv)
        ! splicer end function.get_char_ptr1
    end function get_char_ptr1
    ! end get_char_ptr1

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrLen +len(30)
    ! Statement: f_function_char*_cfi_copy
    !>
    !! \brief return 'const char *' with fixed size (len=30)
    !!
    !<
    ! start get_const_char_ptr_len
    function get_const_char_ptr_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_char_ptr_len
        call c_get_const_char_ptr_len_CFI(SHT_rv)
        ! splicer end function.get_const_char_ptr_len
    end function get_const_char_ptr_len
    ! end get_const_char_ptr_len

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrAsArg
    ! Statement: f_function_char*_cfi_arg
    !>
    !! \brief return a 'const char *' as argument
    !!
    !<
    ! start get_const_char_ptr_as_arg
    subroutine get_const_char_ptr_as_arg(output)
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_char_ptr_as_arg
        call c_get_const_char_ptr_as_arg_CFI(output)
        ! splicer end function.get_const_char_ptr_as_arg
    end subroutine get_const_char_ptr_as_arg
    ! end get_const_char_ptr_as_arg

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  const char *getCharPtr4 +deref(raw)
    ! Statement: f_function_char*_raw
    !>
    !! \brief return a 'const char *' as type(C_PTR)
    !!
    !<
    function get_char_ptr4() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(C_PTR) :: SHT_rv
        ! splicer begin function.get_char_ptr4
        SHT_rv = c_get_char_ptr4()
        ! splicer end function.get_char_ptr4
    end function get_char_ptr4
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char *getCharPtr5 +deref(pointer)
    ! Statement: f_function_char*_cfi_pointer
    !>
    !! \brief return a 'const char *' as character(:) pointer
    !!
    !<
    function get_char_ptr5() &
            result(SHT_rv)
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_char_ptr5
        call c_get_char_ptr5_CFI(SHT_rv)
        ! splicer end function.get_char_ptr5
    end function get_char_ptr5
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void explicit1
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(in)+len_trim(AAlen)
    ! Statement: f_in_char*_cfi
    subroutine explicit1(name)
        character(len=*), intent(IN) :: name
        ! splicer begin function.explicit1
        call c_explicit1_CFI(name)
        ! splicer end function.explicit1
    end subroutine explicit1
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void explicit2
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(out)+len(AAtrim)
    ! Statement: f_out_char*_cfi
    subroutine explicit2(name)
        character(len=*), intent(OUT) :: name
        ! splicer begin function.explicit2
        call c_explicit2_CFI(name)
        ! splicer end function.explicit2
    end subroutine explicit2
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! \brief pass a single char argument as a scalar, extern "C"
    !!
    !<
    subroutine cpass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.cpass_char
        call c_cpass_char(status)
        ! splicer end function.cpass_char
    end subroutine cpass_char
#endif

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char(SHT_rv)
        ! splicer end function.creturn_char
    end function creturn_char

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src +blanknull
    ! Statement: f_in_char*_cfi
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! extern "C"
    !! If src is a blank string, pass a NULL pointer to C library function.
    !<
    subroutine cpass_char_ptr(dest, src)
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr
        call c_cpass_char_ptr_CFI(dest, src)
        ! splicer end function.cpass_char_ptr
    end subroutine cpass_char_ptr
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_cfi
    !>
    !! \brief Test F_blanknull option
    !!
    !<
    subroutine cpass_char_ptr_blank(dest, src)
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr_blank
        call c_cpass_char_ptr_blank_CFI(dest, src)
        ! splicer end function.cpass_char_ptr_blank
    end subroutine cpass_char_ptr_blank
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_cfi
    !>
    !! \brief NULL terminate input string in C, not in Fortran.
    !!
    !<
    function cpass_char_ptr_notrim(src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_notrim
        SHT_rv = c_cpass_char_ptr_notrim_CFI(src)
        ! splicer end function.cpass_char_ptr_notrim
    end function cpass_char_ptr_notrim
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  void *addr
    ! Statement: f_in_void*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    !>
    !! \brief Do not NULL terminate input string
    !!
    !! The C library function should get the same address
    !! for addr and src.
    !! Used when the C function needs the true address of the argument.
    !! Skips null-termination. Useful to create an interface for
    !! a function which is already callable by Fortran.
    !! For example, the length is passed explicitly.
    !! This example will not create a Fortran wrapper since C can be
    !! called directly.
    !<
    function cpass_char_ptr_capi(addr, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        type(C_PTR), intent(IN) :: addr
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi
        SHT_rv = c_cpass_char_ptr_capi(addr, src)
        ! splicer end function.cpass_char_ptr_capi
    end function cpass_char_ptr_capi
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *in
    ! Statement: f_in_char*_cfi
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    !>
    !! \brief Mix api(buf) and api(capi)
    !!
    !<
    function cpass_char_ptr_capi2(in, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: in
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi2
        SHT_rv = c_cpass_char_ptr_capi2_CFI(in, src)
        ! splicer end function.cpass_char_ptr_capi2
    end function cpass_char_ptr_capi2
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int acceptCharArrayIn
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  char **names +intent(in)
    ! Statement: f_in_char**_cfi
    !>
    !! Return strlen of the first index as a check.
    !<
    function accept_char_array_in(names) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: names(:)
        integer(C_INT) :: SHT_rv
        ! splicer begin function.accept_char_array_in
        SHT_rv = c_accept_char_array_in_CFI(names)
        ! splicer end function.accept_char_array_in
    end function accept_char_array_in
#endif

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module char_mod

// wrapchar.cpp
// This file is generated by Shroud nowrite-version. Do not edit.
// Copyright Shroud Project Developers. See LICENSE file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)
//

// cxx_header
#include "char.h"
#include "shroud/features.h"
// shroud
#include <cstring>
#include <cstdlib>
#include "wrapchar.h"

// splicer begin CXX_definitions
// splicer end CXX_definitions

extern "C" {


// helper char_len_trim
// Returns the length of character string src with length nsrc,
// ignoring any trailing blanks.
static int ShroudCharLenTrim(const char *src, int nsrc) {
    int i;

    for (i = nsrc - 1; i >= 0; i--) {
        if (src[i] != ' ') {
            break;
        }
    }

    return i + 1;
}


// helper char_alloc
// Copy src into new memory and null terminate.
// If ntrim is 0, return NULL pointer.
// If blanknull is 1, return NULL when string is blank.
static char *ShroudCharAlloc(const char *src, int nsrc, int blanknull)
{
    int ntrim = ShroudCharLenTrim(src, nsrc);
    if (ntrim == 0 && blanknull == 1) {
        return nullptr;
    }
    char *rv = (char *) std::malloc(nsrc + 1);
    if (ntrim > 0) {
        std::memcpy(rv, src, ntrim);
    }
    rv[ntrim] = '\0';
    return rv;
}

// start helper char_array_alloc
// helper char_array_alloc
// Copy src into new memory and null terminate.
// char **src +size(nsrc) +len(len)
// CHARACTER(len) src(nsrc)
static char **ShroudStrArrayAlloc(const char *src, int nsrc, int len)
{
    char **rv = static_cast<char **>(std::malloc(sizeof(char *) *nsrc));
    const char *src0 = src;
    for(int i=0; i < nsrc; ++i) {
        int ntrim = ShroudCharLenTrim(src0, len);
        char *tgt = static_cast<char *>(std::malloc(ntrim+1));
        std::memcpy(tgt, src0, ntrim);
        tgt[ntrim] = '\0';
        rv[i] = tgt;
        src0 += len;
    }
    return rv;
}
// end helper char_array_alloc

// helper char_array_free
// Release memory allocated by ShroudStrArrayAlloc
static void ShroudStrArrayFree(char **src, int nsrc)
{
    for(int i=0; i < nsrc; ++i) {
        std::free(src[i]);
    }
    std::free(src);
}

// helper ShroudCharCopy
// Copy src into dest, blank fill to ndest characters
// Truncate if dest is too short.
// dest will not be NULL terminated.
static void ShroudCharCopy(char *dest, int ndest, const char *src, int nsrc)
{
    if (src == NULL) {
        std::memset(dest,' ',ndest); // convert NULL pointer to blank filled string
    } else {
        if (nsrc < 0) nsrc = std::strlen(src);
        int nm = nsrc < ndest ? nsrc : ndest;
        std::memcpy(dest,src,nm);
        if(ndest > nm) std::memset(dest+nm,' ',ndest-nm); // blank fill
    }
}

// helper char_free
// Release memory allocated by ShroudCharAlloc
static void ShroudCharFree(char *src)
{
    if (src != NULL) {
        std::free(src);
    }
}

// splicer begin C_definitions
// splicer end C_definitions

// ----------------------------------------
// Function:  void init_test
// Statement: c_subroutine
// start CHA_init_test
void CHA_init_test(void)
{
    // splicer begin function.init_test
    init_test();
    // splicer end function.init_test
}
// end CHA_init_test

/**
 * \brief pass a single char argument as a scalar.
 *
 */
// ----------------------------------------
// Function:  void passChar
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
// start CHA_passChar
void CHA_passChar(char status)
{
    // splicer begin function.passChar
    passChar(status);
    // splicer end function.passChar
}
// end CHA_passChar

/**
 * By default no Fortran wrapper is created.
 * Force one so it can be tested.
 */
// ----------------------------------------
// Function:  void passCharForce
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
// start CHA_passCharForce
void CHA_passCharForce(char status)
{
    // splicer begin function.passCharForce
    passCharForce(status);
    // splicer end function.passCharForce
}
// end CHA_passCharForce

/**
 * \brief return a char argument (non-pointer)
 *
 */
// ----------------------------------------
// Function:  char returnChar
// Statement: c_function_char
// start CHA_returnChar
void CHA_returnChar(char *SHC_rv)
{
    // splicer begin function.returnChar
    *SHC_rv = returnChar();
    // splicer end function.returnChar
}
// end CHA_returnChar

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * In Python, src must not be over 40 characters, defined by charlen.
 */
// ----------------------------------------
// Function:  void passCharPtr
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *dest +charlen(40)+intent(out)
// Statement: c_out_char*
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_passCharPtr
void CHA_passCharPtr(char *dest, const char *src)
{
    // splicer begin function.passCharPtr
    passCharPtr(dest, src);
    // splicer end function.passCharPtr
}
// end CHA_passCharPtr

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * In Python, src must not be over 40 characters, defined by charlen.
 */
// ----------------------------------------
// Function:  void passCharPtr
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +charlen(40)+intent(out)
// Statement: f_out_char*_cfi
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_cfi
// start CHA_passCharPtr_CFI
void CHA_passCharPtr_CFI(CFI_cdesc_t *SHT_dest_cfi,
    CFI_cdesc_t *SHT_src_cfi)
{
    // splicer begin function.passCharPtr_CFI
    char *dest = static_cast<char *>(SHT_dest_cfi->base_addr);
    size_t SHT_dest_len = SHT_dest_cfi->elem_len;
    char *SHC_dest_cxx = new char[SHT_dest_len+1];
    char *src = static_cast<char *>(SHT_src_cfi->base_addr);
    size_t SHT_src_len = SHT_src_cfi->elem_len;
    char *SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 0);
    passCharPtr(SHC_dest_cxx, SHC_src_cxx);
    ShroudCharCopy(dest, SHT_dest_len, SHC_dest_cxx, -1);
    if (SHC_dest_cxx != nullptr) {
        delete[] SHC_dest_cxx;
    }
    ShroudCharFree(SHC_src_cxx);
    // splicer end function.passCharPtr_CFI
}
// end CHA_passCharPtr_CFI

/**
 * \brief toupper
 *
 * Change a string in-place.
 * For Python, return a new string since strings are immutable.
 */
// ----------------------------------------
// Function:  void passCharPtrInOut
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *s +intent(inout)
// Statement: c_inout_char*
// start CHA_passCharPtrInOut
void CHA_passCharPtrInOut(char *s)
{
    // splicer begin function.passCharPtrInOut
    passCharPtrInOut(s);
    // splicer end function.passCharPtrInOut
}
// end CHA_passCharPtrInOut

/**
 * \brief toupper
 *
 * Change a string in-place.
 * For Python, return a new string since strings are immutable.
 */
// ----------------------------------------
// Function:  void passCharPtrInOut
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *s +intent(inout)
// Statement: f_inout_char*_cfi
// start CHA_passCharPtrInOut_CFI
void CHA_passCharPtrInOut_CFI(CFI_cdesc_t *SHT_s_cfi)
{
    // splicer begin function.passCharPtrInOut_CFI
    char *s = static_cast<char *>(SHT_s_cfi->base_addr);
    size_t SHT_s_len = SHT_s_cfi->elem_len;
    char *SHC_s_cxx = ShroudCharAlloc(s, SHT_s_len, 0);
    passCharPtrInOut(SHC_s_cxx);
    ShroudCharCopy(s, SHT_s_len, SHC_s_cxx, -1);
    ShroudCharFree(SHC_s_cxx);
    // splicer end function.passCharPtrInOut_CFI
}
// end CHA_passCharPtrInOut_CFI

/**
 * \brief return 'const char *' with fixed size (len=30)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrLen +len(30)
// Statement: c_function_char*
// start CHA_getConstCharPtrLen
const char * CHA_getConstCharPtrLen(void)
{
    // splicer begin function.getConstCharPtrLen
    const char *SHC_rv = getConstCharPtrLen();
    return SHC_rv;
    // splicer end function.getConstCharPtrLen
}
// end CHA_getConstCharPtrLen

/**
 * \brief return 'const char *' with fixed size (len=30)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrLen +len(30)
// Statement: f_function_char*_cfi_copy
// start CHA_getConstCharPtrLen_CFI
void CHA_getConstCharPtrLen_CFI(CFI_cdesc_t *SHT_rv_cfi)
{
    // splicer begin function.getConstCharPtrLen_CFI
    char *SHC_rv = static_cast<char *>(SHT_rv_cfi->base_addr);
    size_t SHT_rv_len = SHT_rv_cfi->elem_len;
    const char *SHC_rv_cxx = getConstCharPtrLen();
    ShroudCharCopy(SHC_rv, SHT_rv_len, SHC_rv_cxx, -1);
    // splicer end function.getConstCharPtrLen_CFI
}
// end CHA_getConstCharPtrLen_CFI

/**
 * Return an ALLOCATABLE CHARACTER from char *.
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAlloc +deref(allocatable)
// Statement: c_function_char*
// start CHA_getConstCharPtrAlloc
const char * CHA_getConstCharPtrAlloc(void)
{
    // splicer begin function.getConstCharPtrAlloc
    const char *SHC_rv = getConstCharPtrAlloc();
    return SHC_rv;
    // splicer end function.getConstCharPtrAlloc
}
// end CHA_getConstCharPtrAlloc

/**
 * Return an ALLOCATABLE CHARACTER from char *.
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAlloc +deref(allocatable)
// Statement: f_function_char*_cfi_allocatable
// start CHA_getConstCharPtrAlloc_CFI
void CHA_getConstCharPtrAlloc_CFI(CFI_cdesc_t *SHT_rv_cfi)
{
    // splicer begin function.getConstCharPtrAlloc_CFI
    const char *SHC_rv = getConstCharPtrAlloc();
    if (SHC_rv != nullptr) {
        int SH_ret = CFI_allocate(SHT_rv_cfi, (CFI_index_t *) 0, 
            (CFI_index_t *) 0, strlen(SHC_rv));
        if (SH_ret == CFI_SUCCESS) {
            std::memcpy(SHT_rv_cfi->base_addr, SHC_rv, 
                SHT_rv_cfi->elem_len);
        }
    }
    // splicer end function.getConstCharPtrAlloc_CFI
}
// end CHA_getConstCharPtrAlloc_CFI

/**
 * \brief return a 'const char *' as character(:) pointer
 *
 */
#ifdef HAVE_CHARACTER_POINTER_FUNCTION
// ----------------------------------------
// Function:  const char *getConstCharPtrPointer +deref(pointer)
// Statement: c_function_char*
// start CHA_getConstCharPtrPointer
const char * CHA_getConstCharPtrPointer(void)
{
    // splicer begin function.getConstCharPtrPointer
    const char *SHC_rv = getConstCharPtrPointer();
    return SHC_rv;
    // splicer end function.getConstCharPtrPointer
}
// end CHA_getConstCharPtrPointer
#endif  // ifdef HAVE_CHARACTER_POINTER_FUNCTION

/**
 * \brief return a 'const char *' as character(:) pointer
 *
 */
#ifdef HAVE_CHARACTER_POINTER_FUNCTION
// ----------------------------------------
// Function:  const char *getConstCharPtrPointer +deref(pointer)
// Statement: f_function_char*_cfi_pointer_library
// start CHA_getConstCharPtrPointer_CFI
void CHA_getConstCharPtrPointer_CFI(CFI_cdesc_t *SHT_rv_cfi)
{
    // splicer begin function.getConstCharPtrPointer_CFI
    const char *SHC_rv = getConstCharPtrPointer();
    int SHC_rv_err;
    if (SHC_rv == nullptr) {
        SHC_rv_err = CFI_setpointer(SHT_rv_cfi, nullptr, nullptr);
    } else {
        CFI_CDESC_T(0) SHC_rv_fptr;
        CFI_cdesc_t *SHC_rv_cdesc = reinterpret_cast<CFI_cdesc_t *>
            (&SHC_rv_fptr);
        void *SHC_rv_cptr = const_cast<char *>(SHC_rv);
        size_t SHC_rv_len = std::strlen(SHC_rv);
        SHC_rv_err = CFI_establish(SHC_rv_cdesc, SHC_rv_cptr,
            CFI_attribute_pointer, CFI_type_char, SHC_rv_len, 0,
            nullptr);
        if (SHC_rv_err == CFI_SUCCESS) {
            SHT_rv_cfi->elem_len = SHC_rv_cdesc->elem_len;
            SHC_rv_err = CFI_setpointer(SHT_rv_cfi, SHC_rv_cdesc,
                nullptr);
        }
    }
    // splicer end function.getConstCharPtrPointer_CFI
}
// end CHA_getConstCharPtrPointer_CFI
#endif  // ifdef HAVE_CHARACTER_POINTER_FUNCTION

/**
 * \brief return a 'const char *' as type(C_PTR)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrRaw +deref(raw)
// Statement: c_function_char*
// start CHA_getConstCharPtrRaw
const char * CHA_getConstCharPtrRaw(void)
{
    // splicer begin function.getConstCharPtrRaw
    const char *SHC_rv = getConstCharPtrRaw();
    return SHC_rv;
    // splicer end function.getConstCharPtrRaw
}
// end CHA_getConstCharPtrRaw

/**
 * \brief return a 'const char *' as argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsCopyArg +deref(copy)+funcarg
// Statement: c_function_char*
// start CHA_getConstCharPtrAsCopyArg
const char * CHA_getConstCharPtrAsCopyArg(void)
{
    // splicer begin function.getConstCharPtrAsCopyArg
    const char *SHC_rv = getConstCharPtrAsCopyArg();
    return SHC_rv;
    // splicer end function.getConstCharPtrAsCopyArg
}
// end CHA_getConstCharPtrAsCopyArg

/**
 * \brief return a 'const char *' as argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsCopyArg +deref(copy)+funcarg
// Statement: f_function_char*_cfi_funcarg_copy
// start CHA_getConstCharPtrAsCopyArg_CFI
void CHA_getConstCharPtrAsCopyArg_CFI(CFI_cdesc_t *SHT_rv_cfi)
{
    // splicer begin function.getConstCharPtrAsCopyArg_CFI
    char *SHC_rv = static_cast<char *>(SHT_rv_cfi->base_addr);
    size_t SHT_rv_len = SHT_rv_cfi->elem_len;
    const char *SHC_rv_cxx = getConstCharPtrAsCopyArg();
    ShroudCharCopy(SHC_rv, SHT_rv_len, SHC_rv_cxx, -1);
    // splicer end function.getConstCharPtrAsCopyArg_CFI
}
// end CHA_getConstCharPtrAsCopyArg_CFI

/**
 * \brief return a 'const char *' as an allocatable argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsAllocArg +deref(allocatable)+funcarg
// Statement: f_function_char*_cfi_funcarg_allocatable
// start CHA_getConstCharPtrAsAllocArg_CFI
void CHA_getConstCharPtrAsAllocArg_CFI(CFI_cdesc_t *SHT_rv_cfi)
{
    // splicer begin function.getConstCharPtrAsAllocArg_CFI
    const char *SHC_rv = getConstCharPtrAsAllocArg();
    if (SHC_rv != nullptr) {
        int SH_ret = CFI_allocate(SHT_rv_cfi, (CFI_index_t *) 0, 
            (CFI_index_t *) 0, strlen(SHC_rv));
        if (SH_ret == CFI_SUCCESS) {
            std::memcpy(SHT_rv_cfi->base_addr, SHC_rv, 
                SHT_rv_cfi->elem_len);
        }
    }
    // splicer end function.getConstCharPtrAsAllocArg_CFI
}
// end CHA_getConstCharPtrAsAllocArg_CFI

/**
 * \brief return a 'const char *' as an pointer argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsPointerArg +deref(pointer)+funcarg
// Statement: f_function_char*_cfi_funcarg_pointer_library
// start CHA_getConstCharPtrAsPointerArg_CFI
void CHA_getConstCharPtrAsPointerArg_CFI(CFI_cdesc_t *SHT_rv_cfi)
{
    // splicer begin function.getConstCharPtrAsPointerArg_CFI
    const char *SHC_rv = getConstCharPtrAsPointerArg();
    int SHC_rv_err;
    if (SHC_rv == nullptr) {
        SHC_rv_err = CFI_setpointer(SHT_rv_cfi, nullptr, nullptr);
    } else {
        CFI_CDESC_T(0) SHC_rv_fptr;
        CFI_cdesc_t *SHC_rv_cdesc = reinterpret_cast<CFI_cdesc_t *>
            (&SHC_rv_fptr);
        void *SHC_rv_cptr = const_cast<char *>(SHC_rv);
        size_t SHC_rv_len = std::strlen(SHC_rv);
        SHC_rv_err = CFI_establish(SHC_rv_cdesc, SHC_rv_cptr,
            CFI_attribute_pointer, CFI_type_char, SHC_rv_len, 0,
            nullptr);
        if (SHC_rv_err == CFI_SUCCESS) {
            SHT_rv_cfi->elem_len = SHC_rv_cdesc->elem_len;
            SHC_rv_err = CFI_setpointer(SHT_rv_cfi, SHC_rv_cdesc,
                nullptr);
        }
    }
    // splicer end function.getConstCharPtrAsPointerArg_CFI
}
// end CHA_getConstCharPtrAsPointerArg_CFI

/**
 * \brief return a 'const char *' as a type(C_PTR) argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsRawArg +deref(raw)+funcarg
// Statement: f_function_char*_funcarg_raw_library
// start CHA_getConstCharPtrAsRawArg_bufferify
void CHA_getConstCharPtrAsRawArg_bufferify(void **SHC_rv)
{
    // splicer begin function.getConstCharPtrAsRawArg_bufferify
    const char *SHC_rv_cxx = getConstCharPtrAsRawArg();
    *SHC_rv = const_cast<char *>(SHC_rv_cxx);
    // splicer end function.getConstCharPtrAsRawArg_bufferify
}
// end CHA_getConstCharPtrAsRawArg_bufferify

// ----------------------------------------
// Function:  void explicit1
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *name +intent(in)+len_trim(AAlen)
// Statement: c_in_char*
// start CHA_explicit1
void CHA_explicit1(char *name)
{
    // splicer begin function.explicit1
    explicit1(name);
    // splicer end function.explicit1
}
// end CHA_explicit1

// ----------------------------------------
// Function:  void explicit1
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *name +intent(in)+len_trim(AAlen)
// Statement: f_in_char*_cfi
// start CHA_explicit1_CFI
void CHA_explicit1_CFI(CFI_cdesc_t *SHT_name_cfi)
{
    // splicer begin function.explicit1_CFI
    char *name = static_cast<char *>(SHT_name_cfi->base_addr);
    size_t SHT_name_len = SHT_name_cfi->elem_len;
    char *SHC_name_cxx = ShroudCharAlloc(name, SHT_name_len, 0);
    explicit1(SHC_name_cxx);
    ShroudCharFree(SHC_name_cxx);
    // splicer end function.explicit1_CFI
}
// end CHA_explicit1_CFI

// ----------------------------------------
// Function:  void explicit2
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *name +intent(out)+len(AAtrim)
// Statement: c_out_char*
// start CHA_explicit2
void CHA_explicit2(char *name)
{
    // splicer begin function.explicit2
    explicit2(name);
    // splicer end function.explicit2
}
// end CHA_explicit2

// ----------------------------------------
// Function:  void explicit2
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *name +intent(out)+len(AAtrim)
// Statement: f_out_char*_cfi
// start CHA_explicit2_CFI
void CHA_explicit2_CFI(CFI_cdesc_t *SHT_name_cfi)
{
    // splicer begin function.explicit2_CFI
    char *name = static_cast<char *>(SHT_name_cfi->base_addr);
    size_t SHT_name_len = SHT_name_cfi->elem_len;
    char *SHC_name_cxx = new char[SHT_name_len+1];
    explicit2(SHC_name_cxx);
    ShroudCharCopy(name, SHT_name_len, SHC_name_cxx, -1);
    if (SHC_name_cxx != nullptr) {
        delete[] SHC_name_cxx;
    }
    // splicer end function.explicit2_CFI
}
// end CHA_explicit2_CFI

/**
 * \brief pass a single char argument as a scalar, extern "C"
 *
 */
// ----------------------------------------
// Function:  void CpassChar
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
// start CHA_CpassChar
void CHA_CpassChar(char status)
{
    // splicer begin function.CpassChar
    CpassChar(status);
    // splicer end function.CpassChar
}
// end CHA_CpassChar

/**
 * \brief return a char argument (non-pointer), extern "C"
 *
 */
// ----------------------------------------
// Function:  char CreturnChar
// Statement: c_function_char
// start CHA_CreturnChar
void CHA_CreturnChar(char *SHC_rv)
{
    // splicer begin function.CreturnChar
    *SHC_rv = CreturnChar();
    // splicer end function.CreturnChar
}
// end CHA_CreturnChar

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * extern "C"
 * If src is a blank string, pass a NULL pointer to C library function.
 */
// ----------------------------------------
// Function:  void CpassCharPtr
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: f_out_char*_cfi
// ----------------------------------------
// Argument:  const char *src +blanknull
// Statement: f_in_char*_cfi
// start CHA_CpassCharPtr_CFI
void CHA_CpassCharPtr_CFI(CFI_cdesc_t *SHT_dest_cfi,
    CFI_cdesc_t *SHT_src_cfi)
{
    // splicer begin function.CpassCharPtr_CFI
    char *dest = static_cast<char *>(SHT_dest_cfi->base_addr);
    size_t SHT_dest_len = SHT_dest_cfi->elem_len;
    char *SHC_dest_cxx = new char[SHT_dest_len+1];
    char *src = static_cast<char *>(SHT_src_cfi->base_addr);
    size_t SHT_src_len = SHT_src_cfi->elem_len;
    char *SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 1);
    CpassCharPtr(SHC_dest_cxx, SHC_src_cxx);
    ShroudCharCopy(dest, SHT_dest_len, SHC_dest_cxx, -1);
    if (SHC_dest_cxx != nullptr) {
        delete[] SHC_dest_cxx;
    }
    ShroudCharFree(SHC_src_cxx);
    // splicer end function.CpassCharPtr_CFI
}
// end CHA_CpassCharPtr_CFI

/**
 * \brief Test F_blanknull option
 *
 */
// ----------------------------------------
// Function:  void CpassCharPtrBlank
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: c_out_char*
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_CpassCharPtrBlank
void CHA_CpassCharPtrBlank(char *dest, const char *src)
{
    // splicer begin function.CpassCharPtrBlank
    CpassCharPtrBlank(dest, src);
    // splicer end function.CpassCharPtrBlank
}
// end CHA_CpassCharPtrBlank

/**
 * \brief Test F_blanknull option
 *
 */
// ----------------------------------------
// Function:  void CpassCharPtrBlank
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: f_out_char*_cfi
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_cfi
// start CHA_CpassCharPtrBlank_CFI
void CHA_CpassCharPtrBlank_CFI(CFI_cdesc_t *SHT_dest_cfi,
    CFI_cdesc_t *SHT_src_cfi)
{
    // splicer begin function.CpassCharPtrBlank_CFI
    char *dest = static_cast<char *>(SHT_dest_cfi->base_addr);
    size_t SHT_dest_len = SHT_dest_cfi->elem_len;
    char *SHC_dest_cxx = new char[SHT_dest_len+1];
    char *src = static_cast<char *>(SHT_src_cfi->base_addr);
    size_t SHT_src_len = SHT_src_cfi->elem_len;
    char *SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 1);
    CpassCharPtrBlank(SHC_dest_cxx, SHC_src_cxx);
    ShroudCharCopy(dest, SHT_dest_len, SHC_dest_cxx, -1);
    if (SHC_dest_cxx != nullptr) {
        delete[] SHC_dest_cxx;
    }
    ShroudCharFree(SHC_src_cxx);
    // splicer end function.CpassCharPtrBlank_CFI
}
// end CHA_CpassCharPtrBlank_CFI

/**
 * \brief NULL terminate input string in C, not in Fortran.
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrNotrim
// Statement: c_function_native
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_CpassCharPtrNotrim
int CHA_CpassCharPtrNotrim(const char *src)
{
    // splicer begin function.CpassCharPtrNotrim
    int SHC_rv = CpassCharPtrNotrim(src);
    return SHC_rv;
    // splicer end function.CpassCharPtrNotrim
}
// end CHA_CpassCharPtrNotrim

/**
 * \brief NULL terminate input string in C, not in Fortran.
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrNotrim
// Statement: f_function_native
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_cfi
// start CHA_CpassCharPtrNotrim_CFI
int CHA_CpassCharPtrNotrim_CFI(CFI_cdesc_t *SHT_src_cfi)
{
    // splicer begin function.CpassCharPtrNotrim_CFI
    char *src = static_cast<char *>(SHT_src_cfi->base_addr);
    size_t SHT_src_len = SHT_src_cfi->elem_len;
    char *SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 0);
    int SHC_rv = CpassCharPtrNotrim(SHC_src_cxx);
    ShroudCharFree(SHC_src_cxx);
    return SHC_rv;
    // splicer end function.CpassCharPtrNotrim_CFI
}
// end CHA_CpassCharPtrNotrim_CFI

/**
 * \brief Do not NULL terminate input string
 *
 * The C library function should get the same address
 * for addr and src.
 * Used when the C function needs the true address of the argument.
 * Skips null-termination. Useful to create an interface for
 * a function which is already callable by Fortran.
 * For example, the length is passed explicitly.
 * This example will not create a Fortran wrapper since C can be
 * called directly.
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI
// Statement: c_function_native
// ----------------------------------------
// Argument:  void *addr
// Statement: c_in_void*
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: c_in_char*
// start CHA_CpassCharPtrCAPI
int CHA_CpassCharPtrCAPI(void *addr, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI
    int SHC_rv = CpassCharPtrCAPI(addr, src);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI
}
// end CHA_CpassCharPtrCAPI

/**
 * \brief Mix api(buf) and api(capi)
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI2
// Statement: c_function_native
// ----------------------------------------
// Argument:  const char *in
// Statement: c_in_char*
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: c_in_char*
// start CHA_CpassCharPtrCAPI2
int CHA_CpassCharPtrCAPI2(const char *in, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI2
    int SHC_rv = CpassCharPtrCAPI2(in, src);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI2
}
// end CHA_CpassCharPtrCAPI2

/**
 * \brief Mix api(buf) and api(capi)
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI2
// Statement: f_function_native
// ----------------------------------------
// Argument:  const char *in
// Statement: f_in_char*_cfi
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: f_in_char*_capi
// start CHA_CpassCharPtrCAPI2_CFI
int CHA_CpassCharPtrCAPI2_CFI(CFI_cdesc_t *SHT_in_cfi, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI2_CFI
    char *in = static_cast<char *>(SHT_in_cfi->base_addr);
    size_t SHT_in_len = SHT_in_cfi->elem_len;
    char *SHC_in_cxx = ShroudCharAlloc(in, SHT_in_len, 0);
    int SHC_rv = CpassCharPtrCAPI2(SHC_in_cxx, src);
    ShroudCharFree(SHC_in_cxx);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI2_CFI
}
// end CHA_CpassCharPtrCAPI2_CFI

/**
 * Return strlen of the first index as a check.
 */
// ----------------------------------------
// Function:  int acceptCharArrayIn
// Statement: c_function_native
// ----------------------------------------
// Argument:  char **names +intent(in)
// Statement: c_in_char**
// start CHA_acceptCharArrayIn
int CHA_acceptCharArrayIn(char **names)
{
    // splicer begin function.acceptCharArrayIn
    int SHC_rv = acceptCharArrayIn(names);
    return SHC_rv;
    // splicer end function.acceptCharArrayIn
}
// end CHA_acceptCharArrayIn

/**
 * Return strlen of the first index as a check.
 */
// ----------------------------------------
// Function:  int acceptCharArrayIn
// Statement: f_function_native
// ----------------------------------------
// Argument:  char **names +intent(in)
// Statement: f_in_char**_cfi
// start CHA_acceptCharArrayIn_CFI
int CHA_acceptCharArrayIn_CFI(CFI_cdesc_t *SHT_names_cfi)
{
    // splicer begin function.acceptCharArrayIn_CFI
    char *names = static_cast<char *>(SHT_names_cfi->base_addr);
    size_t SHT_names_len = SHT_names_cfi->elem_len;
    size_t SHT_names_size = SHT_names_cfi->dim[0].extent;
    char **SHC_names_cxx = ShroudStrArrayAlloc(names, SHT_names_size,
        SHT_names_len);
    int SHC_rv = acceptCharArrayIn(SHC_names_cxx);
    ShroudStrArrayFree(SHC_names_cxx, SHT_names_size);
    return SHC_rv;
    // splicer end function.acceptCharArrayIn_CFI
}
// end CHA_acceptCharArrayIn_CFI

/**
 * Copy a char array owned by the library.
 */
// ----------------------------------------
// Function:  void fetchCharPtrCopyLibrary
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char **outstr +deref(copy)+intent(out)
// Statement: c_out_char**
// start CHA_fetchCharPtrCopyLibrary
void CHA_fetchCharPtrCopyLibrary(char **outstr)
{
    // splicer begin function.fetchCharPtrCopyLibrary
    fetchCharPtrCopyLibrary(outstr);
    // splicer end function.fetchCharPtrCopyLibrary
}
// end CHA_fetchCharPtrCopyLibrary

/**
 * Copy a char array owned by the library.
 */
// ----------------------------------------
// Function:  void fetchCharPtrCopyLibrary
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char **outstr +deref(copy)+intent(out)
// Statement: f_out_char**_buf_copy
// start CHA_fetchCharPtrCopyLibrary_bufferify
void CHA_fetchCharPtrCopyLibrary_bufferify(char *outstr,
    int SHT_outstr_len)
{
    // splicer begin function.fetchCharPtrCopyLibrary_bufferify
    char *SHC_outstr_cxx;
    fetchCharPtrCopyLibrary(&SHC_outstr_cxx);
    ShroudCharCopy(outstr, SHT_outstr_len, SHC_outstr_cxx, -1);
    // splicer end function.fetchCharPtrCopyLibrary_bufferify
}
// end CHA_fetchCharPtrCopyLibrary_bufferify

/**
 * Fetch a pointer to a char array owned by the library.
 */
// ----------------------------------------
// Function:  void fetchCharPtrLibrary
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char **outstr +deref(pointer)+intent(out)
// Statement: c_out_char**
// start CHA_fetchCharPtrLibrary
void CHA_fetchCharPtrLibrary(char **outstr)
{
    // splicer begin function.fetchCharPtrLibrary
    fetchCharPtrLibrary(outstr);
    // splicer end function.fetchCharPtrLibrary
}
// end CHA_fetchCharPtrLibrary

/**
 * Fetch a pointer to a char array owned by the library.
 */
// ----------------------------------------
// Function:  void fetchCharPtrLibrary
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char **outstr +deref(pointer)+intent(out)
// Statement: f_out_char**_cfi_pointer_library
// start CHA_fetchCharPtrLibrary_CFI
void CHA_fetchCharPtrLibrary_CFI(CFI_cdesc_t *SHT_outstr_cfi)
{
    // splicer begin function.fetchCharPtrLibrary_CFI
    char *outstr;
    fetchCharPtrLibrary(&outstr);
    int SHC_outstr_err;
    if (outstr == nullptr) {
        SHC_outstr_err = CFI_setpointer(SHT_outstr_cfi, nullptr,
            nullptr);
    } else {
        CFI_CDESC_T(0) SHC_outstr_fptr;
        CFI_cdesc_t *SHC_outstr_cdesc = reinterpret_cast<CFI_cdesc_t *>
            (&SHC_outstr_fptr);
        void *SHC_outstr_cptr = outstr;
        size_t SHC_outstr_len = std::strlen(outstr);
        SHC_outstr_err = CFI_establish(SHC_outstr_cdesc,
            SHC_outstr_cptr, CFI_attribute_pointer, CFI_type_char,
            SHC_outstr_len, 0, nullptr);
        if (SHC_outstr_err == CFI_SUCCESS) {
            SHT_outstr_cfi->elem_len = SHC_outstr_cdesc->elem_len;
            SHC_outstr_err = CFI_setpointer(SHT_outstr_cfi,
                SHC_outstr_cdesc, nullptr);
        }
    }
    // splicer end function.fetchCharPtrLibrary_CFI
}
// end CHA_fetchCharPtrLibrary_CFI

/**
 * Fetch a NULL pointer to a char array owned by the library.
 * Return a value to test Python returning a tuple.
 */
// ----------------------------------------
// Function:  int fetchCharPtrLibraryNULL
// Statement: c_function_native
// ----------------------------------------
// Argument:  char **outstr +deref(pointer)+intent(out)
// Statement: c_out_char**
// start CHA_fetchCharPtrLibraryNULL
int CHA_fetchCharPtrLibraryNULL(char **outstr)
{
    // splicer begin function.fetchCharPtrLibraryNULL
    int SHC_rv = fetchCharPtrLibraryNULL(outstr);
    return SHC_rv;
    // splicer end function.fetchCharPtrLibraryNULL
}
// end CHA_fetchCharPtrLibraryNULL

/**
 * Fetch a NULL pointer to a char array owned by the library.
 * Return a value to test Python returning a tuple.
 */
// ----------------------------------------
// Function:  int fetchCharPtrLibraryNULL
// Statement: f_function_native
// ----------------------------------------
// Argument:  char **outstr +deref(pointer)+intent(out)
// Statement: f_out_char**_cfi_pointer_library
// start CHA_fetchCharPtrLibraryNULL_CFI
int CHA_fetchCharPtrLibraryNULL_CFI(CFI_cdesc_t *SHT_outstr_cfi)
{
    // splicer begin function.fetchCharPtrLibraryNULL_CFI
    char *outstr;
    int SHC_rv = fetchCharPtrLibraryNULL(&outstr);
    int SHC_outstr_err;
    if (outstr == nullptr) {
        SHC_outstr_err = CFI_setpointer(SHT_outstr_cfi, nullptr,
            nullptr);
    } else {
        CFI_CDESC_T(0) SHC_outstr_fptr;
        CFI_cdesc_t *SHC_outstr_cdesc = reinterpret_cast<CFI_cdesc_t *>
            (&SHC_outstr_fptr);
        void *SHC_outstr_cptr = outstr;
        size_t SHC_outstr_len = std::strlen(outstr);
        SHC_outstr_err = CFI_establish(SHC_outstr_cdesc,
            SHC_outstr_cptr, CFI_attribute_pointer, CFI_type_char,
            SHC_outstr_len, 0, nullptr);
        if (SHC_outstr_err == CFI_SUCCESS) {
            SHT_outstr_cfi->elem_len = SHC_outstr_cdesc->elem_len;
            SHC_outstr_err = CFI_setpointer(SHT_outstr_cfi,
                SHC_outstr_cdesc, nullptr);
        }
    }
    return SHC_rv;
    // splicer end function.fetchCharPtrLibraryNULL_CFI
}
// end CHA_fetchCharPtrLibraryNULL_CFI

}  // extern "C"

***** Fortran/C
root
  c
    ctor
      shadow
        scalar
          capptr -- f_ctor_shadow_scalar_capptr
    defaulttmp -- c_defaulttmp
    dtor -- f_dtor
    function -- c_function
      bool
        scalar -- f_function_bool_scalar
      char
        * -- f_function_char_*
          arg -- f_function_char_*_arg
          buf
            arg -- f_function_char_*_arg
            copy -- f_function_char_*_buf_copy
        scalar -- f_function_char_scalar
      native
        & -- f_function_native_*_raw
        * -- f_function_native_*_raw
          caller -- f_function_native_*_raw
          scalar -- c_function_native_*_scalar
        ** -- f_function_native_*_raw
        scalar -- f_function_native_scalar
      shadow
        &
          capptr -- f_function_shadow_*/&_capptr
            caller -- f_function_shadow_*/&_capptr
            library -- f_function_shadow_*/&_capptr
        *
          capptr -- f_function_shadow_*/&_capptr
            caller -- f_function_shadow_*/&_capptr
            library -- f_function_shadow_*/&_capptr
          capsule -- f_function_shadow_*_capsule
          this -- f_function_shadow_*_this
        scalar
          capptr -- f_function_shadow_scalar_capptr
            targ
              native
                scalar -- f_function_shadow_scalar_capptr
      string
        & -- f_shared_function_string_scalar
          buf
            arg -- f_function_string_scalar_buf_arg
            copy -- f_function_string_scalar_buf
          copy -- f_shared_function_string_scalar
        * -- f_shared_function_string_scalar
          buf
            copy -- f_function_string_scalar_buf
          caller -- f_shared_function_string_scalar
          copy -- f_shared_function_string_scalar
          library -- f_shared_function_string_scalar
        scalar -- c_function_string_scalar
          buf
            arg -- f_function_string_scalar_buf_arg
            copy -- f_function_string_scalar_buf
      struct
        * -- f_function_struct_*_pointer
        scalar -- f_function_struct_scalar
      vector
        scalar
          malloc
            targ
              native
                scalar -- c_function_vector_scalar_malloc_targ_native_scalar
          targ
            native
              scalar -- c_function_vector_scalar_targ_native_scalar
      void
        * -- f_function_void_*
    getter
      native
        * -- f_getter_native_scalar
        scalar -- f_getter_native_scalar
    in
      bool
        scalar -- f_in_bool_scalar
      char
        * -- f_shared_native_scalar
          buf -- f_in_char_*_buf
        ** -- f_in_char_**
          buf -- f_in_char_**_buf
        scalar -- f_in_char_scalar
      native
        & -- f_shared_native_scalar
        * -- f_shared_native_scalar
          cdesc -- f_in/out/inout_native_*_cdesc
        ** -- f_in_native_**
        scalar -- f_shared_native_scalar
      shadow
        & -- f_in_shadow_&
        * -- f_in_shadow_*
        scalar -- f_in_shadow_scalar
      string
        & -- f_in_string_*/&
          buf -- f_in_string_*/&_buf
        * -- f_in_string_*/&
          buf -- f_in_string_*/&_buf
        scalar -- f_in_string_scalar
          buf -- f_in_string_scalar_buf
      struct
        & -- f_shared_struct
        * -- f_shared_struct
        scalar -- f_shared_struct
      unknown
        scalar -- f_shared_native_scalar
      vector
        &
          buf
            targ
              native
                * -- f_in_vector_&_buf_targ_native_*
                scalar -- f_in_vector_scalar/*/&_buf_targ_native_scalar
              string
                scalar -- f_in_vector_scalar/*/&_buf_targ_string_scalar
          targ
            native
              * -- c_shared_vector_argument
              scalar -- c_shared_vector_argument
            string
              scalar -- c_shared_vector_argument
        *
          buf
            targ
              native
                scalar -- f_in_vector_scalar/*/&_buf_targ_native_scalar
              string
                scalar -- f_in_vector_scalar/*/&_buf_targ_string_scalar
        scalar
          buf
            targ
              native
                scalar -- f_in_vector_scalar/*/&_buf_targ_native_scalar
              string
                scalar -- f_in_vector_scalar/*/&_buf_targ_string_scalar
      void
        * -- f_in_void_*
          cdesc -- f_in/out/inout_native_*_cdesc
        ** -- f_in/out/inout_void_**
        scalar -- f_shared_native_scalar
    inout
      bool
        * -- f_inout_bool_*
      char
        * -- f_shared_native_scalar
          buf -- f_inout_char_*_buf
      native
        & -- f_shared_native_scalar
          hidden -- f_out/inout_native_&_hidden
        * -- f_shared_native_scalar
          cdesc -- f_in/out/inout_native_*_cdesc
          hidden -- f_out/inout_native_*_hidden
      shadow
        & -- f_in_shadow_*
        * -- f_in_shadow_*
      string
        & -- f_inout_string_*/&
          buf -- f_inout_string_*/&_buf
        * -- f_inout_string_*/&
          buf -- f_inout_string_*/&_buf
      struct
        & -- f_shared_struct
        * -- f_shared_struct
      vector
        &
          buf
            copy
              targ
                native
                  scalar -- c_inout_vector_scalar/*/&_buf_copy_targ_native_scalar
            malloc
              targ
                native
                  scalar -- c_inout_vector_scalar/*/&_buf_malloc_targ_native_scalar
          targ
            native
              scalar -- c_shared_vector_argument
        *
          buf
            copy
              targ
                native
                  scalar -- c_inout_vector_scalar/*/&_buf_copy_targ_native_scalar
            malloc
              targ
                native
                  scalar -- c_inout_vector_scalar/*/&_buf_malloc_targ_native_scalar
        scalar
          buf
            copy
              targ
                native
                  scalar -- c_inout_vector_scalar/*/&_buf_copy_targ_native_scalar
            malloc
              targ
                native
                  scalar -- c_inout_vector_scalar/*/&_buf_malloc_targ_native_scalar
      void
        *
          cdesc -- f_in/out/inout_native_*_cdesc
        ** -- f_in/out/inout_void_**
    mixin
      arg
        cfi -- c_mixin_arg_cfi
        character
          cfi -- c_mixin_arg_character_cfi
        native
          cfi -- c_mixin_arg_native_cfi
      destructor
        new-string -- c_mixin_destructor_new-string
        new-vector -- c_mixin_destructor_new-vector
      function
        array
          malloc -- c_mixin_function_array_malloc
        char
          *
            cdesc -- c_mixin_function_char_*_cdesc
        string
          cdesc -- c_mixin_function_string_cdesc
      in
        character
          buf -- c_mixin_in_character_buf
      inout
        array
          cdesc -- c_mixin_inout_array_cdesc
        vector
          cdesc
            targ
              native
                scalar -- c_mixin_inout_vector_cdesc_targ_native_scalar
      native
        capsule
          fill -- c_mixin_native_capsule_fill
        cdesc
          fill-cdesc -- c_mixin_native_cdesc_fill-cdesc
        cfi
          allocatable -- c_mixin_native_cfi_allocatable
          pointer -- c_mixin_native_cfi_pointer
      noargs -- c_mixin_noargs
      out
        array
          buf
            malloc -- c_mixin_out_array_buf_malloc
        native
          ** -- c_mixin_out_native_**
        vector
          cdesc
            targ
              native
                scalar -- c_mixin_out_vector_cdesc_targ_native_scalar
      shadow -- c_mixin_shadow
      unknown -- c_mixin_unknown
      vector
        cdesc
          fill-cdesc -- c_mixin_vector_cdesc_fill-cdesc
    out
      bool
        * -- f_out_bool_*
      char
        * -- f_shared_native_scalar
          buf -- f_out_char_*_buf
      native
        & -- f_shared_native_scalar
          hidden -- f_out/inout_native_&_hidden
        &* -- c_defaulttmp
        * -- f_out_native_*
          cdesc -- f_in/out/inout_native_*_cdesc
          hidden -- f_out/inout_native_*_hidden
        *& -- f_shared_native_scalar
        ** -- f_out_native_**_raw
          raw -- f_out_native_**_raw
        *** -- f_shared_native_scalar
      string
        & -- f_out_string_*/&
          buf -- f_out_string_*/&_buf
        * -- f_out_string_*/&
          buf -- f_out_string_*/&_buf
        ** -- f_out_string_**_copy
          cdesc
            copy -- f_out_string_**_cdesc_copy
      struct
        & -- f_shared_struct
        * -- f_shared_struct
      vector
        &
          buf
            copy
              targ
                native
                  scalar -- c_out_vector_scalar/*/&_buf_copy_targ_native_scalar
                string
                  scalar -- c_out_vector_scalar/*/&_buf_copy_targ_string_scalar
            malloc
              targ
                native
                  scalar -- c_out_vector_scalar/*/&_buf_malloc_targ_native_scalar
          cdesc
            allocatable
              targ
                string
                  scalar -- f_out_vector_&_cdesc_allocatable_targ_string_scalar
            targ
              native
                scalar -- f_out_vector_*/&_cdesc_targ_native_scalar
              string
                scalar -- f_out_vector_&_cdesc_targ_string_scalar
          targ
            native
              scalar -- c_shared_vector_argument
            string
              scalar -- c_shared_vector_argument
        *
          buf
            copy
              targ
                native
                  scalar -- c_out_vector_scalar/*/&_buf_copy_targ_native_scalar
                string
                  scalar -- c_out_vector_scalar/*/&_buf_copy_targ_string_scalar
            malloc
              targ
                native
                  scalar -- c_out_vector_scalar/*/&_buf_malloc_targ_native_scalar
          cdesc
            targ
              native
                scalar -- f_out_vector_*/&_cdesc_targ_native_scalar
        scalar
          buf
            copy
              targ
                native
                  scalar -- c_out_vector_scalar/*/&_buf_copy_targ_native_scalar
                string
                  scalar -- c_out_vector_scalar/*/&_buf_copy_targ_string_scalar
            malloc
              targ
                native
                  scalar -- c_out_vector_scalar/*/&_buf_malloc_targ_native_scalar
      void
        *
          cdesc -- f_in/out/inout_native_*_cdesc
        *& -- f_shared_native_scalar
        ** -- f_in/out/inout_void_**
    setter -- f_setter
      native
        * -- f_setter_native_scalar/*
        scalar -- f_setter_native_scalar/*
      string
        scalar
          buf -- f_setter_string_scalar_buf
    shared
      vector
        argument -- c_shared_vector_argument
    subroutine -- f_subroutine
    test -- c_test
  f
    XXXin
      string
        scalar -- f_XXXin_string_scalar
    ctor
      shadow
        scalar
          capptr -- f_ctor_shadow_scalar_capptr
    defaulttmp -- f_defaulttmp
    dtor -- f_dtor
    function
      bool
        scalar -- f_function_bool_scalar
      char
        * -- f_function_char_*
          allocatable -- f_function_char_*
          arg -- f_function_char_*_arg
          buf
            arg -- f_function_char_*_arg
            copy -- f_function_char_*_buf_copy
          cdesc
            allocatable -- f_function_char_scalar_cdesc_allocatable
            pointer -- f_function_char_scalar_cdesc_pointer
          cfi
            allocatable -- f_function_char_*_cfi_allocatable
            arg -- f_function_char_*_cfi_arg
            copy -- f_function_char_*_cfi_copy
            pointer -- f_function_char_scalar_cfi_pointer
          copy -- f_function_char_*
          pointer -- f_function_char_*
          raw -- f_function_char_*
        scalar -- f_function_char_scalar
          cdesc
            allocatable -- f_function_char_scalar_cdesc_allocatable
            pointer -- f_function_char_scalar_cdesc_pointer
          cfi
            allocatable -- f_function_char_*_cfi_allocatable
            pointer -- f_function_char_scalar_cfi_pointer
      native
        & -- f_function_native_&
          pointer -- f_function_native_&
        *
          cdesc
            allocatable -- f_function_native_*_cdesc_allocatable
            pointer -- f_function_native_*_cdesc_pointer
              caller -- f_function_native_*_cdesc_pointer_caller
          cfi
            allocatable -- f_function_native_*_cfi_allocatable
            pointer -- f_function_native_*_cfi_pointer
          pointer -- f_function_native_&
            caller -- f_function_native_&
          raw -- f_function_native_*_raw
          scalar -- f_function_native_*_scalar
        ** -- f_function_native_*_raw
        scalar -- f_function_native_scalar
      shadow
        &
          capptr -- f_function_shadow_*/&_capptr
            caller -- f_function_shadow_*/&_capptr
            library -- f_function_shadow_*/&_capptr
        *
          capptr -- f_function_shadow_*/&_capptr
            caller -- f_function_shadow_*/&_capptr
            library -- f_function_shadow_*/&_capptr
          capsule -- f_function_shadow_*_capsule
          this -- f_function_shadow_*_this
        scalar
          capptr -- f_function_shadow_scalar_capptr
            caller -- f_function_shadow_scalar_capptr
            library -- f_function_shadow_scalar_capptr
            targ
              native
                scalar -- f_function_shadow_scalar_capptr
      string
        &
          buf -- f_function_string_scalar_buf
            arg -- f_function_string_scalar_buf_arg
            copy -- f_function_string_scalar_buf
          cdesc
            allocatable -- f_function_string_*_cdesc_allocatable
              caller -- f_function_string_*_cdesc_allocatable
              library -- f_function_string_*_cdesc_allocatable
            pointer -- f_function_string_*_cdesc_pointer
              caller -- f_function_string_*_cdesc_pointer
              library -- f_function_string_*_cdesc_pointer
          cfi
            allocatable -- f_function_string_*/&_cfi_allocatable
              caller -- f_function_string_*/&_cfi_allocatable
              library -- f_function_string_*/&_cfi_allocatable
            arg -- f_function_string_scalar_cfi_arg
            copy -- f_function_string_scalar_cfi_copy
            pointer -- f_shared_function_string_*_cfi_pointer
              caller -- f_shared_function_string_*_cfi_pointer
              library -- f_shared_function_string_*_cfi_pointer
        *
          buf -- f_function_string_scalar_buf
            copy -- f_function_string_scalar_buf
          cdesc
            allocatable -- f_function_string_*_cdesc_allocatable
              caller -- f_function_string_*_cdesc_allocatable
              library -- f_function_string_*_cdesc_allocatable
            pointer -- f_function_string_*_cdesc_pointer
              caller -- f_function_string_*_cdesc_pointer
              library -- f_function_string_*_cdesc_pointer
          cfi
            allocatable -- f_function_string_*/&_cfi_allocatable
              caller -- f_function_string_*/&_cfi_allocatable
              library -- f_function_string_*/&_cfi_allocatable
            copy -- f_function_string_scalar_cfi_copy
            pointer -- f_shared_function_string_*_cfi_pointer
              caller -- f_shared_function_string_*_cfi_pointer
              library -- f_shared_function_string_*_cfi_pointer
        scalar
          buf -- f_function_string_scalar_buf
            arg -- f_function_string_scalar_buf_arg
            copy -- f_function_string_scalar_buf
          cdesc
            allocatable -- f_function_string_scalar_cdesc_allocatable
              caller -- f_function_string_scalar_cdesc_allocatable
              library -- f_function_string_scalar_cdesc_allocatable
          cfi
            allocatable -- f_function_string_scalar_cfi_allocatable
              caller -- f_function_string_*/&_cfi_allocatable
              library -- f_function_string_*/&_cfi_allocatable
            arg -- f_function_string_scalar_cfi_arg
            copy -- f_function_string_scalar_cfi_copy
            pointer -- f_shared_function_string_*_cfi_pointer
              caller -- f_shared_function_string_*_cfi_pointer
              library -- f_shared_function_string_*_cfi_pointer
      struct
        *
          cdesc
            pointer -- f_function_native_*_cdesc_pointer
          pointer -- f_function_struct_*_pointer
        scalar -- f_function_struct_scalar
      vector
        scalar
          cdesc -- f_function_vector_scalar_cdesc
            allocatable
              targ
                native
                  scalar -- f_function_vector_scalar_cdesc_allocatable_targ_native_scalar
      void
        * -- f_function_void_*
    getter
      bool
        scalar -- f_getter_bool_scalar
      native
        *
          cdesc
            pointer -- f_getter_native_*_cdesc_pointer
          pointer -- f_getter_native_scalar
        scalar -- f_getter_native_scalar
      string
        scalar
          cdesc
            allocatable -- f_getter_string_scalar_cdesc_allocatable
      struct
        *
          cdesc
            pointer -- f_getter_native_*_cdesc_pointer
          fapi
            pointer -- f_getter_struct_*_fapi_pointer
        **
          cdesc
            raw -- f_getter_struct_**_cdesc_raw
    in
      bool
        scalar -- f_in_bool_scalar
      char
        * -- f_shared_native_scalar
          buf -- f_in_char_*_buf
          capi -- f_shared_native_scalar
          cfi -- f_in_char_*_cfi
        ** -- f_in_char_**
          buf -- f_in_char_**_buf
          cfi -- f_in_char_**_cfi
        scalar -- f_in_char_scalar
      native
        & -- f_shared_native_scalar
        * -- f_shared_native_scalar
          cdesc -- f_in/out/inout_native_*_cdesc
          cfi -- f_in/inout_native_*_cfi
        ** -- f_in_native_**
        scalar -- f_shared_native_scalar
      shadow
        & -- f_in_shadow_&
        * -- f_in_shadow_*
        scalar -- f_in_shadow_scalar
      string
        & -- f_in_string_*/&
          buf -- f_in_string_*/&_buf
          cfi -- f_in_string_scalar/*/&_cfi
        * -- f_in_string_*/&
          buf -- f_in_string_*/&_buf
          cfi -- f_in_string_scalar/*/&_cfi
        scalar -- f_in_string_scalar
          buf -- f_in_string_scalar_buf
          cfi -- f_in_string_scalar/*/&_cfi
      struct
        & -- f_shared_struct
        * -- f_shared_struct
        scalar -- f_shared_struct
      unknown
        scalar -- f_shared_native_scalar
      vector
        &
          buf
            targ
              native
                * -- f_in_vector_&_buf_targ_native_*
                scalar -- f_in_vector_scalar/*/&_buf_targ_native_scalar
              string
                scalar -- f_in_vector_scalar/*/&_buf_targ_string_scalar
          cdesc
            targ
              native
                scalar -- f_defaulttmp
        *
          buf
            targ
              native
                scalar -- f_in_vector_scalar/*/&_buf_targ_native_scalar
              string
                scalar -- f_in_vector_scalar/*/&_buf_targ_string_scalar
        scalar
          buf
            targ
              native
                scalar -- f_in_vector_scalar/*/&_buf_targ_native_scalar
              string
                scalar -- f_in_vector_scalar/*/&_buf_targ_string_scalar
      void
        * -- f_in_void_*
          cdesc -- f_in/out/inout_native_*_cdesc
        ** -- f_in/out/inout_void_**
          cfi -- f_in/out/inout_void_**
        scalar -- f_shared_native_scalar
    inout
      bool
        * -- f_inout_bool_*
      char
        * -- f_shared_native_scalar
          buf -- f_inout_char_*_buf
          cfi -- f_inout_char_*_cfi
      native
        & -- f_shared_native_scalar
          hidden -- f_out/inout_native_&_hidden
        * -- f_shared_native_scalar
          cdesc -- f_in/out/inout_native_*_cdesc
          cfi -- f_in/inout_native_*_cfi
          hidden -- f_out/inout_native_*_hidden
      shadow
        & -- f_in_shadow_*
        * -- f_in_shadow_*
      string
        & -- f_inout_string_*/&
          buf -- f_inout_string_*/&_buf
          cfi -- f_inout_string_*/&_cfi
        * -- f_inout_string_*/&
          buf -- f_inout_string_*/&_buf
          cfi -- f_inout_string_*/&_cfi
      struct
        & -- f_shared_struct
        * -- f_shared_struct
      vector
        &
          cdesc
            allocatable
              targ
                native
                  scalar -- f_inout_vector_&_cdesc_allocatable_targ_native_scalar
            targ
              native
                scalar -- f_inout_vector_&_cdesc_targ_native_scalar
        buf
          targ
            string
              scalar -- f_inout_vector_buf_targ_string_scalar
      void
        *
          cdesc -- f_in/out/inout_native_*_cdesc
        ** -- f_in/out/inout_void_**
    mixin
      arg
        capsule -- f_mixin_arg_capsule
      capsule
        dtor -- f_mixin_capsule_dtor
      char
        cdesc
          allocate -- f_mixin_char_cdesc_allocate
          pointer -- f_mixin_char_cdesc_pointer
      function -- f_mixin_function
        c-ptr -- f_mixin_function_c-ptr
        ptr -- f_mixin_function_ptr
        shadow
          capptr -- f_mixin_function_shadow_capptr
          capsule -- f_mixin_function_shadow_capsule
        string
          scalar
            cfi
              allocatable -- f_mixin_function_string_scalar_cfi_allocatable
      function-to-subroutine -- f_mixin_function-to-subroutine
      getter
        cdesc -- f_mixin_getter_cdesc
      helper
        array
          string
            allocatable -- f_mixin_helper_array_string_allocatable
        vector
          string
            allocatable -- f_mixin_helper_vector_string_allocatable
      in
        2d
          array
            buf -- f_mixin_in_2d_array_buf
        array
          buf -- f_mixin_in_array_buf
        character
          buf -- f_mixin_in_character_buf
        string
          array
            buf -- f_mixin_in_string_array_buf
      inout
        array
          cdesc -- f_mixin_inout_array_cdesc
        char
          array
            cdesc -- f_mixin_inout_char_array_cdesc
      local-logical-var -- f_mixin_local-logical-var
      native
        cdesc
          allocate -- f_mixin_native_cdesc_allocate
          pointer -- f_mixin_native_cdesc_pointer
          raw -- f_mixin_native_cdesc_raw
      out
        array
          buf -- f_mixin_out_array_buf
          cdesc
            allocatable -- f_mixin_out_array_cdesc_allocatable
        native
          cdesc
            allocate -- f_mixin_out_native_cdesc_allocate
            pointer -- f_mixin_out_native_cdesc_pointer
        string
          **
            cfi -- f_mixin_out_string_**_cfi
      pass
        capsule -- f_mixin_pass_capsule
        cdesc -- f_mixin_pass_cdesc
      shadow-arg -- f_mixin_shadow-arg
      str
        array -- f_mixin_str_array
      unknown -- f_mixin_unknown
      use
        capsule -- f_mixin_use_capsule
    out
      bool
        * -- f_out_bool_*
      char
        * -- f_shared_native_scalar
          buf -- f_out_char_*_buf
          cfi -- f_out_char_*_cfi
      native
        & -- f_shared_native_scalar
          hidden -- f_out/inout_native_&_hidden
        * -- f_out_native_*
          cdesc -- f_in/out/inout_native_*_cdesc
          cfi
            allocatable -- f_out_native_*_cfi_allocatable
          hidden -- f_out/inout_native_*_hidden
        *&
          cdesc -- f_out_native_*&_cdesc
            pointer -- f_out_native_*&_cdesc
        **
          cdesc
            allocatable -- f_out_native_**_cdesc_allocatable
            pointer -- f_out_native_**_cdesc_pointer
          cfi
            allocatable -- f_out_native_**_cfi_allocatable
            pointer -- f_out_native_**_cfi_pointer
          raw -- f_out_native_**_raw
        *** -- f_shared_native_scalar
      string
        & -- f_out_string_*/&
          buf -- f_out_string_*/&_buf
          cfi -- f_out_string_*/&_cfi
        * -- f_out_string_*/&
          buf -- f_out_string_*/&_buf
          cfi -- f_out_string_*/&_cfi
        **
          cdesc
            allocatable -- f_out_string_**_cdesc_allocatable
            copy -- f_out_string_**_cdesc_copy
          cfi
            allocatable -- f_out_string_**_cfi_allocatable
            copy -- f_out_string_**_cfi_copy
          copy -- f_out_string_**_copy
      struct
        & -- f_shared_struct
        * -- f_shared_struct
      vector
        &
          cdesc
            allocatable
              targ
                native
                  scalar -- f_out_vector_*/&_cdesc_allocatable_targ_native_scalar
                string
                  scalar -- f_out_vector_&_cdesc_allocatable_targ_string_scalar
            targ
              native
                scalar -- f_out_vector_*/&_cdesc_targ_native_scalar
              string
                scalar -- f_out_vector_&_cdesc_targ_string_scalar
        *
          cdesc
            allocatable
              targ
                native
                  scalar -- f_out_vector_*/&_cdesc_allocatable_targ_native_scalar
            targ
              native
                scalar -- f_out_vector_*/&_cdesc_targ_native_scalar
        buf
          targ
            string
              scalar -- f_out_vector_buf_targ_string_scalar
      void
        *
          cdesc -- f_in/out/inout_native_*_cdesc
        *& -- f_shared_native_scalar
        ** -- f_in/out/inout_void_**
    setter -- f_setter
      bool
        scalar -- f_setter_bool_scalar
      native
        * -- f_setter_native_scalar/*
        scalar -- f_setter_native_scalar/*
      string
        scalar
          buf -- f_setter_string_scalar_buf
      struct
        * -- f_setter_struct_*_pointer
          pointer -- f_setter_struct_*_pointer
        ** -- f_setter_struct_**
    shared
      function
        string
          *
            cfi
              pointer -- f_shared_function_string_*_cfi_pointer
          scalar -- f_shared_function_string_scalar
      native
        scalar -- f_shared_native_scalar
      struct -- f_shared_struct
    subroutine -- f_subroutine
    test -- f_test
c_ctor_shadow_scalar_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_call:
  - "{cxx_type} *{cxx_var} =\t new {cxx_type}({C_call_list});"
  - "{c_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});"
  - '{c_var}->idtor = {idtor};'
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: ctor
  name: c_ctor_shadow_scalar_capptr
  owner: caller
c_defaulttmp:
  intent: defaulttmp
  name: c_defaulttmp
  owner: library
c_dtor:
  c_call:
  - delete {CXX_this};
  - '{C_this}->addr = {nullptr};'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  impl_header:
  - <cstddef>
  intent: dtor
  lang_c:
    impl_header:
    - <stddef.h>
  lang_cxx:
    impl_header:
    - <cstddef>
  name: c_dtor
  owner: library
c_function:
  intent: function
  name: c_function
  owner: library
c_function_bool_scalar:
  intent: function
  name: c_function_bool_scalar
  owner: library
c_function_char_*:
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_char_*
  owner: library
c_function_char_*_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_char_*_arg
  owner: library
c_function_char_*_buf_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_char_*_buf_arg
  owner: library
c_function_char_*_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_char_*_buf_copy
  owner: library
c_function_char_scalar:
  c_arg_decl:
  - char *{c_var}
  c_call:
  - '*{c_var} = {function_name}({C_call_list});'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(OUT) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_CHAR
  intent: function
  name: c_function_char_scalar
  owner: library
c_function_native_&:
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_native_&
  owner: library
c_function_native_*:
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_native_*
  owner: library
c_function_native_**:
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_native_**
  owner: library
c_function_native_*_caller:
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_native_*_caller
  owner: library
c_function_native_*_scalar:
  i_module:
    iso_c_binding:
    - '{f_kind}'
  i_result_decl:
  - '{f_type} :: {i_var}'
  intent: function
  name: c_function_native_*_scalar
  owner: library
c_function_native_scalar:
  intent: function
  name: c_function_native_scalar
  owner: library
c_function_shadow_&_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_&_capptr
  owner: library
c_function_shadow_&_capptr_caller:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_&_capptr_caller
  owner: library
c_function_shadow_&_capptr_library:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_&_capptr_library
  owner: library
c_function_shadow_*_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_*_capptr
  owner: library
c_function_shadow_*_capptr_caller:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_*_capptr_caller
  owner: library
c_function_shadow_*_capptr_library:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_*_capptr_library
  owner: library
c_function_shadow_*_capsule:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: function
  name: c_function_shadow_*_capsule
  owner: library
c_function_shadow_*_this:
  c_call:
  - '{CXX_this_call}{function_name}{CXX_template}({C_call_list});'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  intent: function
  name: c_function_shadow_*_this
  owner: library
c_function_shadow_scalar_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: pointer
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_scalar_capptr
  owner: caller
c_function_shadow_scalar_capptr_targ_native_scalar:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: pointer
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: c_function_shadow_scalar_capptr_targ_native_scalar
  owner: caller
c_function_string_&:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_string_&
  owner: library
c_function_string_&_buf_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_string_&_buf_arg
  owner: library
c_function_string_&_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_string_&_buf_copy
  owner: library
c_function_string_&_copy:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_string_&_copy
  owner: library
c_function_string_*:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_string_*
  owner: library
c_function_string_*_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_string_*_buf_copy
  owner: library
c_function_string_*_caller:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_string_*_caller
  owner: library
c_function_string_*_copy:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_string_*_copy
  owner: library
c_function_string_*_library:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_string_*_library
  owner: library
c_function_string_scalar:
  comments:
  - Cannot return a char array by value.
  intent: function
  name: c_function_string_scalar
  notimplemented: true
  owner: library
c_function_string_scalar_buf_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_string_scalar_buf_arg
  owner: library
c_function_string_scalar_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: c_function_string_scalar_buf_copy
  owner: library
c_function_struct_*:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: c_function_struct_*
  owner: library
c_function_struct_scalar:
  c_arg_decl:
  - '{c_type} *{c_var}'
  c_call:
  - '*{c_var} = {C_call_function};'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  i_arg_decl:
  - '{f_type}, intent(OUT) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_kind}'
  intent: function
  name: c_function_struct_scalar
  owner: library
c_function_vector_scalar_malloc_targ_native_scalar:
  c_arg_decl:
  - size_t *{c_var_size}
  c_call:
  - '{cxx_var} = {C_call_function};'
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "{cxx_T} *{c_var} =\t static_cast<{cxx_T} *>\t(std::malloc({c_local_bytes}));"
  - "std::memcpy({c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t {cxx_var};"
  c_return_type: '{cxx_T} *'
  c_temps:
  - size
  comments:
  - Create empty local vector then copy result to
  - malloc allocated array.
  - Add an argument with the length of the array.
  cxx_local_var: result
  i_arg_decl:
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  i_result_decl:
  - 'type(C_PTR) :: {i_var}'
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: function
  name: c_function_vector_scalar_malloc_targ_native_scalar
  owner: library
c_function_vector_scalar_targ_native_scalar:
  comments:
  - Cannot return a std::vector<native> by value.
  intent: function
  name: c_function_vector_scalar_targ_native_scalar
  notimplemented: true
  owner: library
c_function_void_*:
  intent: function
  name: c_function_void_*
  owner: library
c_getter_native_*:
  c_call:
  - // skip call c_getter
  c_return:
  - return {CXX_this}->{field_name};
  intent: getter
  name: c_getter_native_*
  owner: library
c_getter_native_scalar:
  c_call:
  - // skip call c_getter
  c_return:
  - return {CXX_this}->{field_name};
  intent: getter
  name: c_getter_native_scalar
  owner: library
c_in_bool_scalar:
  intent: in
  name: c_in_bool_scalar
  owner: library
c_in_char_*:
  intent: in
  name: c_in_char_*
  owner: library
c_in_char_**:
  c_arg_decl:
  - char **{c_var}
  i_arg_decl:
  - 'type(C_PTR), intent(IN) :: {i_var}(*)'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: c_in_char_**
  owner: library
c_in_char_**_buf:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_array_alloc
  - char_array_free
  c_post_call:
  - '{c_helper_char_array_free}({cxx_var}, {c_var_size});'
  c_pre_call:
  - "char **{cxx_var} = {c_helper_char_array_alloc}({c_var},\t {c_var_size},\t {c_var_len});"
  c_temps:
  - size
  - len
  cxx_local_var: pointer
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: c_in_char_**_buf
  owner: library
c_in_char_*_buf:
  c_arg_call:
  - '{c_var_str}'
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_alloc
  - char_free
  c_post_call:
  - '{c_helper_char_free}({c_var_str});'
  c_pre_call:
  - "char * {c_var_str} = {c_helper_char_alloc}(\t{c_var},\t {c_var_len},\t {c_blanknull});"
  c_temps:
  - len
  - str
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: c_in_char_*_buf
  owner: library
c_in_char_scalar:
  c_arg_decl:
  - char {c_var}
  i_arg_decl:
  - 'character(kind=C_CHAR), value, intent(IN) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_CHAR
  intent: in
  name: c_in_char_scalar
  owner: library
c_in_native_&:
  intent: in
  name: c_in_native_&
  owner: library
c_in_native_*:
  intent: in
  name: c_in_native_*
  owner: library
c_in_native_**:
  c_arg_decl:
  - '{cxx_type} **{cxx_var}'
  i_arg_decl:
  - 'type(C_PTR), intent(IN), value :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: c_in_native_**
  owner: library
c_in_native_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: in
  lang_c:
    c_pre_call:
    - '{cxx_type} * {c_var} = {c_var_cdesc}->base_addr;'
  lang_cxx:
    c_pre_call:
    - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  name: c_in_native_*_cdesc
  owner: library
c_in_native_scalar:
  intent: in
  name: c_in_native_scalar
  owner: library
c_in_shadow_&:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: in
  name: c_in_shadow_&
  owner: library
c_in_shadow_*:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: in
  name: c_in_shadow_*
  owner: library
c_in_shadow_scalar:
  c_arg_decl:
  - '{c_type} {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}.addr{cast2};"
  cxx_local_var: pointer
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}), value :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: in
  name: c_in_shadow_scalar
  owner: library
c_in_string_&:
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  intent: in
  name: c_in_string_&
  owner: library
c_in_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_pre_call:
  - "{c_const}std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: c_in_string_&_buf
  owner: library
c_in_string_*:
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  intent: in
  name: c_in_string_*
  owner: library
c_in_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_pre_call:
  - "{c_const}std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: c_in_string_*_buf
  owner: library
c_in_string_scalar:
  c_arg_decl:
  - char *{c_var}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_CHAR
  intent: in
  name: c_in_string_scalar
  owner: library
c_in_string_scalar_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_call:
  - XXX{cxx_var}
  c_helper:
  - char_len_trim
  c_local:
  - trim
  c_pre_call:
  - int {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_len});
  - std::string {cxx_var}({c_var}, {c_local_trim});
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: c_in_string_scalar_buf
  owner: library
c_in_struct_&:
  intent: in
  name: c_in_struct_&
  owner: library
c_in_struct_*:
  intent: in
  name: c_in_struct_*
  owner: library
c_in_struct_scalar:
  intent: in
  name: c_in_struct_scalar
  owner: library
c_in_unknown_scalar:
  intent: in
  name: c_in_unknown_scalar
  owner: library
c_in_vector_&_buf_targ_native_*:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_len}
  - size_t {c_var_size}
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - for (size_t i=0; i < {c_var_size}; ++i) {{+
  - '{cxx_var}.push_back({c_var} + ({c_var_len}*i));'
  - -}}
  c_temps:
  - len
  - size
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_len}'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: c_in_vector_&_buf_targ_native_*
  owner: library
c_in_vector_&_buf_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: c_in_vector_&_buf_targ_native_scalar
  owner: library
c_in_vector_&_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: c_in_vector_&_buf_targ_string_scalar
  owner: library
c_in_vector_&_targ_native_*:
  comments:
  - Need to know the length of the vector from C
  intent: in
  name: c_in_vector_&_targ_native_*
  notimplemented: true
  owner: library
c_in_vector_&_targ_native_scalar:
  comments:
  - Need to know the length of the vector from C
  intent: in
  name: c_in_vector_&_targ_native_scalar
  notimplemented: true
  owner: library
c_in_vector_&_targ_string_scalar:
  comments:
  - Need to know the length of the vector from C
  intent: in
  name: c_in_vector_&_targ_string_scalar
  notimplemented: true
  owner: library
c_in_vector_*_buf_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: c_in_vector_*_buf_targ_native_scalar
  owner: library
c_in_vector_*_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: c_in_vector_*_buf_targ_string_scalar
  owner: library
c_in_vector_scalar_buf_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: c_in_vector_scalar_buf_targ_native_scalar
  owner: library
c_in_vector_scalar_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: c_in_vector_scalar_buf_targ_string_scalar
  owner: library
c_in_void_*:
  intent: in
  name: c_in_void_*
  owner: library
c_in_void_**:
  c_arg_decl:
  - void **{c_var}
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: c_in_void_**
  owner: library
c_in_void_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: in
  lang_c:
    c_pre_call:
    - '{cxx_type} * {c_var} = {c_var_cdesc}->base_addr;'
  lang_cxx:
    c_pre_call:
    - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  name: c_in_void_*_cdesc
  owner: library
c_in_void_scalar:
  intent: in
  name: c_in_void_scalar
  owner: library
c_inout_bool_*:
  intent: inout
  name: c_inout_bool_*
  owner: library
c_inout_char_*:
  intent: inout
  name: c_inout_char_*
  owner: library
c_inout_char_*_buf:
  c_arg_call:
  - '{c_var_str}'
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_alloc
  - char_copy
  - char_free
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {c_var_str},\t -1);"
  - '{c_helper_char_free}({c_var_str});'
  c_pre_call:
  - "char * {c_var_str} = {c_helper_char_alloc}(\t{c_var},\t {c_var_len},\t {c_blanknull});"
  c_temps:
  - len
  - str
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: inout
  name: c_inout_char_*_buf
  owner: library
c_inout_native_&:
  intent: inout
  name: c_inout_native_&
  owner: library
c_inout_native_&_hidden:
  c_arg_call:
  - '{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: inout
  name: c_inout_native_&_hidden
  owner: library
c_inout_native_*:
  intent: inout
  name: c_inout_native_*
  owner: library
c_inout_native_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: inout
  lang_c:
    c_pre_call:
    - '{cxx_type} * {c_var} = {c_var_cdesc}->base_addr;'
  lang_cxx:
    c_pre_call:
    - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  name: c_inout_native_*_cdesc
  owner: library
c_inout_native_*_hidden:
  c_arg_call:
  - '&{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: inout
  name: c_inout_native_*_hidden
  owner: library
c_inout_shadow_&:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: inout
  name: c_inout_shadow_&
  owner: library
c_inout_shadow_*:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: inout
  name: c_inout_shadow_*
  owner: library
c_inout_string_&:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  intent: inout
  lang_cxx:
    impl_header:
    - <cstring>
  name: c_inout_string_&
  owner: library
c_inout_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  - char_len_trim
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - "std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: inout
  name: c_inout_string_&_buf
  owner: library
c_inout_string_*:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  intent: inout
  lang_cxx:
    impl_header:
    - <cstring>
  name: c_inout_string_*
  owner: library
c_inout_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  - char_len_trim
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - "std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: inout
  name: c_inout_string_*_buf
  owner: library
c_inout_struct_&:
  intent: inout
  name: c_inout_struct_&
  owner: library
c_inout_struct_*:
  intent: inout
  name: c_inout_struct_*
  owner: library
c_inout_vector_&_buf_copy_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_post_call:
  - '*{c_var_size} = {cxx_var}->size()'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + *{c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: inout
  name: c_inout_vector_&_buf_copy_targ_native_scalar
  notimplemented: true
  owner: library
c_inout_vector_&_buf_malloc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "*{c_var} = static_cast<{cxx_T} *>\t(std::realloc(*{c_var},\t {c_local_bytes}));"
  - "std::memcpy(*{c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}(*{c_var}, *{c_var} + *{c_var_size});'
  c_temps:
  - size
  comments:
  - Create local vector from arguments then copy result to
  - malloc allocated array.
  cxx_local_var: scalar
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: inout
  name: c_inout_vector_&_buf_malloc_targ_native_scalar
  owner: library
c_inout_vector_&_targ_native_scalar:
  comments:
  - Need to know the length of the vector from C
  intent: inout
  name: c_inout_vector_&_targ_native_scalar
  notimplemented: true
  owner: library
c_inout_vector_*_buf_copy_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_post_call:
  - '*{c_var_size} = {cxx_var}->size()'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + *{c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: inout
  name: c_inout_vector_*_buf_copy_targ_native_scalar
  notimplemented: true
  owner: library
c_inout_vector_*_buf_malloc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "*{c_var} = static_cast<{cxx_T} *>\t(std::realloc(*{c_var},\t {c_local_bytes}));"
  - "std::memcpy(*{c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}(*{c_var}, *{c_var} + *{c_var_size});'
  c_temps:
  - size
  comments:
  - Create local vector from arguments then copy result to
  - malloc allocated array.
  cxx_local_var: scalar
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: inout
  name: c_inout_vector_*_buf_malloc_targ_native_scalar
  owner: library
c_inout_vector_scalar_buf_copy_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_post_call:
  - '*{c_var_size} = {cxx_var}->size()'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + *{c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: inout
  name: c_inout_vector_scalar_buf_copy_targ_native_scalar
  notimplemented: true
  owner: library
c_inout_vector_scalar_buf_malloc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "*{c_var} = static_cast<{cxx_T} *>\t(std::realloc(*{c_var},\t {c_local_bytes}));"
  - "std::memcpy(*{c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}(*{c_var}, *{c_var} + *{c_var_size});'
  c_temps:
  - size
  comments:
  - Create local vector from arguments then copy result to
  - malloc allocated array.
  cxx_local_var: scalar
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: inout
  name: c_inout_vector_scalar_buf_malloc_targ_native_scalar
  owner: library
c_inout_void_**:
  c_arg_decl:
  - void **{c_var}
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: inout
  name: c_inout_void_**
  owner: library
c_inout_void_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: inout
  lang_c:
    c_pre_call:
    - '{cxx_type} * {c_var} = {c_var_cdesc}->base_addr;'
  lang_cxx:
    c_pre_call:
    - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  name: c_inout_void_*_cdesc
  owner: library
c_mixin_arg_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_temps:
  - cfi
  iface_header:
  - ISO_Fortran_binding.h
  intent: mixin
  name: c_mixin_arg_cfi
  owner: library
c_mixin_arg_character_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_pre_call:
  - char *{cxx_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: mixin
  name: c_mixin_arg_character_cfi
  owner: library
c_mixin_arg_native_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: mixin
  name: c_mixin_arg_native_cfi
  owner: library
c_mixin_destructor_new-string:
  destructor:
  - "std::string *cxx_ptr = \treinterpret_cast<std::string *>(ptr);"
  - delete cxx_ptr;
  destructor_name: new_string
  intent: mixin
  name: c_mixin_destructor_new-string
  owner: library
c_mixin_destructor_new-vector:
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  intent: mixin
  name: c_mixin_destructor_new-vector
  owner: library
c_mixin_function_array_malloc:
  c_arg_decl:
  - size_t *{c_var_size}
  c_return_type: '{cxx_T} *'
  c_temps:
  - size
  comments:
  - Return pointer to array type.
  - Add an argument to return the length of the array
  i_arg_decl:
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  i_result_decl:
  - 'type(C_PTR) :: {i_var}'
  intent: mixin
  name: c_mixin_function_array_malloc
  owner: library
c_mixin_function_char_*_cdesc:
  c_helper:
  - type_defines
  c_post_call:
  - "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{cxx_var});"
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});'
  - '{c_var_cdesc}->size = 1;'
  - '{c_var_cdesc}->rank = 0;'
  comments:
  - Fill cdesc from char * in the C wrapper.
  intent: mixin
  name: c_mixin_function_char_*_cdesc
  owner: library
c_mixin_function_string_cdesc:
  c_helper:
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  comments:
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  intent: mixin
  name: c_mixin_function_string_cdesc
  owner: library
c_mixin_in_character_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: mixin
  name: c_mixin_in_character_buf
  owner: library
c_mixin_inout_array_cdesc:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_temps:
  - size
  - cdesc
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: mixin
  name: c_mixin_inout_array_cdesc
  owner: library
c_mixin_inout_vector_cdesc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - type_defines
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "std::vector<{cxx_T}> *{cxx_var} = \tnew std::vector<{cxx_T}>\t(\t{c_var}, {c_var}\
    \ + {c_var_size});"
  c_temps:
  - size
  - cdesc
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: mixin
  name: c_mixin_inout_vector_cdesc_targ_native_scalar
  owner: library
c_mixin_native_capsule_fill:
  c_post_call:
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  comments:
  - Assign to capsule in C wrapper.
  intent: mixin
  name: c_mixin_native_capsule_fill
  owner: library
c_mixin_native_cdesc_fill-cdesc:
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  comments:
  - Fill cdesc from native in the C wrapper.
  intent: mixin
  name: c_mixin_native_cdesc_fill-cdesc
  owner: library
c_mixin_native_cfi_allocatable:
  c_post_call:
  - if ({cxx_var} != {nullptr}) {{+
  - "{c_temp_lower_decl}{c_temp_extents_decl}int SH_ret = CFI_allocate({c_var_cfi},\
    \ \t{c_temp_lower_use}, \t{c_temp_extents_use}, \t0);"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}, \t{c_var_cfi}->elem_len);"
  - -}}
  - -}}
  c_temps:
  - extents
  - lower
  intent: mixin
  name: c_mixin_native_cfi_allocatable
  owner: library
c_mixin_native_cfi_pointer:
  c_local:
  - cptr
  - fptr
  - cdesc
  - err
  c_post_call:
  - '{{+'
  - CFI_CDESC_T({rank}) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<{c_type} *>({cxx_var});
  - "{c_temp_extents_decl}{c_temp_lower_decl}int {c_local_err} = CFI_establish({c_local_cdesc},\t\
    \ {c_local_cptr},\t CFI_attribute_pointer,\t {cfi_type},\t 0,\t {rank},\t {c_temp_extents_use});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {c_temp_lower_use});"
  - -}}
  - -}}
  c_temps:
  - extents
  - lower
  intent: mixin
  name: c_mixin_native_cfi_pointer
  owner: library
c_mixin_noargs:
  intent: mixin
  name: c_mixin_noargs
  owner: library
c_mixin_out_array_buf_malloc:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_temps:
  - size
  comments:
  - Pass raw pointer and size by reference to C.
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  intent: mixin
  name: c_mixin_out_array_buf_malloc
  owner: library
c_mixin_out_native_**:
  c_arg_call:
  - '&{cxx_var}'
  c_pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
  intent: mixin
  name: c_mixin_out_native_**
  owner: library
c_mixin_out_vector_cdesc_targ_native_scalar:
  c_helper:
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  intent: mixin
  name: c_mixin_out_vector_cdesc_targ_native_scalar
  owner: library
c_mixin_shadow:
  c_arg_decl:
  - '{c_type} * {c_var}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: mixin
  name: c_mixin_shadow
  owner: library
c_mixin_unknown:
  c_arg_decl:
  - ===>{c_var}<===
  comments:
  - Default returned by lookup_fc_stmts when group is not found.
  intent: mixin
  name: c_mixin_unknown
  owner: library
c_mixin_vector_cdesc_fill-cdesc:
  c_helper:
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  intent: mixin
  name: c_mixin_vector_cdesc_fill-cdesc
  owner: library
c_out_bool_*:
  intent: out
  name: c_out_bool_*
  owner: library
c_out_char_*:
  intent: out
  name: c_out_char_*
  owner: library
c_out_char_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_blank_fill
  c_post_call:
  - '{c_helper_char_blank_fill}({c_var}, {c_var_len});'
  c_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: out
  name: c_out_char_*_buf
  owner: library
c_out_native_&:
  intent: out
  name: c_out_native_&
  owner: library
c_out_native_&*:
  intent: out
  name: c_out_native_&*
  owner: library
c_out_native_&_hidden:
  c_arg_call:
  - '{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: out
  name: c_out_native_&_hidden
  owner: library
c_out_native_*:
  intent: out
  name: c_out_native_*
  owner: library
c_out_native_*&:
  intent: out
  name: c_out_native_*&
  owner: library
c_out_native_**:
  intent: out
  name: c_out_native_**
  owner: library
c_out_native_***:
  intent: out
  name: c_out_native_***
  owner: library
c_out_native_**_raw:
  intent: out
  name: c_out_native_**_raw
  owner: library
c_out_native_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  lang_c:
    c_pre_call:
    - '{cxx_type} * {c_var} = {c_var_cdesc}->base_addr;'
  lang_cxx:
    c_pre_call:
    - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  name: c_out_native_*_cdesc
  owner: library
c_out_native_*_hidden:
  c_arg_call:
  - '&{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: out
  name: c_out_native_*_hidden
  owner: library
c_out_string_&:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var};'
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  intent: out
  lang_cxx:
    impl_header:
    - <cstring>
  name: c_out_string_&
  owner: library
c_out_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - std::string {cxx_var};
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: out
  name: c_out_string_&_buf
  owner: library
c_out_string_*:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var};'
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  intent: out
  lang_cxx:
    impl_header:
    - <cstring>
  name: c_out_string_*
  owner: library
c_out_string_**:
  intent: out
  name: c_out_string_**
  notimplemented: true
  owner: library
c_out_string_**_cdesc_copy:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_string_out
  c_post_call:
  - "{c_helper_array_string_out}(\t{c_var_cdesc},\t {cxx_var}, {c_array_size2});"
  c_pre_call:
  - std::string *{cxx_var};
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: c_out_string_**_cdesc_copy
  owner: library
c_out_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - std::string {cxx_var};
  c_temps:
  - len
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: out
  name: c_out_string_*_buf
  owner: library
c_out_struct_&:
  intent: out
  name: c_out_struct_&
  owner: library
c_out_struct_*:
  intent: out
  name: c_out_struct_*
  owner: library
c_out_vector_&_buf_copy_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_local:
  - size
  c_post_call:
  - "size_t {c_local_size} =\t *{c_var_size} < {cxx_var}.size() ?\t *{c_var_size}\
    \ :\t {cxx_var}.size();"
  - "std::memcpy({c_var},\t {cxx_var}.data(),\t {c_local_size}*sizeof({cxx_var}[0]));"
  - '*{c_var_size} = {c_local_size};'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  impl_header:
  - <cstring>
  intent: out
  name: c_out_vector_&_buf_copy_targ_native_scalar
  owner: library
c_out_vector_&_buf_copy_targ_string_scalar:
  intent: out
  name: c_out_vector_&_buf_copy_targ_string_scalar
  notimplemented: true
  owner: library
c_out_vector_&_buf_malloc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "*{c_var} = static_cast<{cxx_T} *>\t(std::malloc({c_local_bytes}));"
  - "std::memcpy(*{c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  comments:
  - Create empty local vector then copy result to
  - malloc allocated array.
  cxx_local_var: scalar
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: out
  name: c_out_vector_&_buf_malloc_targ_native_scalar
  owner: library
c_out_vector_&_cdesc_allocatable_targ_string_scalar:
  c_arg_call:
  - '*{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - vector_string_allocatable
  - vector_string_out_len
  c_post_call:
  - if ({c_char_len} > 0) {{+
  - '{c_var_cdesc}->elem_len = {c_char_len};'
  - -}} else {{+
  - '{c_var_cdesc}->elem_len = {c_helper_vector_string_out_len}(*{cxx_var});'
  - -}}
  - '{c_var_cdesc}->size      = {cxx_var}->size();'
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - std::vector<std::string> *{cxx_var} = new std::vector<std::string>;
  c_temps:
  - cdesc
  - capsule
  comments:
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Allocate Fortran array from cdesc.
  - Allocate a vector<string> variable.
  - Copy into Fortran allocated memory.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  cxx_local_var: pointer
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: out
  name: c_out_vector_&_cdesc_allocatable_targ_string_scalar
  owner: library
c_out_vector_&_cdesc_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: c_out_vector_&_cdesc_targ_native_scalar
  owner: library
c_out_vector_&_cdesc_targ_string_scalar:
  c_arg_call:
  - '{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - vector_string_out
  c_post_call:
  - "{c_helper_vector_string_out}(\t{c_var_cdesc},\t {cxx_var});"
  c_pre_call:
  - '{c_const}std::vector<std::string> {cxx_var};'
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: c_out_vector_&_cdesc_targ_string_scalar
  owner: library
c_out_vector_&_targ_native_scalar:
  comments:
  - Need to know the length of the vector from C
  intent: out
  name: c_out_vector_&_targ_native_scalar
  notimplemented: true
  owner: library
c_out_vector_&_targ_string_scalar:
  comments:
  - Need to know the length of the vector from C
  intent: out
  name: c_out_vector_&_targ_string_scalar
  notimplemented: true
  owner: library
c_out_vector_*_buf_copy_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_local:
  - size
  c_post_call:
  - "size_t {c_local_size} =\t *{c_var_size} < {cxx_var}.size() ?\t *{c_var_size}\
    \ :\t {cxx_var}.size();"
  - "std::memcpy({c_var},\t {cxx_var}.data(),\t {c_local_size}*sizeof({cxx_var}[0]));"
  - '*{c_var_size} = {c_local_size};'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  impl_header:
  - <cstring>
  intent: out
  name: c_out_vector_*_buf_copy_targ_native_scalar
  owner: library
c_out_vector_*_buf_copy_targ_string_scalar:
  intent: out
  name: c_out_vector_*_buf_copy_targ_string_scalar
  notimplemented: true
  owner: library
c_out_vector_*_buf_malloc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "*{c_var} = static_cast<{cxx_T} *>\t(std::malloc({c_local_bytes}));"
  - "std::memcpy(*{c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  comments:
  - Create empty local vector then copy result to
  - malloc allocated array.
  cxx_local_var: scalar
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: out
  name: c_out_vector_*_buf_malloc_targ_native_scalar
  owner: library
c_out_vector_*_cdesc_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: c_out_vector_*_cdesc_targ_native_scalar
  owner: library
c_out_vector_scalar_buf_copy_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_local:
  - size
  c_post_call:
  - "size_t {c_local_size} =\t *{c_var_size} < {cxx_var}.size() ?\t *{c_var_size}\
    \ :\t {cxx_var}.size();"
  - "std::memcpy({c_var},\t {cxx_var}.data(),\t {c_local_size}*sizeof({cxx_var}[0]));"
  - '*{c_var_size} = {c_local_size};'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  cxx_local_var: scalar
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  impl_header:
  - <cstring>
  intent: out
  name: c_out_vector_scalar_buf_copy_targ_native_scalar
  owner: library
c_out_vector_scalar_buf_copy_targ_string_scalar:
  intent: out
  name: c_out_vector_scalar_buf_copy_targ_string_scalar
  notimplemented: true
  owner: library
c_out_vector_scalar_buf_malloc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} **{c_var}'
  - size_t *{c_var_size}
  c_local:
  - bytes
  c_post_call:
  - "size_t {c_local_bytes} =\t {cxx_var}.size()*sizeof({cxx_var}[0]);"
  - "*{c_var} = static_cast<{cxx_T} *>\t(std::malloc({c_local_bytes}));"
  - "std::memcpy(*{c_var},\t {cxx_var}.data(),\t {c_local_bytes});"
  - '*{c_var_size} = {cxx_var}.size();'
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  comments:
  - Create empty local vector then copy result to
  - malloc allocated array.
  cxx_local_var: scalar
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - C_PTR
    - C_SIZE_T
  impl_header:
  - <cstdlib>
  - <cstring>
  intent: out
  name: c_out_vector_scalar_buf_malloc_targ_native_scalar
  owner: library
c_out_void_*&:
  intent: out
  name: c_out_void_*&
  owner: library
c_out_void_**:
  c_arg_decl:
  - void **{c_var}
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: out
  name: c_out_void_**
  owner: library
c_out_void_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  lang_c:
    c_pre_call:
    - '{cxx_type} * {c_var} = {c_var_cdesc}->base_addr;'
  lang_cxx:
    c_pre_call:
    - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  name: c_out_void_*_cdesc
  owner: library
c_setter:
  c_call:
  - // skip call c_setter
  intent: setter
  name: c_setter
  owner: library
c_setter_native_*:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  intent: setter
  name: c_setter_native_*
  owner: library
c_setter_native_scalar:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  intent: setter
  name: c_setter_native_scalar
  owner: library
c_setter_string_scalar_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_post_call:
  - "{CXX_this}->{field_name} = std::string({c_var},\t {c_var_len});"
  c_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: setter
  name: c_setter_string_scalar_buf
  owner: library
c_shared_vector_argument:
  comments:
  - Need to know the length of the vector from C
  intent: shared
  name: c_shared_vector_argument
  notimplemented: true
  owner: library
c_subroutine:
  intent: subroutine
  name: c_subroutine
  owner: library
c_test:
  intent: test
  lang_c:
    field2:
    - this is a test
    - more test
  name: c_test
  owner: library
f_XXXin_string_scalar:
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  intent: XXXin
  name: f_XXXin_string_scalar
  owner: library
f_ctor_shadow_scalar_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_call:
  - "{cxx_type} *{cxx_var} =\t new {cxx_type}({C_call_list});"
  - "{c_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});"
  - '{c_var}->idtor = {idtor};'
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: ctor
  name: f_ctor_shadow_scalar_capptr
  owner: caller
f_defaulttmp:
  intent: defaulttmp
  name: f_defaulttmp
  owner: library
f_dtor:
  c_call:
  - delete {CXX_this};
  - '{C_this}->addr = {nullptr};'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  f_call:
  - call {F_C_call}({F_arg_c_call})
  impl_header:
  - <cstddef>
  intent: dtor
  name: f_dtor
  owner: library
f_function_bool_scalar:
  f_need_wrapper: true
  intent: function
  name: f_function_bool_scalar
  owner: library
f_function_char_*:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_char_*
  owner: library
f_function_char_*_allocatable:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_char_*_allocatable
  owner: library
f_function_char_*_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_result: subroutine
  f_temps:
  - len
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_char_*_arg
  owner: library
f_function_char_*_buf_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_result: subroutine
  f_temps:
  - len
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_char_*_buf_arg
  owner: library
f_function_char_*_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_char_*_buf_copy
  owner: library
f_function_char_*_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - copy_string
  - type_defines
  c_post_call:
  - "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{cxx_var});"
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});'
  - '{c_var_cdesc}->size = 1;'
  - '{c_var_cdesc}->rank = 0;'
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Fill cdesc from char * in the C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - copy_string
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_char_*_cdesc_allocatable
  owner: library
f_function_char_*_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - type_defines
  c_post_call:
  - "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{cxx_var});"
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});'
  - '{c_var_cdesc}->size = 1;'
  - '{c_var_cdesc}->rank = 0;'
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from char * in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_char_*_cdesc_pointer
  owner: library
f_function_char_*_cfi_allocatable:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - if ({cxx_var} != {nullptr}) {{+
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \tstrlen({cxx_var}));"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}, \t{c_var_cfi}->elem_len);"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_char_*_cfi_allocatable
  owner: library
f_function_char_*_cfi_arg:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  f_result: subroutine
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    f_var: '{F_string_result_as_arg}'
    i_var: '{F_string_result_as_arg}'
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_char_*_cfi_arg
  owner: library
f_function_char_*_cfi_copy:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var},\t -1);"
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_char_*_cfi_copy
  owner: library
f_function_char_*_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = {cxx_nonconst_ptr};
  - size_t {c_local_len} = {stdlib}strlen({cxx_var});
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_char_*_cfi_pointer
  owner: library
f_function_char_*_copy:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_char_*_copy
  owner: library
f_function_char_*_pointer:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_char_*_pointer
  owner: library
f_function_char_*_raw:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_char_*_raw
  owner: library
f_function_char_scalar:
  c_arg_decl:
  - char *{c_var}
  c_call:
  - '*{c_var} = {function_name}({C_call_list});'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(OUT) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_CHAR
  intent: function
  name: f_function_char_scalar
  owner: library
f_function_char_scalar_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - copy_string
  - type_defines
  c_post_call:
  - "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{cxx_var});"
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});'
  - '{c_var_cdesc}->size = 1;'
  - '{c_var_cdesc}->rank = 0;'
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Fill cdesc from char * in the C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - copy_string
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_char_scalar_cdesc_allocatable
  owner: library
f_function_char_scalar_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - type_defines
  c_post_call:
  - "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{cxx_var});"
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});'
  - '{c_var_cdesc}->size = 1;'
  - '{c_var_cdesc}->rank = 0;'
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from char * in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_char_scalar_cdesc_pointer
  owner: library
f_function_char_scalar_cfi_allocatable:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - if ({cxx_var} != {nullptr}) {{+
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \tstrlen({cxx_var}));"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}, \t{c_var_cfi}->elem_len);"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_char_scalar_cfi_allocatable
  owner: library
f_function_char_scalar_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = {cxx_nonconst_ptr};
  - size_t {c_local_len} = {stdlib}strlen({cxx_var});
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_char_scalar_cfi_pointer
  owner: library
f_function_native_&:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_declare:
  - 'type(C_PTR) :: {f_local_ptr}'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_local_ptr}, {F_result})
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_native_&
  owner: library
f_function_native_&_pointer:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_declare:
  - 'type(C_PTR) :: {f_local_ptr}'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_local_ptr}, {F_result})
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_native_&_pointer
  owner: library
f_function_native_**:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_native_**
  owner: library
f_function_native_*_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Allocate Fortran native array, then fill from cdesc
  - using helper copy_array.
  - Pass local capsule as argument to C wrapper.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - '{f_type}, allocatable, target :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - copy_array
  - array_context
  - capsule_dtor
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_need_wrapper: true
  f_post_call:
  - allocate({f_var}{f_array_allocate})
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},\t\
    \ kind=C_SIZE_T))"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_native_*_cdesc_allocatable
  owner: library
f_function_native_*_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Set Fortran pointer to native array.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_native_*_cdesc_pointer
  owner: library
f_function_native_*_cdesc_pointer_caller:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Add a capsule argument to the Fortran wrapper.
  - Pass the capsule as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Assign to capsule in C wrapper.
  - Set Fortran pointer to native array.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}%mem'
  f_arg_decl:
  - 'type({F_capsule_type}), intent(OUT) :: {f_var_capsule}'
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_arg_name:
  - '{f_var_capsule}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - array_context
  - capsule_helper
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  f_temps:
  - cdesc
  - capsule
  fmtdict:
    f_var_capsule: Crv
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_native_*_cdesc_pointer_caller
  owner: library
f_function_native_*_cfi_allocatable:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - if ({cxx_var} != {nullptr}) {{+
  - "{c_temp_lower_decl}{c_temp_extents_decl}int SH_ret = CFI_allocate({c_var_cfi},\
    \ \t{c_temp_lower_use}, \t{c_temp_extents_use}, \t0);"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}, \t{c_var_cfi}->elem_len);"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  - extents
  - lower
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - '{f_type}, allocatable :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  i_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_native_*_cfi_allocatable
  owner: library
f_function_native_*_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - err
  c_post_call:
  - '{{+'
  - CFI_CDESC_T({rank}) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<{c_type} *>({cxx_var});
  - "{c_temp_extents_decl}{c_temp_lower_decl}int {c_local_err} = CFI_establish({c_local_cdesc},\t\
    \ {c_local_cptr},\t CFI_attribute_pointer,\t {cfi_type},\t 0,\t {rank},\t {c_temp_extents_use});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {c_temp_lower_use});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  - extents
  - lower
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_pre_call:
  - nullify({f_var})
  i_arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_native_*_cfi_pointer
  owner: library
f_function_native_*_pointer:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_declare:
  - 'type(C_PTR) :: {f_local_ptr}'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_local_ptr}, {F_result})
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_native_*_pointer
  owner: library
f_function_native_*_pointer_caller:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_declare:
  - 'type(C_PTR) :: {f_local_ptr}'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_local_ptr}, {F_result})
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_native_*_pointer_caller
  owner: library
f_function_native_*_raw:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_native_*_raw
  owner: library
f_function_native_*_scalar:
  c_need_wrapper: true
  c_return:
  - return *{cxx_var};
  c_return_type: '{c_type}'
  comments:
  - Return a scalar to avoid doing the deref in Fortran.
  intent: function
  name: f_function_native_*_scalar
  owner: library
f_function_native_scalar:
  intent: function
  name: f_function_native_scalar
  owner: library
f_function_shadow_&_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_&_capptr
  owner: library
f_function_shadow_&_capptr_caller:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_&_capptr_caller
  owner: library
f_function_shadow_&_capptr_library:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_&_capptr_library
  owner: library
f_function_shadow_*_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_*_capptr
  owner: library
f_function_shadow_*_capptr_caller:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_*_capptr_caller
  owner: library
f_function_shadow_*_capptr_library:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_*_capptr_library
  owner: library
f_function_shadow_*_capsule:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  cxx_local_var: result
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: function
  name: f_function_shadow_*_capsule
  owner: library
f_function_shadow_*_this:
  c_call:
  - '{CXX_this_call}{function_name}{CXX_template}({C_call_list});'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_result: subroutine
  intent: function
  name: f_function_shadow_*_this
  owner: library
f_function_shadow_scalar_capptr:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_scalar_capptr
  owner: caller
f_function_shadow_scalar_capptr_caller:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_scalar_capptr_caller
  owner: caller
f_function_shadow_scalar_capptr_library:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_scalar_capptr_library
  owner: caller
f_function_shadow_scalar_capptr_targ_native_scalar:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_post_call:
  - '{c_var}->addr = {cxx_nonconst_ptr};'
  - '{c_var}->idtor = {idtor};'
  c_pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  c_return:
  - return {c_var};
  c_return_type: '{c_type} *'
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
    '{f_type_module}':
    - '{f_capsule_data_type}'
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: function
  name: f_function_shadow_scalar_capptr_targ_native_scalar
  owner: caller
f_function_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_&_buf
  owner: library
f_function_string_&_buf_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_result: subroutine
  f_temps:
  - len
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_&_buf_arg
  owner: library
f_function_string_&_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_&_buf_copy
  owner: library
f_function_string_&_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign to capsule in C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - copy_string
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_&_cdesc_allocatable
  owner: library
f_function_string_&_cdesc_allocatable_caller:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign to capsule in C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - copy_string
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_&_cdesc_allocatable_caller
  owner: library
f_function_string_&_cdesc_allocatable_library:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign to capsule in C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - copy_string
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_&_cdesc_allocatable_library
  owner: library
f_function_string_&_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_string_&_cdesc_pointer
  owner: library
f_function_string_&_cdesc_pointer_caller:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_string_&_cdesc_pointer_caller
  owner: library
f_function_string_&_cdesc_pointer_library:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_string_&_cdesc_pointer_library
  owner: library
f_function_string_&_cfi_allocatable:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_&_cfi_allocatable
  owner: library
f_function_string_&_cfi_allocatable_caller:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_&_cfi_allocatable_caller
  owner: library
f_function_string_&_cfi_allocatable_library:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_&_cfi_allocatable_library
  owner: library
f_function_string_&_cfi_arg:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  f_result: subroutine
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    f_var: '{F_string_result_as_arg}'
    i_var: '{F_string_result_as_arg}'
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_&_cfi_arg
  owner: library
f_function_string_&_cfi_copy:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_&_cfi_copy
  owner: library
f_function_string_&_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_&_cfi_pointer
  owner: library
f_function_string_&_cfi_pointer_caller:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_&_cfi_pointer_caller
  owner: library
f_function_string_&_cfi_pointer_library:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_&_cfi_pointer_library
  owner: library
f_function_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_*_buf
  owner: library
f_function_string_*_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_*_buf_copy
  owner: library
f_function_string_*_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign to capsule in C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - copy_string
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_*_cdesc_allocatable
  owner: library
f_function_string_*_cdesc_allocatable_caller:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign to capsule in C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - copy_string
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_*_cdesc_allocatable_caller
  owner: library
f_function_string_*_cdesc_allocatable_library:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign to capsule in C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - copy_string
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_*_cdesc_allocatable_library
  owner: library
f_function_string_*_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_string_*_cdesc_pointer
  owner: library
f_function_string_*_cdesc_pointer_caller:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_string_*_cdesc_pointer_caller
  owner: library
f_function_string_*_cdesc_pointer_library:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - string_to_cdesc
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_string_*_cdesc_pointer_library
  owner: library
f_function_string_*_cfi_allocatable:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_*_cfi_allocatable
  owner: library
f_function_string_*_cfi_allocatable_caller:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_*_cfi_allocatable_caller
  owner: library
f_function_string_*_cfi_allocatable_library:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_*_cfi_allocatable_library
  owner: library
f_function_string_*_cfi_copy:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_*_cfi_copy
  owner: library
f_function_string_*_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_*_cfi_pointer
  owner: library
f_function_string_*_cfi_pointer_caller:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_*_cfi_pointer_caller
  owner: library
f_function_string_*_cfi_pointer_library:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_*_cfi_pointer_library
  owner: library
f_function_string_scalar_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_scalar_buf
  owner: library
f_function_string_scalar_buf_arg:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_result: subroutine
  f_temps:
  - len
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    c_var_len: n{F_string_result_as_arg}
    f_var: '{F_string_result_as_arg}'
    f_var_len: n{F_string_result_as_arg}
    i_var: '{F_string_result_as_arg}'
    i_var_len: n{F_string_result_as_arg}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_scalar_buf_arg
  owner: library
f_function_string_scalar_buf_copy:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - len
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: function
  name: f_function_string_scalar_buf_copy
  owner: library
f_function_string_scalar_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - std::string * {cxx_var} = new std::string;
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Pass local capsule as argument to C wrapper.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  cxx_local_var: pointer
  destructor:
  - "std::string *cxx_ptr = \treinterpret_cast<std::string *>(ptr);"
  - delete cxx_ptr;
  destructor_name: new_string
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - copy_string
  - array_context
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_scalar_cdesc_allocatable
  owner: library
f_function_string_scalar_cdesc_allocatable_caller:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - std::string * {cxx_var} = new std::string;
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Pass local capsule as argument to C wrapper.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  cxx_local_var: pointer
  destructor:
  - "std::string *cxx_ptr = \treinterpret_cast<std::string *>(ptr);"
  - delete cxx_ptr;
  destructor_name: new_string
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - copy_string
  - array_context
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_scalar_cdesc_allocatable_caller
  owner: library
f_function_string_scalar_cdesc_allocatable_library:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - string_to_cdesc
  - copy_string
  c_post_call:
  - "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - std::string * {cxx_var} = new std::string;
  c_return_type: void
  c_temps:
  - cdesc
  - capsule
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from std::string using helper string_to_cdesc
  - in the C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  - Pass local capsule as argument to C wrapper.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  cxx_local_var: pointer
  destructor:
  - "std::string *cxx_ptr = \treinterpret_cast<std::string *>(ptr);"
  - delete cxx_ptr;
  destructor_name: new_string
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - copy_string
  - array_context
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: function
  name: f_function_string_scalar_cdesc_allocatable_library
  owner: library
f_function_string_scalar_cfi_allocatable:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}.length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}.data(), \t{c_var_cfi}->elem_len);"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_scalar_cfi_allocatable
  owner: library
f_function_string_scalar_cfi_allocatable_caller:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_scalar_cfi_allocatable_caller
  owner: library
f_function_string_scalar_cfi_allocatable_library:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *)\
    \ 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}{cxx_member}data(), \t{cxx_var}{cxx_member}length());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  intent: function
  name: f_function_string_scalar_cfi_allocatable_library
  owner: library
f_function_string_scalar_cfi_arg:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=*), intent(OUT) :: {f_var}'
  f_arg_name:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  f_result: subroutine
  fmtdict:
    c_var: '{F_string_result_as_arg}'
    f_var: '{F_string_result_as_arg}'
    i_var: '{F_string_result_as_arg}'
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_scalar_cfi_arg
  owner: library
f_function_string_scalar_cfi_copy:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_scalar_cfi_copy
  owner: library
f_function_string_scalar_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_scalar_cfi_pointer
  owner: library
f_function_string_scalar_cfi_pointer_caller:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_scalar_cfi_pointer_caller
  owner: library
f_function_string_scalar_cfi_pointer_library:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: function
  name: f_function_string_scalar_cfi_pointer_library
  owner: library
f_function_struct_*_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Set Fortran pointer to native array.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_struct_*_cdesc_pointer
  owner: library
f_function_struct_*_pointer:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_declare:
  - 'type(C_PTR) :: {f_local_ptr}'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_local_ptr}, {F_result})
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: function
  name: f_function_struct_*_pointer
  owner: library
f_function_struct_scalar:
  c_arg_decl:
  - '{c_type} *{c_var}'
  c_call:
  - '*{c_var} = {C_call_function};'
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  i_arg_decl:
  - '{f_type}, intent(OUT) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_kind}'
  intent: function
  name: f_function_struct_scalar
  owner: library
f_function_vector_scalar_cdesc:
  c_helper:
  - copy_array
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_post_call:
  - "call {f_helper_copy_array}(\t{temp0},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  intent: function
  name: f_function_vector_scalar_cdesc
  owner: library
f_function_vector_scalar_cdesc_allocatable_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, allocatable, target :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_need_wrapper: true
  f_post_call:
  - allocate({f_var}({f_var_cdesc}%size))
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: function
  name: f_function_vector_scalar_cdesc_allocatable_targ_native_scalar
  owner: library
f_function_void_*:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  intent: function
  name: f_function_void_*
  owner: library
f_getter_bool_scalar:
  c_call:
  - // skip call c_getter
  c_return:
  - return {CXX_this}->{field_name};
  intent: getter
  name: f_getter_bool_scalar
  owner: library
f_getter_native_*_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_call:
  - '{c_var_cdesc}->base_addr = {CXX_this}->{field_name};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_helper:
  - array_context
  - type_defines
  - array_context
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Set Fortran pointer to native array.
  - Save pointer struct members in a cdesc
  - along with shape information.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: getter
  name: f_getter_native_*_cdesc_pointer
  owner: library
f_getter_native_*_pointer:
  c_call:
  - // skip call c_getter
  c_return:
  - return {CXX_this}->{field_name};
  intent: getter
  name: f_getter_native_*_pointer
  owner: library
f_getter_native_scalar:
  c_call:
  - // skip call c_getter
  c_return:
  - return {CXX_this}->{field_name};
  intent: getter
  name: f_getter_native_scalar
  owner: library
f_getter_string_scalar_cdesc_allocatable:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_call:
  - "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{CXX_this}->{field_name}.data());"
  - '{c_var_cdesc}->type = 0; // SH_CHAR;'
  - '{c_var_cdesc}->elem_len = {CXX_this}->{field_name}.size();'
  - '{c_var_cdesc}->rank = 0;'
  c_helper:
  - array_context
  - copy_string
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - copy_string
  f_need_wrapper: true
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: getter
  name: f_getter_string_scalar_cdesc_allocatable
  owner: library
f_getter_struct_**_cdesc_raw:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_call:
  - '{c_var_cdesc}->base_addr = {CXX_this}->{field_name};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_helper:
  - array_context
  - type_defines
  - array_context
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Set Fortran pointer to pointers to arrays.
  - '''double **'' function returns ''type(C_PTR), pointer :: array(:)'''
  - Save pointer struct members in a cdesc
  - along with shape information.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - 'type(C_PTR), pointer :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: getter
  name: f_getter_struct_**_cdesc_raw
  owner: library
f_getter_struct_*_cdesc_pointer:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_call:
  - '{c_var_cdesc}->base_addr = {CXX_this}->{field_name};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_helper:
  - array_context
  - type_defines
  - array_context
  c_return_type: void
  c_temps:
  - cdesc
  comments:
  - Call the C wrapper as a subroutine.
  - Pass cdesc as argument to C wrapper.
  - Set Fortran pointer to native array.
  - Save pointer struct members in a cdesc
  - along with shape information.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: getter
  name: f_getter_struct_*_cdesc_pointer
  owner: library
f_getter_struct_*_fapi_pointer:
  f_arg_decl:
  - '{f_type}, pointer :: {F_result}'
  f_call:
  - call c_f_pointer({CXX_this}%{field_name}, {F_result})
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  intent: getter
  name: f_getter_struct_*_fapi_pointer
  owner: library
f_in_bool_scalar:
  f_arg_call:
  - '{f_var_cxx}'
  f_declare:
  - 'logical(C_BOOL) :: {f_var_cxx}'
  f_pre_call:
  - '{f_var_cxx} = {f_var}  ! coerce to C_BOOL'
  f_temps:
  - cxx
  intent: in
  name: f_in_bool_scalar
  owner: library
f_in_char_*:
  intent: in
  name: f_in_char_*
  owner: library
f_in_char_**:
  c_arg_decl:
  - char **{c_var}
  i_arg_decl:
  - 'type(C_PTR), intent(IN) :: {i_var}(*)'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: f_in_char_**
  owner: library
f_in_char_**_buf:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_array_alloc
  - char_array_free
  c_post_call:
  - '{c_helper_char_array_free}({cxx_var}, {c_var_size});'
  c_pre_call:
  - "char **{cxx_var} = {c_helper_char_array_alloc}({c_var},\t {c_var_size},\t {c_var_len});"
  c_temps:
  - size
  - len
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: f_in_char_**_buf
  owner: library
f_in_char_**_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_array_alloc
  - char_array_free
  c_post_call:
  - '{c_helper_char_array_free}({cxx_var}, {c_var_size});'
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - size_t {c_var_len} = {c_var_cfi}->elem_len;
  - size_t {c_var_size} = {c_var_cfi}->dim[0].extent;
  - "char **{cxx_var} = {c_helper_char_array_alloc}({c_var},\t {c_var_size},\t {c_var_len});"
  c_temps:
  - cfi
  - len
  - size
  cxx_local_var: pointer
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {f_var}(:)'
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}(:)'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: in
  name: f_in_char_**_cfi
  owner: library
f_in_char_*_buf:
  c_arg_call:
  - '{c_var_str}'
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_alloc
  - char_free
  c_post_call:
  - '{c_helper_char_free}({c_var_str});'
  c_pre_call:
  - "char * {c_var_str} = {c_helper_char_alloc}(\t{c_var},\t {c_var_len},\t {c_blanknull});"
  c_temps:
  - len
  - str
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: f_in_char_*_buf
  owner: library
f_in_char_*_capi:
  intent: in
  name: f_in_char_*_capi
  owner: library
f_in_char_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_alloc
  - char_free
  c_post_call:
  - '{c_helper_char_free}({cxx_var});'
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - "char *{cxx_var} = {c_helper_char_alloc}(\t{c_var},\t {c_var_cfi}->elem_len,\t\
    \ {c_blanknull});"
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: in
  name: f_in_char_*_cfi
  owner: library
f_in_char_scalar:
  c_arg_decl:
  - char {c_var}
  f_arg_decl:
  - 'character, value, intent(IN) :: {f_var}'
  i_arg_decl:
  - 'character(kind=C_CHAR), value, intent(IN) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_CHAR
  intent: in
  name: f_in_char_scalar
  owner: library
f_in_native_&:
  intent: in
  name: f_in_native_&
  owner: library
f_in_native_*:
  intent: in
  name: f_in_native_*
  owner: library
f_in_native_**:
  c_arg_decl:
  - '{cxx_type} **{cxx_var}'
  i_arg_decl:
  - 'type(C_PTR), intent(IN), value :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: f_in_native_**
  owner: library
f_in_native_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = {sh_type}'
  - '! {f_var_cdesc}%elem_len = C_SIZEOF()'
  - '{f_var_cdesc}%size = {size}'
  - '{f_var_cdesc}%rank = {rank}{f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: in
  name: f_in_native_*_cdesc
  owner: library
f_in_native_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_pre_call:
  - '{cxx_type} *{cxx_var} = {cast_static}{cxx_type} *{cast1}{c_var_cfi}->base_addr{cast2};'
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: in
  name: f_in_native_*_cfi
  owner: library
f_in_native_scalar:
  intent: in
  name: f_in_native_scalar
  owner: library
f_in_shadow_&:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}'
  f_need_wrapper: true
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: in
  name: f_in_shadow_&
  owner: library
f_in_shadow_*:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}'
  f_need_wrapper: true
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: in
  name: f_in_shadow_*
  owner: library
f_in_shadow_scalar:
  c_arg_decl:
  - '{c_type} {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}.addr{cast2};"
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}'
  f_need_wrapper: true
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}), value :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: in
  name: f_in_shadow_scalar
  owner: library
f_in_string_&:
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  intent: in
  name: f_in_string_&
  owner: library
f_in_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_pre_call:
  - "{c_const}std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: f_in_string_&_buf
  owner: library
f_in_string_&_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_len_trim
  c_local:
  - trim
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - size_t {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_cfi}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_local_trim});'
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: in
  name: f_in_string_&_cfi
  owner: library
f_in_string_*:
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  intent: in
  name: f_in_string_*
  owner: library
f_in_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_pre_call:
  - "{c_const}std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: f_in_string_*_buf
  owner: library
f_in_string_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_len_trim
  c_local:
  - trim
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - size_t {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_cfi}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_local_trim});'
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: in
  name: f_in_string_*_cfi
  owner: library
f_in_string_scalar:
  c_arg_decl:
  - char *{c_var}
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_CHAR
  intent: in
  name: f_in_string_scalar
  owner: library
f_in_string_scalar_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_call:
  - XXX{cxx_var}
  c_helper:
  - char_len_trim
  c_local:
  - trim
  c_pre_call:
  - int {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_len});
  - std::string {cxx_var}({c_var}, {c_local_trim});
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {f_var}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: in
  name: f_in_string_scalar_buf
  owner: library
f_in_string_scalar_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_len_trim
  c_local:
  - trim
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - size_t {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_cfi}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_local_trim});'
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: in
  name: f_in_string_scalar_cfi
  owner: library
f_in_struct_&:
  intent: in
  name: f_in_struct_&
  owner: library
f_in_struct_*:
  intent: in
  name: f_in_struct_*
  owner: library
f_in_struct_scalar:
  intent: in
  name: f_in_struct_scalar
  owner: library
f_in_unknown_scalar:
  intent: in
  name: f_in_unknown_scalar
  owner: library
f_in_vector_&_buf_targ_native_*:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_len}
  - size_t {c_var_size}
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - for (size_t i=0; i < {c_var_size}; ++i) {{+
  - '{cxx_var}.push_back({c_var} + ({c_var_len}*i));'
  - -}}
  c_temps:
  - len
  - size
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, 1, kind=C_SIZE_T)
  - size({f_var}, 2, kind=C_SIZE_T)
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}(:,:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_len}'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: f_in_vector_&_buf_targ_native_*
  owner: library
f_in_vector_&_buf_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  f_arg_decl:
  - '{f_type}, intent(IN) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: f_in_vector_&_buf_targ_native_scalar
  owner: library
f_in_vector_&_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: f_in_vector_&_buf_targ_string_scalar
  owner: library
f_in_vector_&_cdesc_targ_native_scalar:
  intent: in
  name: f_in_vector_&_cdesc_targ_native_scalar
  owner: library
f_in_vector_*_buf_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  f_arg_decl:
  - '{f_type}, intent(IN) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: f_in_vector_*_buf_targ_native_scalar
  owner: library
f_in_vector_*_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: f_in_vector_*_buf_targ_string_scalar
  owner: library
f_in_vector_scalar_buf_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  f_arg_decl:
  - '{f_type}, intent(IN) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: in
  name: f_in_vector_scalar_buf_targ_native_scalar
  owner: library
f_in_vector_scalar_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: in
  name: f_in_vector_scalar_buf_targ_string_scalar
  owner: library
f_in_void_*:
  f_arg_decl:
  - 'type(C_PTR), intent(IN) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: f_in_void_*
  owner: library
f_in_void_**:
  c_arg_decl:
  - void **{c_var}
  f_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: f_in_void_**
  owner: library
f_in_void_**_cfi:
  c_arg_decl:
  - void **{c_var}
  f_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: in
  name: f_in_void_**_cfi
  owner: library
f_in_void_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = {sh_type}'
  - '! {f_var_cdesc}%elem_len = C_SIZEOF()'
  - '{f_var_cdesc}%size = {size}'
  - '{f_var_cdesc}%rank = {rank}{f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: in
  name: f_in_void_*_cdesc
  owner: library
f_in_void_scalar:
  intent: in
  name: f_in_void_scalar
  owner: library
f_inout_bool_*:
  f_arg_call:
  - '{f_var_cxx}'
  f_declare:
  - 'logical(C_BOOL) :: {f_var_cxx}'
  f_post_call:
  - '{f_var} = {f_var_cxx}  ! coerce to logical'
  f_pre_call:
  - '{f_var_cxx} = {f_var}  ! coerce to C_BOOL'
  f_temps:
  - cxx
  intent: inout
  name: f_inout_bool_*
  owner: library
f_inout_char_*:
  intent: inout
  name: f_inout_char_*
  owner: library
f_inout_char_*_buf:
  c_arg_call:
  - '{c_var_str}'
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_alloc
  - char_copy
  - char_free
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {c_var_str},\t -1);"
  - '{c_helper_char_free}({c_var_str});'
  c_pre_call:
  - "char * {c_var_str} = {c_helper_char_alloc}(\t{c_var},\t {c_var_len},\t {c_blanknull});"
  c_temps:
  - len
  - str
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: inout
  name: f_inout_char_*_buf
  owner: library
f_inout_char_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_alloc
  - char_copy
  - char_free
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {cxx_var},\t -1);"
  - '{c_helper_char_free}({cxx_var});'
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - "char *{cxx_var} = {c_helper_char_alloc}(\t{c_var},\t {c_var_cfi}->elem_len,\t\
    \ {c_blanknull});"
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: inout
  name: f_inout_char_*_cfi
  owner: library
f_inout_native_&:
  intent: inout
  name: f_inout_native_&
  owner: library
f_inout_native_&_hidden:
  c_arg_call:
  - '{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: inout
  name: f_inout_native_&_hidden
  owner: library
f_inout_native_*:
  intent: inout
  name: f_inout_native_*
  owner: library
f_inout_native_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = {sh_type}'
  - '! {f_var_cdesc}%elem_len = C_SIZEOF()'
  - '{f_var_cdesc}%size = {size}'
  - '{f_var_cdesc}%rank = {rank}{f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: inout
  name: f_inout_native_*_cdesc
  owner: library
f_inout_native_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_pre_call:
  - '{cxx_type} *{cxx_var} = {cast_static}{cxx_type} *{cast1}{c_var_cfi}->base_addr{cast2};'
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: inout
  name: f_inout_native_*_cfi
  owner: library
f_inout_native_*_hidden:
  c_arg_call:
  - '&{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: inout
  name: f_inout_native_*_hidden
  owner: library
f_inout_shadow_&:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}'
  f_need_wrapper: true
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: inout
  name: f_inout_shadow_&
  owner: library
f_inout_shadow_*:
  c_arg_decl:
  - '{c_type} * {c_var}'
  c_pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}'
  f_need_wrapper: true
  i_arg_decl:
  - 'type({f_capsule_data_type}), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  i_module:
    '{f_type_module}':
    - '{f_capsule_data_type}'
  intent: inout
  name: f_inout_shadow_*
  owner: library
f_inout_string_&:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  impl_header:
  - <cstring>
  intent: inout
  name: f_inout_string_&
  owner: library
f_inout_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  - char_len_trim
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - "std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: inout
  name: f_inout_string_&_buf
  owner: library
f_inout_string_&_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  - char_len_trim
  c_local:
  - trim
  c_post_call:
  - "{c_helper_char_copy}({c_var},\t {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - size_t {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_cfi}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_local_trim});'
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: inout
  name: f_inout_string_&_cfi
  owner: library
f_inout_string_*:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  impl_header:
  - <cstring>
  intent: inout
  name: f_inout_string_*
  owner: library
f_inout_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  - char_len_trim
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - "std::string {cxx_var}({c_var},\t {c_helper_char_len_trim}({c_var}, {c_var_len}));"
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: inout
  name: f_inout_string_*_buf
  owner: library
f_inout_string_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  - char_len_trim
  c_local:
  - trim
  c_post_call:
  - "{c_helper_char_copy}({c_var},\t {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  c_pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  - size_t {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_cfi}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_local_trim});'
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: inout
  name: f_inout_string_*_cfi
  owner: library
f_inout_struct_&:
  intent: inout
  name: f_inout_struct_&
  owner: library
f_inout_struct_*:
  intent: inout
  name: f_inout_struct_*
  owner: library
f_inout_vector_&_cdesc_allocatable_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - type_defines
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "std::vector<{cxx_T}> *{cxx_var} = \tnew std::vector<{cxx_T}>\t(\t{c_var}, {c_var}\
    \ + {c_var_size});"
  c_temps:
  - size
  - cdesc
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable, target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - copy_array
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_LOC
  f_post_call:
  - if (allocated({f_var})) deallocate({f_var})
  - allocate({f_var}({f_var_cdesc}%size))
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: inout
  name: f_inout_vector_&_cdesc_allocatable_targ_native_scalar
  owner: library
f_inout_vector_&_cdesc_targ_native_scalar:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  - type_defines
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "std::vector<{cxx_T}> *{cxx_var} = \tnew std::vector<{cxx_T}>\t(\t{c_var}, {c_var}\
    \ + {c_var_size});"
  c_temps:
  - size
  - cdesc
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  - copy_array
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_LOC
  f_post_call:
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: inout
  name: f_inout_vector_&_cdesc_targ_native_scalar
  owner: library
f_inout_vector_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_len_trim
  c_local:
  - i
  - n
  - s
  c_post_call:
  - '{{+'
  - char * {c_local_s} = {c_var};
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -{c_local_n} = std::min({cxx_var}.size(),{c_local_n});
  - for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{c_helper_char_copy}({c_local_s}, {c_var_len},\t {cxx_var}[{c_local_i}].data(),\t\
    \ {cxx_var}[{c_local_i}].size());"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * {c_local_s} = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{cxx_var}.push_back(std::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s},\
    \ {c_var_len})));"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: inout
  name: f_inout_vector_buf_targ_string_scalar
  owner: library
f_inout_void_**:
  c_arg_decl:
  - void **{c_var}
  f_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: inout
  name: f_inout_void_**
  owner: library
f_inout_void_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = {sh_type}'
  - '! {f_var_cdesc}%elem_len = C_SIZEOF()'
  - '{f_var_cdesc}%size = {size}'
  - '{f_var_cdesc}%rank = {rank}{f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: inout
  name: f_inout_void_*_cdesc
  owner: library
f_mixin_arg_capsule:
  c_arg_decl:
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_temps:
  - capsule
  comments:
  - Add a capsule argument to the Fortran wrapper.
  - Pass the capsule as argument to C wrapper.
  f_arg_call:
  - '{f_var_capsule}%mem'
  f_arg_decl:
  - 'type({F_capsule_type}), intent(OUT) :: {f_var_capsule}'
  f_arg_name:
  - '{f_var_capsule}'
  f_helper:
  - array_context
  - capsule_helper
  f_need_wrapper: true
  f_temps:
  - capsule
  fmtdict:
    f_var_capsule: Crv
  i_arg_decl:
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_capsule}'
  i_import:
  - '{F_capsule_data_type}'
  intent: mixin
  name: f_mixin_arg_capsule
  owner: library
f_mixin_capsule_dtor:
  comments:
  - Release memory from capsule.
  f_helper:
  - capsule_dtor
  f_post_call:
  - call {f_helper_capsule_dtor}({f_var_capsule})
  intent: mixin
  name: f_mixin_capsule_dtor
  owner: library
f_mixin_char_cdesc_allocate:
  c_helper:
  - copy_string
  comments:
  - Allocate Fortran CHARACTER scalar, then fill from cdesc.
  - using helper copy_string.
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_helper:
  - copy_string
  f_post_call:
  - 'allocate(character(len={f_var_cdesc}%elem_len):: {f_var})'
  - "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
  intent: mixin
  name: f_mixin_char_cdesc_allocate
  owner: library
f_mixin_char_cdesc_pointer:
  comments:
  - Assign Fortran pointer from cdesc using helper pointer_string.
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_helper:
  - pointer_string
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_post_call:
  - "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
  intent: mixin
  name: f_mixin_char_cdesc_pointer
  owner: library
f_mixin_function:
  f_call:
  - '{F_result} = {F_C_call}({F_arg_c_call})'
  intent: mixin
  name: f_mixin_function
  owner: library
f_mixin_function-to-subroutine:
  c_return_type: void
  comments:
  - Call the C wrapper as a subroutine.
  f_call:
  - call {F_C_call}({F_arg_c_call})
  intent: mixin
  name: f_mixin_function-to-subroutine
  owner: library
f_mixin_function_c-ptr:
  c_need_wrapper: true
  comments:
  - Return a C pointer as a type(C_PTR).
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_declare:
  - 'type(C_PTR) :: {f_local_ptr}'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_local_ptr}, {F_result})
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: mixin
  name: f_mixin_function_c-ptr
  owner: library
f_mixin_function_ptr:
  f_arg_decl:
  - 'type(C_PTR) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: mixin
  name: f_mixin_function_ptr
  owner: library
f_mixin_function_shadow_capptr:
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  - 'type(C_PTR) :: {f_local_ptr}'
  f_call:
  - '{f_local_ptr} = {F_C_call}({F_arg_c_call})'
  f_local:
  - ptr
  f_module:
    iso_c_binding:
    - C_PTR
  f_need_wrapper: true
  fmtdict:
    f_local_ptr: '{F_result_ptr}'
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - 'type(C_PTR) :: {F_result_ptr}'
  i_result_var: '{F_result_ptr}'
  intent: mixin
  name: f_mixin_function_shadow_capptr
  owner: library
f_mixin_function_shadow_capsule:
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type} :: {f_var}'
  f_need_wrapper: true
  intent: mixin
  name: f_mixin_function_shadow_capsule
  owner: library
f_mixin_function_string_scalar_cfi_allocatable:
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  f_need_wrapper: true
  intent: mixin
  name: f_mixin_function_string_scalar_cfi_allocatable
  owner: library
f_mixin_getter_cdesc:
  c_call:
  - '{c_var_cdesc}->base_addr = {CXX_this}->{field_name};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_helper:
  - type_defines
  - array_context
  comments:
  - Save pointer struct members in a cdesc
  - along with shape information.
  intent: mixin
  name: f_mixin_getter_cdesc
  owner: library
f_mixin_helper_array_string_allocatable:
  c_arg_call:
  - '&{cxx_var}'
  c_helper:
  - array_string_allocatable
  - array_string_out_len
  c_post_call:
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size     = {c_array_size};'
  - if ({c_char_len} > 0) {{+
  - '{c_var_cdesc}->elem_len = {c_char_len};'
  - -}} else {{+
  - '{c_var_cdesc}->elem_len = {c_helper_array_string_out_len}({cxx_var}, {c_var_cdesc}->size);'
  - -}}
  c_pre_call:
  - std::string *{cxx_var};
  comments:
  - Allocate a vector<string> variable.
  - Assign to std::string pointer from C++ function.
  - Copy into Fortran allocated memory.
  f_helper:
  - array_string_allocatable
  f_post_call:
  - call {f_helper_array_string_allocatable}({f_var_cdesc}, {f_var_capsule})
  intent: mixin
  name: f_mixin_helper_array_string_allocatable
  owner: library
f_mixin_helper_vector_string_allocatable:
  c_arg_call:
  - '*{cxx_var}'
  c_helper:
  - vector_string_allocatable
  - vector_string_out_len
  c_post_call:
  - if ({c_char_len} > 0) {{+
  - '{c_var_cdesc}->elem_len = {c_char_len};'
  - -}} else {{+
  - '{c_var_cdesc}->elem_len = {c_helper_vector_string_out_len}(*{cxx_var});'
  - -}}
  - '{c_var_cdesc}->size      = {cxx_var}->size();'
  c_pre_call:
  - std::vector<std::string> *{cxx_var} = new std::vector<std::string>;
  comments:
  - Allocate a vector<string> variable.
  - Copy into Fortran allocated memory.
  cxx_local_var: pointer
  f_helper:
  - vector_string_allocatable
  f_post_call:
  - call {f_helper_vector_string_allocatable}({f_var_cdesc}, {f_var_capsule})
  intent: mixin
  name: f_mixin_helper_vector_string_allocatable
  owner: library
f_mixin_in_2d_array_buf:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_len}
  - size_t {c_var_size}
  c_temps:
  - len
  - size
  f_arg_call:
  - '{f_var}'
  - size({f_var}, 1, kind=C_SIZE_T)
  - size({f_var}, 2, kind=C_SIZE_T)
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}(:,:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_len}'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: mixin
  name: f_mixin_in_2d_array_buf
  owner: library
f_mixin_in_array_buf:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t {c_var_size}
  c_temps:
  - size
  comments:
  - Pass argument and size by value to C.
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  f_arg_decl:
  - '{f_type}, intent(IN) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: mixin
  name: f_mixin_in_array_buf
  owner: library
f_mixin_in_character_buf:
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  intent: mixin
  name: f_mixin_in_character_buf
  owner: library
f_mixin_in_string_array_buf:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_temps:
  - size
  - len
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: mixin
  name: f_mixin_in_string_array_buf
  owner: library
f_mixin_inout_array_cdesc:
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - '{f_var_cdesc}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_temps:
  - cdesc
  intent: mixin
  name: f_mixin_inout_array_cdesc
  owner: library
f_mixin_inout_char_array_cdesc:
  f_arg_call:
  - '{f_var_cdesc}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_temps:
  - cdesc
  intent: mixin
  name: f_mixin_inout_char_array_cdesc
  owner: library
f_mixin_local-logical-var:
  f_arg_call:
  - '{f_var_cxx}'
  f_declare:
  - 'logical(C_BOOL) :: {f_var_cxx}'
  f_temps:
  - cxx
  intent: mixin
  name: f_mixin_local-logical-var
  owner: library
f_mixin_native_cdesc_allocate:
  c_helper:
  - copy_array
  comments:
  - Allocate Fortran native array, then fill from cdesc
  - using helper copy_array.
  f_arg_decl:
  - '{f_type}, allocatable, target :: {f_var}{f_assumed_shape}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_post_call:
  - allocate({f_var}{f_array_allocate})
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},\t\
    \ kind=C_SIZE_T))"
  intent: mixin
  name: f_mixin_native_cdesc_allocate
  owner: library
f_mixin_native_cdesc_pointer:
  comments:
  - Set Fortran pointer to native array.
  f_arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  intent: mixin
  name: f_mixin_native_cdesc_pointer
  owner: library
f_mixin_native_cdesc_raw:
  comments:
  - Set Fortran pointer to pointers to arrays.
  - '''double **'' function returns ''type(C_PTR), pointer :: array(:)'''
  f_arg_decl:
  - 'type(C_PTR), pointer :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  f_post_call:
  - "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {F_result}{f_array_shape})"
  intent: mixin
  name: f_mixin_native_cdesc_raw
  owner: library
f_mixin_out_array_buf:
  c_arg_decl:
  - '{cxx_type} *{c_var}'
  - size_t *{c_var_size}
  c_temps:
  - size
  comments:
  - Pass argument and size by reference to C.
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  f_module:
    iso_c_binding:
    - C_SIZE_T
  f_need_wrapper: true
  i_arg_decl:
  - '{f_type}, intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent({f_intent}) :: {i_var_size}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
    - C_SIZE_T
  intent: mixin
  name: f_mixin_out_array_buf
  owner: library
f_mixin_out_array_cdesc_allocatable:
  comments:
  - Allocate Fortran array from cdesc.
  f_arg_decl:
  - 'character({f_char_len}), intent(OUT), allocatable, target :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_LOC
  f_post_call:
  - allocate({f_char_type}{f_var}({f_var_cdesc}%size))
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  intent: mixin
  name: f_mixin_out_array_cdesc_allocatable
  owner: library
f_mixin_out_native_cdesc_allocate:
  c_helper:
  - copy_array
  comments:
  - Allocate Fortran native array for argument
  - then fill from cdesc using helper copy_array.
  f_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable, target :: {f_var}{f_assumed_shape}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_post_call:
  - allocate({f_var}{f_array_allocate})
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t {f_var_cdesc}%size)"
  intent: mixin
  name: f_mixin_out_native_cdesc_allocate
  owner: library
f_mixin_out_native_cdesc_pointer:
  comments:
  - Set Fortran pointer to native array.
  f_arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_post_call:
  - call c_f_pointer({f_var_cdesc}%base_addr, {f_var}{f_array_shape})
  intent: mixin
  name: f_mixin_out_native_cdesc_pointer
  owner: library
f_mixin_out_string_**_cfi:
  c_arg_call:
  - '&{c_var_cxx}'
  c_pre_call:
  - std::string *{c_var_cxx};
  c_temps:
  - cxx
  intent: mixin
  name: f_mixin_out_string_**_cfi
  owner: library
f_mixin_pass_capsule:
  c_arg_decl:
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_temps:
  - capsule
  comments:
  - Pass local capsule as argument to C wrapper.
  f_arg_call:
  - '{f_var_capsule}'
  f_declare:
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  f_need_wrapper: true
  f_temps:
  - capsule
  i_arg_decl:
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_capsule}'
  i_import:
  - '{F_capsule_data_type}'
  intent: mixin
  name: f_mixin_pass_capsule
  owner: library
f_mixin_pass_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_need_wrapper: true
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: mixin
  name: f_mixin_pass_cdesc
  owner: library
f_mixin_shadow-arg:
  f_arg_call:
  - '{f_var}%{F_derived_member}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}'
  f_need_wrapper: true
  intent: mixin
  name: f_mixin_shadow-arg
  owner: library
f_mixin_str_array:
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = SH_TYPE_CHAR'
  - '{f_var_cdesc}%elem_len = len({f_var})'
  - '{f_var_cdesc}%size = size({f_var})'
  - '{f_var_cdesc}%rank = rank({f_var}){f_cdesc_shape}'
  intent: mixin
  name: f_mixin_str_array
  owner: library
f_mixin_unknown:
  c_arg_decl:
  - ===>{c_var}<===
  comments:
  - Default returned by lookup_fc_stmts when group is not found.
  intent: mixin
  name: f_mixin_unknown
  owner: library
f_mixin_use_capsule:
  c_arg_decl:
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_post_call:
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_temps:
  - capsule
  comments:
  - Pass local capsule as argument to C wrapper.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_capsule}'
  f_declare:
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - capsule_dtor
  f_need_wrapper: true
  f_post_call:
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - capsule
  i_arg_decl:
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_capsule}'
  i_import:
  - '{F_capsule_data_type}'
  intent: mixin
  name: f_mixin_use_capsule
  owner: library
f_out_bool_*:
  f_arg_call:
  - '{f_var_cxx}'
  f_declare:
  - 'logical(C_BOOL) :: {f_var_cxx}'
  f_post_call:
  - '{f_var} = {f_var_cxx}  ! coerce to logical'
  f_temps:
  - cxx
  intent: out
  name: f_out_bool_*
  owner: library
f_out_char_*:
  intent: out
  name: f_out_char_*
  owner: library
f_out_char_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_blank_fill
  c_post_call:
  - '{c_helper_char_blank_fill}({c_var}, {c_var_len});'
  c_temps:
  - len
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: out
  name: f_out_char_*_buf
  owner: library
f_out_char_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_blank_fill
  c_post_call:
  - '{c_helper_char_blank_fill}({cxx_var}, {c_var_cfi}->elem_len);'
  c_pre_call:
  - char *{cxx_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  c_temps:
  - cfi
  cxx_local_var: pointer
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_char_*_cfi
  owner: library
f_out_native_&:
  intent: out
  name: f_out_native_&
  owner: library
f_out_native_&_hidden:
  c_arg_call:
  - '{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: out
  name: f_out_native_&_hidden
  owner: library
f_out_native_*:
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {f_var}{f_assumed_shape}'
  intent: out
  name: f_out_native_*
  owner: library
f_out_native_*&_cdesc:
  c_arg_call:
  - '{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Set Fortran pointer to native array.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - call c_f_pointer({f_var_cdesc}%base_addr, {f_var}{f_array_shape})
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_native_*&_cdesc
  owner: library
f_out_native_*&_cdesc_pointer:
  c_arg_call:
  - '{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Set Fortran pointer to native array.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - call c_f_pointer({f_var_cdesc}%base_addr, {f_var}{f_array_shape})
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_native_*&_cdesc_pointer
  owner: library
f_out_native_***:
  intent: out
  name: f_out_native_***
  owner: library
f_out_native_**_cdesc_allocatable:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
  c_temps:
  - cdesc
  - capsule
  comments:
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Allocate Fortran native array for argument
  - then fill from cdesc using helper copy_array.
  - Pass local capsule as argument to C wrapper.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable, target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - copy_array
  - array_context
  - capsule_dtor
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_need_wrapper: true
  f_post_call:
  - allocate({f_var}{f_array_allocate})
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t {f_var_cdesc}%size)"
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: out
  name: f_out_native_**_cdesc_allocatable
  owner: library
f_out_native_**_cdesc_pointer:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_type});'
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size = {c_array_size};'
  c_pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  - Fill cdesc from native in the C wrapper.
  - Set Fortran pointer to native array.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - array_context
  f_module:
    iso_c_binding:
    - c_f_pointer
  f_need_wrapper: true
  f_post_call:
  - call c_f_pointer({f_var_cdesc}%base_addr, {f_var}{f_array_shape})
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_native_**_cdesc_pointer
  owner: library
f_out_native_**_cfi_allocatable:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - if ({cxx_var} != {nullptr}) {{+
  - "{c_temp_lower_decl}{c_temp_extents_decl}int SH_ret = CFI_allocate({c_var_cfi},\
    \ \t{c_temp_lower_use}, \t{c_temp_extents_use}, \t0);"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}, \t{c_var_cfi}->elem_len);"
  - -}}
  - -}}
  c_pre_call:
  - '{c_const}{c_type} * {cxx_var};'
  c_temps:
  - cfi
  - extents
  - lower
  cxx_local_var: pointer
  i_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_native_**_cfi_allocatable
  owner: library
f_out_native_**_cfi_pointer:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - err
  c_post_call:
  - '{{+'
  - CFI_CDESC_T({rank}) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<{c_type} *>({cxx_var});
  - "{c_temp_extents_decl}{c_temp_lower_decl}int {c_local_err} = CFI_establish({c_local_cdesc},\t\
    \ {c_local_cptr},\t CFI_attribute_pointer,\t {cfi_type},\t 0,\t {rank},\t {c_temp_extents_use});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {c_temp_lower_use});"
  - -}}
  - -}}
  c_pre_call:
  - '{c_const}{c_type} * {cxx_var};'
  c_temps:
  - cfi
  - extents
  - lower
  cxx_local_var: pointer
  i_arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - '{f_kind}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_native_**_cfi_pointer
  owner: library
f_out_native_**_raw:
  f_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  intent: out
  name: f_out_native_**_raw
  owner: library
f_out_native_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = {sh_type}'
  - '! {f_var_cdesc}%elem_len = C_SIZEOF()'
  - '{f_var_cdesc}%size = {size}'
  - '{f_var_cdesc}%rank = {rank}{f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_native_*_cdesc
  owner: library
f_out_native_*_cfi_allocatable:
  intent: out
  name: f_out_native_*_cfi_allocatable
  owner: library
f_out_native_*_hidden:
  c_arg_call:
  - '&{cxx_var}'
  c_pre_call:
  - '{cxx_type} {cxx_var};'
  intent: out
  name: f_out_native_*_hidden
  owner: library
f_out_string_&:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var};'
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  intent: out
  name: f_out_string_&
  owner: library
f_out_string_&_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - std::string {cxx_var};
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: out
  name: f_out_string_&_buf
  owner: library
f_out_string_&_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var},\t {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  c_pre_call:
  - std::string {cxx_var};
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_string_&_cfi
  owner: library
f_out_string_*:
  c_post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  c_pre_call:
  - '{c_const}std::string {cxx_var};'
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  intent: out
  name: f_out_string_*
  owner: library
f_out_string_**_cdesc_allocatable:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - array_string_allocatable
  - array_string_out_len
  c_post_call:
  - '{c_var_cdesc}->rank = {rank};{c_array_shape}'
  - '{c_var_cdesc}->size     = {c_array_size};'
  - if ({c_char_len} > 0) {{+
  - '{c_var_cdesc}->elem_len = {c_char_len};'
  - -}} else {{+
  - '{c_var_cdesc}->elem_len = {c_helper_array_string_out_len}({cxx_var}, {c_var_cdesc}->size);'
  - -}}
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - std::string *{cxx_var};
  c_temps:
  - cdesc
  - capsule
  comments:
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Allocate Fortran array from cdesc.
  - Allocate a vector<string> variable.
  - Assign to std::string pointer from C++ function.
  - Copy into Fortran allocated memory.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character({f_char_len}), intent(OUT), allocatable, target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - array_string_allocatable
  - capsule_dtor
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_post_call:
  - allocate({f_char_type}{f_var}({f_var_cdesc}%size))
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - call {f_helper_array_string_allocatable}({f_var_cdesc}, {f_var_capsule})
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: out
  name: f_out_string_**_cdesc_allocatable
  owner: library
f_out_string_**_cdesc_copy:
  c_arg_call:
  - '&{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_string_out
  c_post_call:
  - "{c_helper_array_string_out}(\t{c_var_cdesc},\t {cxx_var}, {c_array_size2});"
  c_pre_call:
  - std::string *{cxx_var};
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = SH_TYPE_CHAR'
  - '{f_var_cdesc}%elem_len = len({f_var})'
  - '{f_var_cdesc}%size = size({f_var})'
  - '{f_var_cdesc}%rank = rank({f_var}){f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_string_**_cdesc_copy
  owner: library
f_out_string_**_cfi_allocatable:
  c_arg_call:
  - '&{c_var_cxx}'
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - // Allocate and copy into {c_var}
  c_pre_call:
  - std::string *{c_var_cxx};
  c_temps:
  - cfi
  - cxx
  i_arg_decl:
  - 'character(*), intent({f_intent}) :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_string_**_cfi_allocatable
  owner: library
f_out_string_**_cfi_copy:
  c_arg_call:
  - '&{c_var_cxx}'
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_post_call:
  - // Copy results into {c_var}
  c_pre_call:
  - std::string *{c_var_cxx};
  c_temps:
  - cfi
  - cxx
  i_arg_decl:
  - 'character(*), intent({f_intent}) :: {i_var}{f_assumed_shape}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_string_**_cfi_copy
  owner: library
f_out_string_**_copy:
  intent: out
  name: f_out_string_**_copy
  notimplemented: true
  owner: library
f_out_string_*_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  c_pre_call:
  - std::string {cxx_var};
  c_temps:
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: out
  name: f_out_string_*_buf
  owner: library
f_out_string_*_cfi:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_helper:
  - char_copy
  c_post_call:
  - "{c_helper_char_copy}({c_var},\t {c_var_cfi}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  c_pre_call:
  - std::string {cxx_var};
  - char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};
  c_temps:
  - cfi
  cxx_local_var: scalar
  i_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: out
  name: f_out_string_*_cfi
  owner: library
f_out_struct_&:
  intent: out
  name: f_out_struct_&
  owner: library
f_out_struct_*:
  intent: out
  name: f_out_struct_*
  owner: library
f_out_vector_&_cdesc_allocatable_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable, target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_need_wrapper: true
  f_post_call:
  - allocate({f_var}({f_var_cdesc}%size))
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_vector_&_cdesc_allocatable_targ_native_scalar
  owner: library
f_out_vector_&_cdesc_allocatable_targ_string_scalar:
  c_arg_call:
  - '*{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  - '{C_capsule_data_type} *{c_var_capsule}'
  c_helper:
  - array_context
  - vector_string_allocatable
  - vector_string_out_len
  c_post_call:
  - if ({c_char_len} > 0) {{+
  - '{c_var_cdesc}->elem_len = {c_char_len};'
  - -}} else {{+
  - '{c_var_cdesc}->elem_len = {c_helper_vector_string_out_len}(*{cxx_var});'
  - -}}
  - '{c_var_cdesc}->size      = {cxx_var}->size();'
  - '{c_var_capsule}->addr  = {cxx_nonconst_ptr};'
  - '{c_var_capsule}->idtor = {idtor};'
  c_pre_call:
  - std::vector<std::string> *{cxx_var} = new std::vector<std::string>;
  c_temps:
  - cdesc
  - capsule
  comments:
  - Pass cdesc as argument to C wrapper.
  - Pass local capsule as argument to C wrapper.
  - Allocate Fortran array from cdesc.
  - Allocate a vector<string> variable.
  - Copy into Fortran allocated memory.
  - Assign to capsule in C wrapper.
  - Release memory from capsule.
  cxx_local_var: pointer
  f_arg_call:
  - '{f_var_cdesc}'
  - '{f_var_capsule}'
  f_arg_decl:
  - 'character({f_char_len}), intent(OUT), allocatable, target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  - 'type({F_capsule_data_type}) :: {f_var_capsule}'
  f_helper:
  - array_context
  - array_context
  - vector_string_allocatable
  - capsule_dtor
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_post_call:
  - allocate({f_char_type}{f_var}({f_var_cdesc}%size))
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - call {f_helper_vector_string_allocatable}({f_var_cdesc}, {f_var_capsule})
  - call {f_helper_capsule_dtor}({f_var_capsule})
  f_temps:
  - cdesc
  - capsule
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  - 'type({F_capsule_data_type}), intent(OUT) :: {i_var_capsule}'
  i_arg_names:
  - '{i_var_cdesc}'
  - '{i_var_capsule}'
  i_import:
  - '{F_array_type}'
  - '{F_capsule_data_type}'
  intent: out
  name: f_out_vector_&_cdesc_allocatable_targ_string_scalar
  owner: library
f_out_vector_&_cdesc_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_LOC
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_vector_&_cdesc_targ_native_scalar
  owner: library
f_out_vector_&_cdesc_targ_string_scalar:
  c_arg_call:
  - '{cxx_var}'
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - vector_string_out
  c_post_call:
  - "{c_helper_vector_string_out}(\t{c_var_cdesc},\t {cxx_var});"
  c_pre_call:
  - '{c_const}std::vector<std::string> {cxx_var};'
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = SH_TYPE_CHAR'
  - '{f_var_cdesc}%elem_len = len({f_var})'
  - '{f_var_cdesc}%size = size({f_var})'
  - '{f_var_cdesc}%rank = rank({f_var}){f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_vector_&_cdesc_targ_string_scalar
  owner: library
f_out_vector_*_cdesc_allocatable_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), allocatable, target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_LOC
    - C_SIZE_T
  f_need_wrapper: true
  f_post_call:
  - allocate({f_var}({f_var_cdesc}%size))
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_vector_*_cdesc_allocatable_targ_native_scalar
  owner: library
f_out_vector_*_cdesc_targ_native_scalar:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - copy_array
  - type_defines
  c_post_call:
  - '{c_var_cdesc}->base_addr = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_cdesc}->type = {sh_type};'
  - '{c_var_cdesc}->elem_len = sizeof({cxx_T});'
  - '{c_var_cdesc}->size = {cxx_var}->size();'
  - '{c_var_cdesc}->rank = 1;'
  - '{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;'
  c_pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  cxx_local_var: pointer
  destructor:
  - "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);"
  - delete cxx_ptr;
  destructor_name: std_vector_{cxx_T}
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - copy_array
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_LOC
  f_need_wrapper: true
  f_post_call:
  - "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var},kind=C_SIZE_T))"
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_vector_*_cdesc_targ_native_scalar
  owner: library
f_out_vector_buf_targ_string_scalar:
  c_arg_decl:
  - const char *{c_var}
  - size_t {c_var_size}
  - int {c_var_len}
  c_helper:
  - char_copy
  c_local:
  - i
  - n
  - s
  c_post_call:
  - '{{+'
  - char * {c_local_s} = {c_var};
  - std::vector<{cxx_T}>::size_type
  - +{c_local_i} = 0,
  - '{c_local_n} = {c_var_size};'
  - '{c_local_n} = std::min({cxx_var}.size(),{c_local_n});'
  - -for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+
  - "{c_helper_char_copy}({c_local_s}, {c_var_len},\t {cxx_var}[{c_local_i}].data(),\t\
    \ {cxx_var}[{c_local_i}].size());"
  - '{c_local_s} += {c_var_len};'
  - -}}
  - -}}
  c_pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
  c_temps:
  - size
  - len
  cxx_local_var: scalar
  f_arg_call:
  - '{f_var}'
  - size({f_var}, kind=C_SIZE_T)
  - len({f_var}, kind=C_INT)
  f_arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}(:)'
  f_module:
    iso_c_binding:
    - C_SIZE_T
    - C_INT
  f_need_wrapper: true
  i_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {i_var}(*)'
  - 'integer(C_SIZE_T), intent(IN), value :: {i_var_size}'
  - 'integer(C_INT), intent(IN), value :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_size}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_SIZE_T
    - C_INT
  intent: out
  name: f_out_vector_buf_targ_string_scalar
  owner: library
f_out_void_*&:
  intent: out
  name: f_out_void_*&
  owner: library
f_out_void_**:
  c_arg_decl:
  - void **{c_var}
  f_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_PTR
  i_arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: out
  name: f_out_void_**
  owner: library
f_out_void_*_cdesc:
  c_arg_decl:
  - '{C_array_type} *{c_var_cdesc}'
  c_helper:
  - array_context
  c_pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
  c_temps:
  - cdesc
  comments:
  - Pass cdesc as argument to C wrapper.
  f_arg_call:
  - '{f_var_cdesc}'
  f_arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_declare:
  - 'type({F_array_type}) :: {f_var_cdesc}'
  f_helper:
  - type_defines
  - array_context
  f_module:
    iso_c_binding:
    - C_LOC
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_cdesc}%base_addr = C_LOC({f_var})'
  - '{f_var_cdesc}%type = {sh_type}'
  - '! {f_var_cdesc}%elem_len = C_SIZEOF()'
  - '{f_var_cdesc}%size = {size}'
  - '{f_var_cdesc}%rank = {rank}{f_cdesc_shape}'
  f_temps:
  - cdesc
  i_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {i_var_cdesc}'
  i_arg_names:
  - '{i_var_cdesc}'
  i_import:
  - '{F_array_type}'
  intent: out
  name: f_out_void_*_cdesc
  owner: library
f_setter:
  c_call:
  - // skip call c_setter
  f_call:
  - call {F_C_call}({F_arg_c_call})
  intent: setter
  name: f_setter
  owner: library
f_setter_bool_scalar:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  f_arg_call:
  - '{f_var_cxx}'
  f_declare:
  - 'logical(C_BOOL) :: {f_var_cxx}'
  f_pre_call:
  - '{f_var_cxx} = {f_var}  ! coerce to C_BOOL'
  f_temps:
  - cxx
  intent: setter
  name: f_setter_bool_scalar
  owner: library
f_setter_native_*:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  f_arg_call:
  - '{fc_var}'
  intent: setter
  name: f_setter_native_*
  owner: library
f_setter_native_scalar:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  f_arg_call:
  - '{fc_var}'
  intent: setter
  name: f_setter_native_scalar
  owner: library
f_setter_string_scalar_buf:
  c_arg_decl:
  - char *{c_var}
  - int {c_var_len}
  c_post_call:
  - "{CXX_this}->{field_name} = std::string({c_var},\t {c_var_len});"
  c_temps:
  - len
  f_arg_call:
  - '{f_var}'
  - '{f_var_len}'
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {f_var}'
  f_declare:
  - integer(C_INT) {f_var_len}
  f_module:
    iso_c_binding:
    - C_INT
  f_need_wrapper: true
  f_pre_call:
  - '{f_var_len} = len({f_var}, kind=C_INT)'
  f_temps:
  - len
  i_arg_decl:
  - 'character(kind=C_CHAR), intent({f_intent}) :: {i_var}(*)'
  - 'integer(C_INT), value, intent(IN) :: {i_var_len}'
  i_arg_names:
  - '{i_var}'
  - '{i_var_len}'
  i_module:
    iso_c_binding:
    - C_CHAR
    - C_INT
  intent: setter
  name: f_setter_string_scalar_buf
  owner: library
f_setter_struct_*:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  intent: setter
  name: f_setter_struct_*
  owner: library
f_setter_struct_**:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  i_arg_decl:
  - 'type(C_PTR), intent(IN) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  i_module:
    iso_c_binding:
    - C_PTR
  intent: setter
  name: f_setter_struct_**
  owner: library
f_setter_struct_*_pointer:
  c_post_call:
  - '{CXX_this}->{field_name} = val;'
  i_arg_decl:
  - '{f_type}, intent(IN) :: {i_var}{i_dimension}'
  i_arg_names:
  - '{i_var}'
  intent: setter
  name: f_setter_struct_*_pointer
  owner: library
f_shared_function_string_*_cfi_pointer:
  c_arg_decl:
  - CFI_cdesc_t *{c_var_cfi}
  c_local:
  - cptr
  - fptr
  - cdesc
  - len
  - err
  c_post_call:
  - int {c_local_err};
  - if ({cxx_var} == {nullptr}) {{+
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});"
  - -}} else {{+
  - CFI_CDESC_T(0) {c_local_fptr};
  - CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};
  - void *{c_local_cptr} = const_cast<char *>({cxx_var}{cxx_member}data());
  - size_t {c_local_len} = {cxx_var}{cxx_member}length();
  - "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t\
    \ CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});"
  - if ({c_local_err} == CFI_SUCCESS) {{+
  - '{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;'
  - "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});"
  - -}}
  - -}}
  c_return_type: void
  c_temps:
  - cfi
  comments:
  - Call the C wrapper as a subroutine.
  f_arg_call:
  - '{f_var}'
  f_arg_decl:
  - 'character(len=:), pointer :: {f_var}'
  f_call:
  - call {F_C_call}({F_arg_c_call})
  f_need_wrapper: true
  i_arg_decl:
  - 'character(len=:), intent({f_intent}), pointer :: {i_var}'
  i_arg_names:
  - '{i_var}'
  iface_header:
  - ISO_Fortran_binding.h
  intent: shared
  name: f_shared_function_string_*_cfi_pointer
  owner: library
f_shared_function_string_scalar:
  c_return:
  - return {c_var};
  i_module:
    iso_c_binding:
    - C_PTR
  i_result_decl:
  - type(C_PTR) {i_var}
  intent: shared
  name: f_shared_function_string_scalar
  owner: library
f_shared_native_scalar:
  intent: shared
  name: f_shared_native_scalar
  owner: library
f_shared_struct:
  intent: shared
  name: f_shared_struct
  owner: library
f_subroutine:
  f_call:
  - call {F_C_call}({F_arg_c_call})
  intent: subroutine
  name: f_subroutine
  owner: library
f_test:
  intent: test
  name: f_test
  owner: library
***** Python
root
  py
    base
      ctor
        array -- py_base_ctor_array
          fill -- py_base_ctor_array_fill
    ctor
      char
        * -- py_ctor_char_*
          numpy -- py_ctor_char_*
        ** -- py_ctor_char_**
          list -- py_ctor_char_**
        [] -- py_ctor_char_[]
          list -- py_ctor_char_[]
          numpy -- py_ctor_char_[]
      native -- py_ctor_native
        * -- py_ctor_native_*
          list -- py_ctor_native_*
          numpy -- py_ctor_native_*
        [] -- py_ctor_native_[]
          list -- py_ctor_native_[]
          numpy -- py_ctor_native_[]
        scalar
          list -- py_ctor_native
          numpy -- py_ctor_native
    defaulttmp -- py_defaulttmp
    descr
      bool
        scalar -- py_descr_bool_scalar
      char
        * -- py_descr_char_*
          numpy -- py_descr_char_*
        **
          list -- py_descr_char_**_list
        [] -- py_descr_char_[]
          list -- py_descr_char_[]
          numpy -- py_descr_char_[]
      native
        *
          list -- py_descr_native_*_list
          numpy -- py_descr_native_*_numpy
        []
          list -- py_descr_native_[]_list
          numpy -- py_descr_native_[]_numpy
        scalar -- py_descr_native_scalar
    function
      bool
        scalar -- py_function_bool_scalar
      char
        * -- py_function_char_*
        scalar -- py_function_char_scalar
      native
        &
          numpy -- py_function_native_*/&_numpy
        *
          list -- py_function_native_*_list
          numpy -- py_function_native_*/&_numpy
          scalar -- py_defaulttmp
        scalar -- py_defaulttmp
      shadow
        & -- py_function_shadow_*
        * -- py_function_shadow_*
        scalar -- py_out_struct_*_class
      string
        & -- py_function_string_*
        * -- py_function_string_*
        scalar -- py_function_string_scalar
      struct
        class -- py_function_struct_class
        list -- py_defaulttmp
        numpy -- py_function_struct_numpy
      vector
        list -- py_function_vector_list
          targ
            native
              scalar -- py_function_vector_list
        numpy -- py_function_vector_numpy
          targ
            native
              scalar -- py_function_vector_numpy
      void
        * -- py_function_void_*
    in
      bool
        scalar -- py_in_bool_scalar
      char
        * -- py_in_char_*
        ** -- py_in_char_**
        scalar -- py_in_char_scalar
      native
        & -- py_in_native_&
        * -- py_in_native_*
          list -- py_in_native_*_list
          numpy -- py_in_native_*_numpy
        scalar -- py_defaulttmp
      shadow
        & -- py_in_shadow_&
        * -- py_in_shadow_*
        scalar -- py_in_shadow_scalar
      string
        & -- py_in_string_scalar
        * -- py_in_string_*
        scalar -- py_in_string_scalar
      struct
        &
          class -- py_in_struct_&_class
          numpy -- py_in_struct_&_numpy
        *
          class -- py_in_struct_*_class
          list -- py_in_struct_*_list
          numpy -- py_in_struct_*_numpy
        list -- py_in_struct_list
        scalar
          class -- py_in_struct_scalar_class
          list -- py_in_struct_list
          numpy -- py_in_struct_scalar_numpy
      unknown
        scalar -- py_defaulttmp
      vector
        list -- py_in_vector_list
        numpy -- py_in_vector_numpy
      void
        * -- py_in_void_*
    inout
      bool -- py_inout_bool
        * -- py_inout_bool_*
      char
        * -- py_inout_char_*
      native
        & -- py_inout_native_&
        * -- py_inout_native_*
          list -- py_inout_native_*_list
          numpy -- py_inout_native_*_numpy
      shadow
        * -- py_inout_shadow_*
      string
        & -- py_inout_string_scalar
        * -- py_inout_string_*
        scalar -- py_inout_string_scalar
      struct
        &
          class -- py_inout_struct_&_class
          numpy -- py_inout_struct_&_numpy
        *
          class -- py_inout_struct_*_class
          list -- py_inout_struct_*_list
          numpy -- py_inout_struct_*_numpy
        list -- py_inout_struct_list
    mixin
      unknown -- py_mixin_unknown
    out
      bool -- py_out_bool
        * -- py_out_bool_*
      char
        *
          charlen -- py_out_char_*_charlen
      native
        & -- py_out_native_&
        * -- py_out_native_*
          list -- py_out_native_*_list
          numpy -- py_out_native_*_numpy
        *&
          numpy -- py_out_native_*&_numpy
        **
          list -- py_out_native_**_list
          numpy -- py_out_native_**_numpy
          raw -- py_out_native_**_raw
      shadow
        * -- py_out_shadow_*
      string
        & -- py_out_string_scalar
        * -- py_out_string_*
        scalar -- py_out_string_scalar
      struct
        &
          class -- py_out_struct_&_class
          numpy -- py_out_struct_&_numpy
        *
          class -- py_out_struct_*_class
          list -- py_out_struct_*_list
          numpy -- py_out_struct_*_numpy
        list -- py_out_struct_list
      vector
        list -- py_out_vector_list
        numpy -- py_out_vector_numpy
      void
        *& -- py_out_void_*&
        ** -- py_out_void_**
py_base_ctor_array:
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: base
  name: py_base_ctor_array
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_base_ctor_array_fill:
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: base
  name: py_base_ctor_array_fill
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_char_*:
  c_helper: get_from_object_char
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_char_*
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_char_**:
  c_helper: get_from_object_charptr
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_char_**
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}char **{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_char_**_list:
  c_helper: get_from_object_charptr
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_char_**_list
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}char **{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_char_*_numpy:
  c_helper: get_from_object_char
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_char_*_numpy
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_char_[]:
  c_helper: fill_from_PyObject_char
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: ctor
  name: py_ctor_char_[]
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_char_[]_list:
  c_helper: fill_from_PyObject_char
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: ctor
  name: py_ctor_char_[]_list
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_char_[]_numpy:
  c_helper: fill_from_PyObject_char
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: ctor
  name: py_ctor_char_[]_numpy
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_native:
  declare:
  - '{c_type} {c_var} = 0;'
  intent: ctor
  name: py_ctor_native
  post_call:
  - SH_obj->{field_name} = {field_name};
py_ctor_native_*:
  c_helper: get_from_object_{c_type}_{PY_array_arg}
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_native_*
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_native_*_list:
  c_helper: get_from_object_{c_type}_{PY_array_arg}
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_native_*_list
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_native_*_numpy:
  c_helper: get_from_object_{c_type}_{PY_array_arg}
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  intent: ctor
  name: py_ctor_native_*_numpy
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_native_[]:
  c_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: ctor
  name: py_ctor_native_[]
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_native_[]_list:
  c_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: ctor
  name: py_ctor_native_[]_list
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_native_[]_numpy:
  c_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  intent: ctor
  name: py_ctor_native_[]_numpy
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_native_scalar_list:
  declare:
  - '{c_type} {c_var} = 0;'
  intent: ctor
  name: py_ctor_native_scalar_list
  post_call:
  - SH_obj->{field_name} = {field_name};
py_ctor_native_scalar_numpy:
  declare:
  - '{c_type} {c_var} = 0;'
  intent: ctor
  name: py_ctor_native_scalar_numpy
  post_call:
  - SH_obj->{field_name} = {field_name};
py_defaulttmp:
  intent: defaulttmp
  name: py_defaulttmp
py_descr_bool_scalar:
  getter:
  - return PyBool_FromLong({c_var});
  intent: descr
  name: py_descr_bool_scalar
  setter:
  - int rv = {PY_get};
  - if (PyErr_Occurred()) {{+
  - return -1;
  - -}}
  - '{c_var} = rv;'
py_descr_char_*:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - PyObject * rv = {ctor};
  - return rv;
  intent: descr
  name: py_descr_char_*
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_data});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_data} = {nullptr};'
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_data} = cvalue.dataobj;  // steal reference'
  setter_helper: get_from_object_{c_type}_list
py_descr_char_**_list:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - PyObject *rv = {hnamefunc0}({c_var}, {npy_intp_size});
  - return rv;
  getter_helper: to_PyList_char
  intent: descr
  name: py_descr_char_**_list
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_data});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_data} = {nullptr};'
  - // XXXX set error
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_data} = cvalue.dataobj;  // steal reference'
  setter_helper: get_from_object_charptr
py_descr_char_*_numpy:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - PyObject * rv = {ctor};
  - return rv;
  intent: descr
  name: py_descr_char_*_numpy
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_data});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_data} = {nullptr};'
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_data} = cvalue.dataobj;  // steal reference'
  setter_helper: get_from_object_{c_type}_list
py_descr_char_[]:
  getter:
  - 'if ({c_var_obj} != {nullptr}) {{+

    Py_INCREF({c_var_obj});

    return {c_var_obj};

    -}}

    PyObject * rv = PyString_FromString({c_var});

    // XXX assumes is null terminated

    return rv;'
  intent: descr
  name: py_descr_char_[]
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_char
py_descr_char_[]_list:
  getter:
  - 'if ({c_var_obj} != {nullptr}) {{+

    Py_INCREF({c_var_obj});

    return {c_var_obj};

    -}}

    PyObject * rv = PyString_FromString({c_var});

    // XXX assumes is null terminated

    return rv;'
  intent: descr
  name: py_descr_char_[]_list
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_char
py_descr_char_[]_numpy:
  getter:
  - 'if ({c_var_obj} != {nullptr}) {{+

    Py_INCREF({c_var_obj});

    return {c_var_obj};

    -}}

    PyObject * rv = PyString_FromString({c_var});

    // XXX assumes is null terminated

    return rv;'
  intent: descr
  name: py_descr_char_[]_numpy
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_char
py_descr_native_*_list:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - if ({c_var_obj} != {nullptr}) {{+
  - Py_INCREF({c_var_obj});
  - return {c_var_obj};
  - -}}
  - PyObject *rv = {hnamefunc0}({c_var}, {npy_intp_size});
  - return rv;
  getter_helper: to_PyList_{c_type}
  intent: descr
  name: py_descr_native_*_list
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_obj});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_obj} = {nullptr};'
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_obj} = cvalue.obj;  // steal reference'
  setter_helper: get_from_object_{c_type}_list
py_descr_native_*_numpy:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - if ({c_var_obj} != {nullptr}) {{+
  - Py_INCREF({c_var_obj});
  - return {c_var_obj};
  - -}}
  - npy_intp {npy_dims_var}[{npy_rank}] = {{ {npy_intp_values} }};
  - "PyObject *rv = PyArray_SimpleNewFromData(\t{npy_rank},\t {npy_dims_var},\t {PYN_typenum},\t\
    \ {c_var_non_const});"
  - if (rv != {nullptr}) {{+
  - Py_INCREF(rv);
  - '{c_var_obj} = rv;'
  - -}}
  - return rv;
  intent: descr
  name: py_descr_native_*_numpy
  need_numpy: true
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_obj});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_obj} = {nullptr};'
  - // XXXX set error
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_obj} = cvalue.obj;  // steal reference'
  setter_helper: get_from_object_{c_type}_numpy
py_descr_native_[]_list:
  getter:
  - PyObject *rv = {hnamefunc0}({c_var}, {npy_intp_size});
  - return rv;
  getter_helper: to_PyList_{c_type}
  intent: descr
  name: py_descr_native_[]_list
  need_numpy: true
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
py_descr_native_[]_numpy:
  getter:
  - if ({c_var_obj} == {nullptr}) {{+
  - // Create Numpy object which points to struct member.
  - npy_intp {npy_dims_var}[{rank}] = {{ {npy_intp_values} }};
  - "{c_var_obj} = PyArray_SimpleNewFromData(\t{npy_rank},\t {npy_dims_var},\t {PYN_typenum},\t\
    \ {c_var});"
  - -}}
  - Py_INCREF({c_var_obj});
  - return {c_var_obj};
  intent: descr
  name: py_descr_native_[]_numpy
  need_numpy: true
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
py_descr_native_scalar:
  getter:
  - PyObject * rv = {ctor};
  - return rv;
  intent: descr
  name: py_descr_native_scalar
  setter:
  - '{cxx_decl} = {PY_get};'
  - if (PyErr_Occurred()) {{+
  - return -1;
  - -}}
  - '{c_var} = rv;'
py_function_bool_scalar:
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: function
  name: py_function_bool_scalar
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
py_function_char_*:
  fmtdict:
    ctor_expr: '{c_var}'
  intent: function
  name: py_function_char_*
py_function_char_scalar:
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  intent: function
  name: py_function_char_scalar
  object_created: true
  post_call:
  - '{py_var} = PyString_FromStringAndSize(&{cxx_var}, 1);'
py_function_native_&_numpy:
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: function
  name: py_function_native_&_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_function_native_*_list:
  c_helper: to_PyList_{cxx_type}
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: function
  name: py_function_native_*_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
py_function_native_*_numpy:
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: function
  name: py_function_native_*_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_function_native_*_scalar:
  intent: function
  name: py_function_native_*_scalar
py_function_native_scalar:
  intent: function
  name: py_function_native_scalar
py_function_shadow_&:
  intent: function
  name: py_function_shadow_&
  object_created: true
  post_call:
  - "{PyObject} * {py_var} =\t PyObject_New({PyObject}, &{PyTypeObject});"
  - '{py_var}->{PY_type_obj} = {cxx_addr}{cxx_var};'
py_function_shadow_*:
  intent: function
  name: py_function_shadow_*
  object_created: true
  post_call:
  - "{PyObject} * {py_var} =\t PyObject_New({PyObject}, &{PyTypeObject});"
  - '{py_var}->{PY_type_obj} = {cxx_addr}{cxx_var};'
py_function_shadow_scalar:
  arg_declare:
  - '{cxx_type} *{cxx_var} = {nullptr};'
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: function
  lang_c:
    pre_call:
    - '{c_var} = malloc(sizeof({c_type}));'
  lang_cxx:
    pre_call:
    - '{cxx_var} = new {cxx_type};'
  name: py_function_shadow_scalar
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_addr}{cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = new {cxx_type};'
py_function_string_&:
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: function
  name: py_function_string_&
py_function_string_*:
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: function
  name: py_function_string_*
py_function_string_scalar:
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: function
  name: py_function_string_scalar
py_function_struct_class:
  allocate_local_var: true
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};  // struct_class
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: function
  name: py_function_struct_class
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_addr}{cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
py_function_struct_list:
  intent: function
  name: py_function_struct_list
py_function_struct_numpy:
  allocate_local_var: true
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: function
  name: py_function_struct_numpy
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_intp_asgn}Py_INCREF({PYN_descr});'
  - "{py_var} = PyArray_NewFromDescr(&PyArray_Type, \t{PYN_descr},\t {npy_rank}, {npy_dims_var},\
    \ \t{nullptr}, {cxx_var}, 0, {nullptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_function_vector_list:
  declare:
  - PyObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: function
  name: py_function_vector_list
  object_created: true
  post_call:
  - "{py_var} = SHROUD_to_PyList_vector_{cxx_T}\t({cxx_var});"
  - if ({py_var} == {nullptr}) goto fail;
py_function_vector_list_targ_native_scalar:
  declare:
  - PyObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: function
  name: py_function_vector_list_targ_native_scalar
  object_created: true
  post_call:
  - "{py_var} = SHROUD_to_PyList_vector_{cxx_T}\t({cxx_var});"
  - if ({py_var} == {nullptr}) goto fail;
py_function_vector_numpy:
  allocate_local_var: true
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: function
  name: py_function_vector_numpy
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_dims_var}[0] = {cxx_var}->size();'
  - "{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t {numpy_type},\t\
    \ {cxx_var}->data());"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_function_vector_numpy_targ_native_scalar:
  allocate_local_var: true
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: function
  name: py_function_vector_numpy_targ_native_scalar
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_dims_var}[0] = {cxx_var}->size();'
  - "{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t {numpy_type},\t\
    \ {cxx_var}->data());"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_function_void_*:
  fmtdict:
    ctor_expr: '{cxx_var}'
  intent: function
  name: py_function_void_*
py_in_bool_scalar:
  intent: in
  name: py_in_bool_scalar
  pre_call:
  - '{cxx_var} = PyObject_IsTrue({py_var});'
py_in_char_*:
  arg_call:
  - '{c_var}'
  intent: in
  name: py_in_char_*
py_in_char_**:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{c_const}char ** {cxx_var} = {nullptr};'
  c_helper: get_from_object_charptr
  declare:
  - PyObject * {pytmp_var};
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{c_var}";'
  - Py_ssize_t {size_var};
  fail:
  - Py_XDECREF({value_var}.dataobj);
  goto_fail: true
  intent: in
  name: py_in_char_**
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_call:
  - Py_XDECREF({value_var}.dataobj);
  pre_call:
  - "if ({hnamefunc0}\t({pytmp_var}, &{value_var}) == 0)"
  - +goto fail;-
  - '{cxx_var} = {cast_static}char **{cast1}{value_var}.data{cast2};'
py_in_char_scalar:
  arg_call:
  - '{c_var}[0]'
  arg_declare:
  - char *{c_var};
  intent: in
  name: py_in_char_scalar
  parse_args:
  - '&{c_var}'
  parse_format: s
py_in_native_&:
  arg_declare:
  - '{c_type} {c_var};'
  intent: in
  name: py_in_native_&
py_in_native_*:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - '{c_type} {c_var};'
  intent: in
  name: py_in_native_*
py_in_native_*_list:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_helper: get_from_object_{cxx_type}_list
  cleanup:
  - Py_XDECREF({value_var}.dataobj);
  declare:
  - PyObject *{pytmp_var} = {nullptr};
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{c_var}";'
  - Py_ssize_t {size_var};
  fail:
  - Py_XDECREF({value_var}.dataobj);
  goto_fail: true
  intent: in
  name: py_in_native_*_list
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - "if ({hnamefunc0}\t({pytmp_var}, &{value_var}) == 0)"
  - +goto fail;-
  - '{cxx_var} = {cast_static}{cxx_type} *{cast1}{value_var}.data{cast2};'
  - '{size_var} = {value_var}.size;'
py_in_native_*_numpy:
  arg_call:
  - '{c_var}'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  declare:
  - PyObject * {pytmp_var};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: in
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_in_native_*_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_ContiguousFromObject(\t\
    {pytmp_var},\t {numpy_type},\t {rank},\t {rank}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_in_native_scalar:
  intent: in
  name: py_in_native_scalar
py_in_shadow_&:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  intent: in
  name: py_in_shadow_&
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_in_shadow_*:
  cxx_local_var: pointer
  intent: in
  name: py_in_shadow_*
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_in_shadow_scalar:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  intent: in
  name: py_in_shadow_scalar
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_in_string_&:
  arg_declare:
  - char * {c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: in
  name: py_in_string_&
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_in_string_*:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - char * {c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: in
  name: py_in_string_*
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_in_string_scalar:
  arg_declare:
  - char * {c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: in
  name: py_in_string_scalar
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_in_struct_&_class:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  intent: in
  name: py_in_struct_&_class
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_in_struct_&_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  cxx_local_var: pointer
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: in
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_in_struct_&_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_in_struct_*_class:
  cxx_local_var: pointer
  intent: in
  name: py_in_struct_*_class
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_in_struct_*_list:
  arg_call:
  - '&{cxx_var}'
  intent: in
  name: py_in_struct_*_list
py_in_struct_*_numpy:
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  cxx_local_var: pointer
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: in
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_in_struct_*_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_in_struct_list:
  intent: in
  name: py_in_struct_list
py_in_struct_scalar_class:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  intent: in
  name: py_in_struct_scalar_class
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_in_struct_scalar_list:
  intent: in
  name: py_in_struct_scalar_list
py_in_struct_scalar_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  cxx_local_var: pointer
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: in
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_in_struct_scalar_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_in_unknown_scalar:
  intent: in
  name: py_in_unknown_scalar
py_in_vector_list:
  c_helper: create_from_PyObject_vector_{cxx_T}
  cxx_local_var: scalar
  declare:
  - PyObject * {pytmp_var};
  goto_fail: true
  intent: in
  name: py_in_vector_list
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_declare:
  - std::vector<{cxx_T}> {cxx_var};
  pre_call:
  - "if ({hnamefunc0}\t({pytmp_var},\t \"{c_var}\",\t {cxx_var}) == -1)"
  - +goto fail;-
py_in_vector_numpy:
  cxx_local_var: scalar
  declare:
  - PyObject * {pytmp_var};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: in
  name: py_in_vector_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_declare:
  - std::vector<{cxx_T}> {cxx_var};
  - '{cxx_T} * {data_var};'
  post_parse:
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FROM_OTF(\t{pytmp_var},\t\
    \ {numpy_type},\t NPY_ARRAY_IN_ARRAY){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {cxx_T}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - '{data_var} = static_cast<{cxx_T} *>(PyArray_DATA({py_var}));'
  - "{cxx_var}.assign(\t{data_var},\t {data_var}+PyArray_SIZE({py_var}));"
py_in_void_*:
  arg_call:
  - '{c_var}'
  declare:
  - PyObject *{py_var};
  goto_fail: true
  intent: in
  name: py_in_void_*
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_parse:
  - '{c_var} = PyCapsule_GetPointer({py_var}, NULL);'
  - if (PyErr_Occurred())
  - +goto fail;-
py_inout_bool:
  arg_declare:
  - bool {cxx_var};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: inout
  name: py_inout_bool
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = PyObject_IsTrue({py_var});'
py_inout_bool_*:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - bool {cxx_var};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: inout
  name: py_inout_bool_*
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = PyObject_IsTrue({py_var});'
py_inout_char_*:
  arg_call:
  - '{c_var}'
  fmtdict:
    ctor_expr: '{c_var}'
  intent: inout
  name: py_inout_char_*
py_inout_native_&:
  arg_declare:
  - '{c_type} {c_var};'
  intent: inout
  name: py_inout_native_&
py_inout_native_*:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - '{c_type} {c_var};'
  fmtdict:
    ctor_expr: '{c_var}'
  intent: inout
  name: py_inout_native_*
py_inout_native_*_list:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_helper: get_from_object_{cxx_type}_list to_PyList_{cxx_type}
  cleanup:
  - Py_XDECREF({value_var}.dataobj);
  declare:
  - PyObject *{py_var};
  - PyObject *{pytmp_var} = {nullptr};
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{c_var}";'
  - Py_ssize_t {size_var};
  fail:
  - Py_XDECREF({value_var}.dataobj);
  goto_fail: true
  intent: inout
  name: py_inout_native_*_list
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_call:
  - "{py_var} = {hnamefunc1}\t({cxx_var},\t {size_var});"
  - if ({py_var} == {nullptr}) goto fail;
  post_parse:
  - "if ({hnamefunc0}\t({pytmp_var}, &{value_var}) == 0)"
  - +goto fail;-
  - '{cxx_var} = {cast_static}{cxx_type} *{cast1}{value_var}.data{cast2};'
  - '{size_var} = {value_var}.size;'
py_inout_native_*_numpy:
  arg_call:
  - '{c_var}'
  declare:
  - PyObject * {pytmp_var};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: inout
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_inout_native_*_numpy
  need_numpy: true
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FROM_OTF(\t{pytmp_var},\t\
    \ {numpy_type},\t NPY_ARRAY_INOUT_ARRAY){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_inout_shadow_*:
  cxx_local_var: pointer
  intent: inout
  name: py_inout_shadow_*
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_inout_string_&:
  arg_declare:
  - char *{c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: inout
  name: py_inout_string_&
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_inout_string_*:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - char *{c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: inout
  name: py_inout_string_*
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_inout_string_scalar:
  arg_declare:
  - char *{c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: inout
  name: py_inout_string_scalar
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_inout_struct_&_class:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  incref_on_return: true
  intent: inout
  name: py_inout_struct_&_class
  object_created: true
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_inout_struct_&_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: inout
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_inout_struct_&_numpy
  need_numpy: true
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_inout_struct_*_class:
  cxx_local_var: pointer
  incref_on_return: true
  intent: inout
  name: py_inout_struct_*_class
  object_created: true
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_inout_struct_*_list:
  arg_call:
  - '&{cxx_var}'
  intent: inout
  name: py_inout_struct_*_list
py_inout_struct_*_numpy:
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: inout
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_inout_struct_*_numpy
  need_numpy: true
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_inout_struct_list:
  intent: inout
  name: py_inout_struct_list
py_mixin_unknown:
  intent: mixin
  name: py_mixin_unknown
py_out_bool:
  arg_declare:
  - bool {cxx_var};
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  name: py_out_bool
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
py_out_bool_*:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - bool {cxx_var};
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  name: py_out_bool_*
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
py_out_char_*_charlen:
  arg_call:
  - '{c_var}'
  arg_declare:
  - '{c_const}char {c_var}[{charlen}];  // intent(out)'
  fmtdict:
    ctor_expr: '{c_var}'
  intent: out
  name: py_out_char_*_charlen
py_out_native_&:
  arg_declare:
  - '{c_const}{c_type} {c_var};'
  intent: out
  name: py_out_native_&
py_out_native_*:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - '{c_type} {c_var};'
  fmtdict:
    ctor_expr: '{c_var}'
  intent: out
  name: py_out_native_*
py_out_native_*&_numpy:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{c_const}{c_type} *{c_var};'
  declare:
  - '{npy_intp_decl}PyObject *{py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: out
  name: py_out_native_*&_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_out_native_**_list:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - '{c_const}{c_type} *{c_var};'
  c_helper: to_PyList_{cxx_type}
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  name: py_out_native_**_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
py_out_native_**_numpy:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - '{c_const}{c_type} *{c_var};'
  declare:
  - '{npy_intp_decl}PyObject *{py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: out
  name: py_out_native_**_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_out_native_**_raw:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - '{c_type} *{c_var};'
  declare:
  - PyObject *{py_var} = {nullptr};
  intent: out
  name: py_out_native_**_raw
  object_created: true
  post_call:
  - '{py_var} = PyCapsule_New({cxx_var}, NULL, NULL);'
py_out_native_*_list:
  arg_call:
  - '{c_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_header:
  - <stdlib.h>
  c_helper: to_PyList_{cxx_type}
  cleanup:
  - '{stdlib}free({cxx_var});'
  - '{cxx_var} = {nullptr};'
  cxx_header:
  - <cstdlib>
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  - "if ({cxx_var} != {nullptr})\t {stdlib}free({cxx_var});"
  goto_fail: true
  intent: out
  lang_c:
    pre_call:
    - "{c_var} = malloc(\tsizeof({c_type}) * ({array_size}));"
    - if ({cxx_var} == {nullptr}) {{+
    - PyErr_NoMemory();
    - goto fail;
    - -}}
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(std::malloc(\tsizeof({cxx_type}) *\
      \ ({array_size})));"
    - if ({cxx_var} == {nullptr}) {{+
    - PyErr_NoMemory();
    - goto fail;
    - -}}
  name: py_out_native_*_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(std::malloc(\tsizeof({cxx_type}) * ({array_size})));"
  - if ({cxx_var} == {nullptr}) {{+
  - PyErr_NoMemory();
  - goto fail;
  - -}}
py_out_native_*_numpy:
  arg_call:
  - '{c_var}'
  declare:
  - '{npy_intp_decl}PyArrayObject * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_out_native_*_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - '{npy_intp_asgn}{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_SimpleNew({npy_rank},
    {npy_dims_var}, {numpy_type}){cast2};'
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_out_shadow_*:
  declare:
  - '{PyObject} *{py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  name: py_out_shadow_*
  object_created: true
  post_call:
  - "{py_var} =\t PyObject_New({PyObject}, &{PyTypeObject});"
  - if ({py_var} == {nullptr}) goto fail;
  - '{py_var}->{PY_type_obj} = {cxx_addr}{cxx_var};'
py_out_string_&:
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: out
  name: py_out_string_&
  post_declare:
  - '{c_const}std::string {cxx_var};'
py_out_string_*:
  arg_call:
  - '&{cxx_var}'
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: out
  name: py_out_string_*
  post_declare:
  - '{c_const}std::string {cxx_var};'
py_out_string_scalar:
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  intent: out
  name: py_out_string_scalar
  post_declare:
  - '{c_const}std::string {cxx_var};'
py_out_struct_&_class:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var} = {nullptr};'
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  lang_c:
    pre_call:
    - '{c_var} = malloc(sizeof({c_type}));'
  lang_cxx:
    pre_call:
    - '{cxx_var} = new {cxx_type};'
  name: py_out_struct_&_class
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = new {cxx_type};'
py_out_struct_&_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_out_struct_&_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_NewFromDescr(\t&PyArray_Type,\t\
    \ {PYN_descr},\t 0,\t {nullptr},\t {nullptr},\t {nullptr},\t 0,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_out_struct_*_class:
  arg_declare:
  - '{cxx_type} *{cxx_var} = {nullptr};'
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  lang_c:
    pre_call:
    - '{c_var} = malloc(sizeof({c_type}));'
  lang_cxx:
    pre_call:
    - '{cxx_var} = new {cxx_type};'
  name: py_out_struct_*_class
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_addr}{cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = new {cxx_type};'
py_out_struct_*_list:
  arg_call:
  - '&{cxx_var}'
  intent: out
  name: py_out_struct_*_list
  post_declare:
  - '{cxx_type} {cxx_var};'
py_out_struct_*_numpy:
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  lang_c:
    pre_call:
    - '{c_var} = PyArray_DATA({py_var});'
  lang_cxx:
    pre_call:
    - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
  name: py_out_struct_*_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_NewFromDescr(\t&PyArray_Type,\t\
    \ {PYN_descr},\t 0,\t {nullptr},\t {nullptr},\t {nullptr},\t 0,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a {rank}-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_out_struct_list:
  intent: out
  name: py_out_struct_list
  post_declare:
  - '{cxx_type} {cxx_var};'
py_out_vector_list:
  c_helper: to_PyList_vector_{cxx_T}
  cxx_local_var: scalar
  declare:
  - PyObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  intent: out
  name: py_out_vector_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var});"
  - if ({py_var} == {nullptr}) goto fail;
  post_declare:
  - std::vector<{cxx_T}> {cxx_var};
py_out_vector_numpy:
  allocate_local_var: true
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  intent: out
  name: py_out_vector_numpy
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_dims_var}[0] = {cxx_var}->size();'
  - "{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t {numpy_type},\t\
    \ {cxx_var}->data());"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_out_void_*&:
  arg_call:
  - '{c_var}'
  arg_declare:
  - void *{c_var};
  fmtdict:
    ctor_expr: '{cxx_var}'
  intent: out
  name: py_out_void_*&
py_out_void_**:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - void *{c_var};
  fmtdict:
    ctor_expr: '{cxx_var}'
  intent: out
  name: py_out_void_**
***** Lua
root
  lua
    ctor
      scalar -- lua_ctor_scalar
    defaulttmp -- lua_defaulttmp
    dtor
      scalar -- lua_dtor_scalar
    function
      bool
        scalar -- lua_function_bool_scalar
      native
        scalar -- lua_function_native_scalar
      shadow
        * -- lua_function_shadow_*
      string
        & -- lua_function_string_&
        scalar -- lua_function_string_scalar
      void
        * -- lua_function_void_*
    in
      bool
        scalar -- lua_in_bool_scalar
      native
        * -- lua_defaulttmp
        scalar -- lua_in_native_scalar
      shadow
        * -- lua_in_shadow_*
      string
        & -- lua_in_string_*
        * -- lua_in_string_*
      unknown
        scalar -- lua_defaulttmp
      void
        scalar -- lua_defaulttmp
    inout
      native
        * -- lua_inout_native_*
    mixin
      callfunction -- lua_mixin_callfunction
      push -- lua_mixin_push
      unknown -- lua_mixin_unknown
    out
      native
        * -- lua_defaulttmp
    subroutine -- lua_subroutine
lua_ctor_scalar:
  call:
  - "{LUA_userdata_type} * {LUA_userdata_var} =\t ({LUA_userdata_type} *) lua_newuserdata({LUA_state_var},\
    \ sizeof(*{LUA_userdata_var}));"
  - "{LUA_userdata_var}->{LUA_userdata_member} =\t new {namespace_scope}{cxx_class}({cxx_call_list});"
  - /* Add the metatable to the stack. */
  - luaL_getmetatable(L, "{LUA_metadata}");
  - /* Set the metatable on the userdata. */
  - lua_setmetatable(L, -2);
  intent: ctor
  name: lua_ctor_scalar
lua_defaulttmp:
  intent: defaulttmp
  name: lua_defaulttmp
lua_dtor_scalar:
  call:
  - delete {LUA_userdata_var}->{LUA_userdata_member};
  - '{LUA_userdata_var}->{LUA_userdata_member} = NULL;'
  intent: dtor
  name: lua_dtor_scalar
lua_function_bool_scalar:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: function
  name: lua_function_bool_scalar
  post_call:
  - '{push_expr};'
lua_function_native_scalar:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: function
  name: lua_function_native_scalar
  post_call:
  - '{push_expr};'
lua_function_shadow_*:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: function
  name: lua_function_shadow_*
  post_call:
  - '{push_expr};'
lua_function_string_&:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: function
  name: lua_function_string_&
  post_call:
  - '{push_expr};'
lua_function_string_scalar:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: function
  name: lua_function_string_scalar
  post_call:
  - '{push_expr};'
lua_function_void_*:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: function
  name: lua_function_void_*
lua_in_bool_scalar:
  intent: in
  name: lua_in_bool_scalar
  pre_call:
  - bool {c_var} = {pop_expr};
lua_in_native_*:
  intent: in
  name: lua_in_native_*
lua_in_native_scalar:
  intent: in
  name: lua_in_native_scalar
  pre_call:
  - "{cxx_type} {cxx_var} =\t {pop_expr};"
lua_in_shadow_*:
  intent: in
  name: lua_in_shadow_*
  pre_call:
  - "{cxx_type} * {cxx_var} =\t {pop_expr};"
lua_in_string_&:
  intent: in
  name: lua_in_string_&
  pre_call:
  - "const char * {c_var} = \t{pop_expr};"
lua_in_string_*:
  intent: in
  name: lua_in_string_*
  pre_call:
  - "const char * {c_var} = \t{pop_expr};"
lua_in_unknown_scalar:
  intent: in
  name: lua_in_unknown_scalar
lua_in_void_scalar:
  intent: in
  name: lua_in_void_scalar
lua_inout_native_*:
  intent: inout
  name: lua_inout_native_*
  pre_call:
  - // lua_native_*_inout;
lua_mixin_callfunction:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  intent: mixin
  name: lua_mixin_callfunction
lua_mixin_push:
  intent: mixin
  name: lua_mixin_push
  post_call:
  - '{push_expr};'
lua_mixin_unknown:
  intent: mixin
  name: lua_mixin_unknown
lua_out_native_*:
  intent: out
  name: lua_out_native_*
lua_subroutine:
  call:
  - '{LUA_this_call}{function_name}({cxx_call_list});'
  intent: subroutine
  name: lua_subroutine

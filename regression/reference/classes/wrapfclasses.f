! wrapfclasses.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2021, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
!>
!! \file wrapfclasses.f
!! \brief Shroud generated wrapper for classes namespace
!<
! splicer begin file_top
! splicer end file_top
module classes_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! start helper capsule_data_helper
    ! helper capsule_data_helper
    type, bind(C) :: CLA_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type CLA_SHROUD_capsule_data
    ! end helper capsule_data_helper

    ! start array_context
    ! helper array_context
    type, bind(C) :: CLA_SHROUD_array
        ! address of C++ memory
        type(CLA_SHROUD_capsule_data) :: cxx
        ! address of data in cxx
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type CLA_SHROUD_array
    ! end array_context

    !  enum classes::Class1::DIRECTION
    integer(C_INT), parameter :: class1_up = 2
    integer(C_INT), parameter :: class1_down = 3
    integer(C_INT), parameter :: class1_left = 100
    integer(C_INT), parameter :: class1_right = 101

    ! start derived-type class1
    type class1
        type(CLA_SHROUD_capsule_data) :: cxxmem
        ! splicer begin class.Class1.component_part
        ! splicer end class.Class1.component_part
    contains
        procedure :: delete => class1_delete
        procedure :: method1 => class1_method1
        procedure :: equivalent => class1_equivalent
        procedure :: return_this => class1_return_this
        procedure :: return_this_buffer => class1_return_this_buffer
        procedure :: getclass3 => class1_getclass3
        procedure :: get_name => class1_get_name
        procedure :: direction_func => class1_direction_func
        procedure :: get_m_flag => class1_get_m_flag
        procedure :: get_test => class1_get_test
        procedure :: set_test => class1_set_test
        procedure :: get_m_name => class1_get_m_name
        procedure :: set_m_name => class1_set_m_name
        procedure :: get_instance => class1_get_instance
        procedure :: set_instance => class1_set_instance
        procedure :: associated => class1_associated
        ! splicer begin class.Class1.type_bound_procedure_part
        ! splicer end class.Class1.type_bound_procedure_part
    end type class1
    ! end derived-type class1

    type class2
        type(CLA_SHROUD_capsule_data) :: cxxmem
        ! splicer begin class.Class2.component_part
        ! splicer end class.Class2.component_part
    contains
        procedure :: get_name => class2_get_name
        procedure :: get_instance => class2_get_instance
        procedure :: set_instance => class2_set_instance
        procedure :: associated => class2_associated
        ! splicer begin class.Class2.type_bound_procedure_part
        ! splicer end class.Class2.type_bound_procedure_part
    end type class2

    type singleton
        type(CLA_SHROUD_capsule_data) :: cxxmem
        ! splicer begin class.Singleton.component_part
        ! splicer end class.Singleton.component_part
    contains
        procedure, nopass :: get_reference => singleton_get_reference
        procedure :: get_instance => singleton_get_instance
        procedure :: set_instance => singleton_set_instance
        procedure :: associated => singleton_associated
        ! splicer begin class.Singleton.type_bound_procedure_part
        ! splicer end class.Singleton.type_bound_procedure_part
    end type singleton

    type shape
        type(CLA_SHROUD_capsule_data) :: cxxmem
        ! splicer begin class.Shape.component_part
        ! splicer end class.Shape.component_part
    contains
        procedure :: get_ivar => shape_get_ivar
        procedure :: get_instance => shape_get_instance
        procedure :: set_instance => shape_set_instance
        procedure :: associated => shape_associated
        ! splicer begin class.Shape.type_bound_procedure_part
        ! splicer end class.Shape.type_bound_procedure_part
    end type shape

    type, extends(shape) :: circle
        ! splicer begin class.Circle.component_part
        ! splicer end class.Circle.component_part
    contains
        ! splicer begin class.Circle.type_bound_procedure_part
        ! splicer end class.Circle.type_bound_procedure_part
    end type circle

    interface operator (.eq.)
        module procedure class1_eq
        module procedure class2_eq
        module procedure singleton_eq
        module procedure shape_eq
        module procedure circle_eq
    end interface

    interface operator (.ne.)
        module procedure class1_ne
        module procedure class2_ne
        module procedure singleton_ne
        module procedure shape_ne
        module procedure circle_ne
    end interface

    ! ----------------------------------------
    ! Function:  Class1
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    ! start c_class1_ctor_default
    interface
        function c_class1_ctor_default(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Class1_ctor_default")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) SHT_prv
        end function c_class1_ctor_default
    end interface
    ! end c_class1_ctor_default

    ! ----------------------------------------
    ! Function:  Class1
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    ! ----------------------------------------
    ! Argument:  int flag +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! start c_class1_ctor_flag
    interface
        function c_class1_ctor_flag(flag, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Class1_ctor_flag")
            use iso_c_binding, only : C_INT, C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            integer(C_INT), value, intent(IN) :: flag
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) SHT_prv
        end function c_class1_ctor_flag
    end interface
    ! end c_class1_ctor_flag

    ! ----------------------------------------
    ! Function:  ~Class1 +name(delete)
    ! Attrs:     +intent(dtor)
    ! Requested: c_dtor_void_scalar
    ! Match:     c_dtor
    ! start c_class1_delete
    interface
        subroutine c_class1_delete(self) &
                bind(C, name="CLA_Class1_delete")
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(INOUT) :: self
        end subroutine c_class1_delete
    end interface
    ! end c_class1_delete

    ! ----------------------------------------
    ! Function:  int Method1
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! start c_class1_method1
    interface
        function c_class1_method1(self) &
                result(SHT_rv) &
                bind(C, name="CLA_Class1_method1")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_class1_method1
    end interface
    ! end c_class1_method1

    ! ----------------------------------------
    ! Function:  bool equivalent
    ! Attrs:     +intent(function)
    ! Requested: c_function_bool_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Class1 & obj2
    ! Attrs:     +intent(in)
    ! Exact:     c_in_shadow_&
    ! start c_class1_equivalent
    interface
        pure function c_class1_equivalent(self, obj2) &
                result(SHT_rv) &
                bind(C, name="CLA_Class1_equivalent")
            use iso_c_binding, only : C_BOOL
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(CLA_SHROUD_capsule_data), intent(IN) :: obj2
            logical(C_BOOL) :: SHT_rv
        end function c_class1_equivalent
    end interface
    ! end c_class1_equivalent

    ! ----------------------------------------
    ! Function:  void returnThis
    ! Attrs:     +api(capptr)+intent(subroutine)
    ! Requested: c_subroutine_void_scalar_capptr
    ! Match:     c_subroutine
    ! start c_class1_return_this
    interface
        subroutine c_class1_return_this(self) &
                bind(C, name="CLA_Class1_return_this")
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
        end subroutine c_class1_return_this
    end interface
    ! end c_class1_return_this

    ! ----------------------------------------
    ! Function:  Class1 * returnThisBuffer
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    ! ----------------------------------------
    ! Argument:  std::string & name +intent(in)
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_&
    ! ----------------------------------------
    ! Argument:  bool flag +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_bool_scalar
    ! Match:     c_default
    ! start c_class1_return_this_buffer
    interface
        function c_class1_return_this_buffer(self, name, flag, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Class1_return_this_buffer")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            character(kind=C_CHAR), intent(IN) :: name(*)
            logical(C_BOOL), value, intent(IN) :: flag
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_class1_return_this_buffer
    end interface
    ! end c_class1_return_this_buffer

    ! ----------------------------------------
    ! Function:  Class1 * returnThisBuffer
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    ! ----------------------------------------
    ! Argument:  std::string & name +intent(in)
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_&_buf
    ! ----------------------------------------
    ! Argument:  bool flag +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_bool_scalar
    ! Match:     c_default
    ! start c_class1_return_this_buffer_bufferify
    interface
        function c_class1_return_this_buffer_bufferify(self, name, &
                SHT_name_len, flag, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Class1_return_this_buffer_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT, C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
            logical(C_BOOL), value, intent(IN) :: flag
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_class1_return_this_buffer_bufferify
    end interface
    ! end c_class1_return_this_buffer_bufferify

    ! ----------------------------------------
    ! Function:  Class1 * getclass3
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    ! start c_class1_getclass3
    interface
        function c_class1_getclass3(self, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Class1_getclass3")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_class1_getclass3
    end interface
    ! end c_class1_getclass3

    ! ----------------------------------------
    ! Function:  const std::string & getName
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_&_allocatable
    ! Match:     c_function_string_&
    ! start c_class1_get_name
    interface
        function c_class1_get_name(self) &
                result(SHT_rv) &
                bind(C, name="CLA_Class1_get_name")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_class1_get_name
    end interface
    ! end c_class1_get_name

    ! ----------------------------------------
    ! Function:  const std::string & getName
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    ! start c_class1_get_name_bufferify
    interface
        subroutine c_class1_get_name_bufferify(self, SHT_rv) &
                bind(C, name="CLA_Class1_get_name_bufferify")
            import :: CLA_SHROUD_array, CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(CLA_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_class1_get_name_bufferify
    end interface
    ! end c_class1_get_name_bufferify

    ! ----------------------------------------
    ! Function:  DIRECTION directionFunc
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  DIRECTION arg +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! start c_class1_direction_func
    interface
        function c_class1_direction_func(self, arg) &
                result(SHT_rv) &
                bind(C, name="CLA_Class1_direction_func")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg
            integer(C_INT) :: SHT_rv
        end function c_class1_direction_func
    end interface
    ! end c_class1_direction_func

    ! ----------------------------------------
    ! Function:  int getM_flag
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_class1_get_m_flag
    interface
        function c_class1_get_m_flag(self) &
                result(SHT_rv) &
                bind(C, name="CLA_Class1_get_m_flag")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_class1_get_m_flag
    end interface
    ! end c_class1_get_m_flag

    ! ----------------------------------------
    ! Function:  int getTest
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_class1_get_test
    interface
        function c_class1_get_test(self) &
                result(SHT_rv) &
                bind(C, name="CLA_Class1_get_test")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_class1_get_test
    end interface
    ! end c_class1_get_test

    ! ----------------------------------------
    ! Function:  void setTest
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start c_class1_set_test
    interface
        subroutine c_class1_set_test(self, val) &
                bind(C, name="CLA_Class1_set_test")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: val
        end subroutine c_class1_set_test
    end interface
    ! end c_class1_set_test

    ! ----------------------------------------
    ! Function:  std::string getM_name
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(getter)
    ! Requested: c_getter_string_scalar_cdesc_allocatable
    ! Match:     c_getter_string_scalar_cdesc
    ! start c_class1_get_m_name_bufferify
    interface
        subroutine c_class1_get_m_name_bufferify(self, SHT_rv) &
                bind(C, name="CLA_Class1_get_m_name_bufferify")
            import :: CLA_SHROUD_array, CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(CLA_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_class1_get_m_name_bufferify
    end interface
    ! end c_class1_get_m_name_bufferify

    ! ----------------------------------------
    ! Function:  void setM_name
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  std::string val +intent(in)
    ! Attrs:     +api(buf)+intent(setter)
    ! Exact:     c_setter_string_scalar_buf
    ! start c_class1_set_m_name_bufferify
    interface
        subroutine c_class1_set_m_name_bufferify(self, val, SHT_val_len) &
                bind(C, name="CLA_Class1_set_m_name_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            character(kind=C_CHAR), intent(IN) :: val(*)
            integer(C_INT), value, intent(IN) :: SHT_val_len
        end subroutine c_class1_set_m_name_bufferify
    end interface
    ! end c_class1_set_m_name_bufferify

    ! splicer begin class.Class1.additional_interfaces
    ! splicer end class.Class1.additional_interfaces

    ! ----------------------------------------
    ! Function:  const std::string & getName
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_&_allocatable
    ! Match:     c_function_string_&
    interface
        function c_class2_get_name(self) &
                result(SHT_rv) &
                bind(C, name="CLA_Class2_get_name")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_class2_get_name
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & getName
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    interface
        subroutine c_class2_get_name_bufferify(self, SHT_rv) &
                bind(C, name="CLA_Class2_get_name_bufferify")
            import :: CLA_SHROUD_array, CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            type(CLA_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_class2_get_name_bufferify
    end interface

    ! splicer begin class.Class2.additional_interfaces
    ! splicer end class.Class2.additional_interfaces

    ! ----------------------------------------
    ! Function:  static Singleton & getReference
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_&_capptr
    interface
        function c_singleton_get_reference(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Singleton_get_reference")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_singleton_get_reference
    end interface

    ! splicer begin class.Singleton.additional_interfaces
    ! splicer end class.Singleton.additional_interfaces

    ! ----------------------------------------
    ! Function:  Shape
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    interface
        function c_shape_ctor(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Shape_ctor")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) SHT_prv
        end function c_shape_ctor
    end interface

    ! ----------------------------------------
    ! Function:  int get_ivar
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    interface
        pure function c_shape_get_ivar(self) &
                result(SHT_rv) &
                bind(C, name="CLA_Shape_get_ivar")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_shape_get_ivar
    end interface

    ! splicer begin class.Shape.additional_interfaces
    ! splicer end class.Shape.additional_interfaces

    ! ----------------------------------------
    ! Function:  Circle
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    interface
        function c_circle_ctor(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_Circle_ctor")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) SHT_prv
        end function c_circle_ctor
    end interface

    ! splicer begin class.Circle.additional_interfaces
    ! splicer end class.Circle.additional_interfaces

    ! ----------------------------------------
    ! Function:  Class1::DIRECTION directionFunc
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  Class1::DIRECTION arg +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        function direction_func(arg) &
                result(SHT_rv) &
                bind(C, name="CLA_direction_func")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: arg
            integer(C_INT) :: SHT_rv
        end function direction_func
    end interface

    ! ----------------------------------------
    ! Function:  void passClassByValue
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  Class1 arg +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_shadow_scalar
    interface
        subroutine c_pass_class_by_value(arg) &
                bind(C, name="CLA_pass_class_by_value")
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN), value :: arg
        end subroutine c_pass_class_by_value
    end interface

    ! ----------------------------------------
    ! Function:  int useclass
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Class1 * arg
    ! Attrs:     +intent(in)
    ! Exact:     c_in_shadow_*
    interface
        function c_useclass(arg) &
                result(SHT_rv) &
                bind(C, name="CLA_useclass")
            use iso_c_binding, only : C_INT
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(IN) :: arg
            integer(C_INT) :: SHT_rv
        end function c_useclass
    end interface

    ! ----------------------------------------
    ! Function:  const Class1 * getclass2
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    interface
        function c_getclass2(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_getclass2")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_getclass2
    end interface

    ! ----------------------------------------
    ! Function:  Class1 * getclass3
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    interface
        function c_getclass3(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_getclass3")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_getclass3
    end interface

    ! ----------------------------------------
    ! Function:  const Class1 * getclass2_void
    ! Attrs:     +api(capsule)+intent(function)
    ! Exact:     c_function_shadow_*_capsule
    interface
        subroutine c_getclass2_void(SHT_rv) &
                bind(C, name="CLA_getclass2_void")
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
        end subroutine c_getclass2_void
    end interface

    ! ----------------------------------------
    ! Function:  Class1 * getclass3_void
    ! Attrs:     +api(capsule)+intent(function)
    ! Exact:     c_function_shadow_*_capsule
    interface
        subroutine c_getclass3_void(SHT_rv) &
                bind(C, name="CLA_getclass3_void")
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
        end subroutine c_getclass3_void
    end interface

    ! ----------------------------------------
    ! Function:  const Class1 & getConstClassReference
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_&_capptr
    interface
        function c_get_const_class_reference(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_get_const_class_reference")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_get_const_class_reference
    end interface

    ! ----------------------------------------
    ! Function:  Class1 & getClassReference
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_&_capptr
    interface
        function c_get_class_reference(SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_get_class_reference")
            use iso_c_binding, only : C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_get_class_reference
    end interface

    ! ----------------------------------------
    ! Function:  Class1 getClassCopy
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_scalar_capptr
    ! ----------------------------------------
    ! Argument:  int flag +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        function c_get_class_copy(flag, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="CLA_get_class_copy")
            use iso_c_binding, only : C_INT, C_PTR
            import :: CLA_SHROUD_capsule_data
            implicit none
            integer(C_INT), value, intent(IN) :: flag
            type(CLA_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_get_class_copy
    end interface

    ! ----------------------------------------
    ! Function:  void set_global_flag
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int arg +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        subroutine set_global_flag(arg) &
                bind(C, name="CLA_set_global_flag")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: arg
        end subroutine set_global_flag
    end interface

    ! ----------------------------------------
    ! Function:  int get_global_flag
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    interface
        function get_global_flag() &
                result(SHT_rv) &
                bind(C, name="CLA_get_global_flag")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT) :: SHT_rv
        end function get_global_flag
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & LastFunctionCalled +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_&_copy
    ! Match:     c_function_string_&
    interface
        function c_last_function_called() &
                result(SHT_rv) &
                bind(C, name="CLA_last_function_called")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_last_function_called
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & LastFunctionCalled +len(30)
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_buf_copy
    ! Match:     c_function_string_&_buf
    interface
        subroutine c_last_function_called_bufferify(SHT_rv, SHT_rv_len) &
                bind(C, name="CLA_last_function_called_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_last_function_called_bufferify
    end interface

    interface
        ! splicer begin additional_interfaces
        ! splicer end additional_interfaces
    end interface

    interface circle
        module procedure circle_ctor
    end interface circle

    ! start generic interface class1
    interface class1
        module procedure class1_ctor_default
        module procedure class1_ctor_flag
    end interface class1
    ! end generic interface class1

    interface shape
        module procedure shape_ctor
    end interface shape

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine CLA_SHROUD_copy_string_and_free(context, c_var, c_var_size) &
             bind(c,name="CLA_ShroudCopyStringAndFree")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import CLA_SHROUD_array
            type(CLA_SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine CLA_SHROUD_copy_string_and_free
    end interface

contains

    ! ----------------------------------------
    ! Function:  Class1
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     f_ctor_shadow_scalar_capptr
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    ! start class1_ctor_default
    function class1_ctor_default() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Class1.method.ctor_default
        SHT_prv = c_class1_ctor_default(SHT_rv%cxxmem)
        ! splicer end class.Class1.method.ctor_default
    end function class1_ctor_default
    ! end class1_ctor_default

    ! ----------------------------------------
    ! Function:  Class1
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     f_ctor_shadow_scalar_capptr
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    ! ----------------------------------------
    ! Argument:  int flag +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! start class1_ctor_flag
    function class1_ctor_flag(flag) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        integer(C_INT), value, intent(IN) :: flag
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Class1.method.ctor_flag
        SHT_prv = c_class1_ctor_flag(flag, SHT_rv%cxxmem)
        ! splicer end class.Class1.method.ctor_flag
    end function class1_ctor_flag
    ! end class1_ctor_flag

    ! ----------------------------------------
    ! Function:  ~Class1 +name(delete)
    ! Attrs:     +intent(dtor)
    ! Exact:     f_dtor
    ! Attrs:     +intent(dtor)
    ! Exact:     c_dtor
    ! start class1_delete
    subroutine class1_delete(obj)
        class(class1) :: obj
        ! splicer begin class.Class1.method.delete
        call c_class1_delete(obj%cxxmem)
        ! splicer end class.Class1.method.delete
    end subroutine class1_delete
    ! end class1_delete

    ! ----------------------------------------
    ! Function:  int Method1
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    !>
    !! \brief returns the value of flag member
    !!
    !<
    ! start class1_method1
    function class1_method1(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(class1) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Class1.method.method1
        SHT_rv = c_class1_method1(obj%cxxmem)
        ! splicer end class.Class1.method.method1
    end function class1_method1
    ! end class1_method1

    ! ----------------------------------------
    ! Function:  bool equivalent
    ! Attrs:     +intent(function)
    ! Requested: f_function_bool_scalar
    ! Match:     f_function_bool
    ! Attrs:     +intent(function)
    ! Requested: c_function_bool_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Class1 & obj2
    ! Attrs:     +intent(in)
    ! Requested: f_in_shadow_&
    ! Match:     f_in_shadow
    ! Attrs:     +intent(in)
    ! Exact:     c_in_shadow_&
    !>
    !! \brief Pass in reference to instance
    !!
    !<
    ! start class1_equivalent
    function class1_equivalent(obj, obj2) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(class1) :: obj
        type(class1), intent(IN) :: obj2
        logical :: SHT_rv
        ! splicer begin class.Class1.method.equivalent
        SHT_rv = c_class1_equivalent(obj%cxxmem, obj2%cxxmem)
        ! splicer end class.Class1.method.equivalent
    end function class1_equivalent
    ! end class1_equivalent

    ! Generated by return_this
    ! ----------------------------------------
    ! Function:  void returnThis
    ! Attrs:     +api(capptr)+intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +api(capptr)+intent(subroutine)
    ! Exact:     c_subroutine
    !>
    !! \brief Return pointer to 'this' to allow chaining calls
    !!
    !<
    ! start class1_return_this
    subroutine class1_return_this(obj)
        class(class1) :: obj
        ! splicer begin class.Class1.method.return_this
        call c_class1_return_this(obj%cxxmem)
        ! splicer end class.Class1.method.return_this
    end subroutine class1_return_this
    ! end class1_return_this

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  Class1 * returnThisBuffer
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_*_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    ! ----------------------------------------
    ! Argument:  std::string & name +intent(in)
    ! Attrs:     +intent(in)
    ! Exact:     f_in_string_&_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_&_buf
    ! ----------------------------------------
    ! Argument:  bool flag +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_bool_scalar
    ! Match:     f_in_bool
    ! Attrs:     +intent(in)
    ! Requested: c_in_bool_scalar
    ! Match:     c_default
    !>
    !! \brief Return pointer to 'this' to allow chaining calls
    !!
    !<
    ! start class1_return_this_buffer
    function class1_return_this_buffer(obj, name, flag) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_INT, C_PTR
        class(class1) :: obj
        character(len=*), intent(IN) :: name
        logical, value, intent(IN) :: flag
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Class1.method.return_this_buffer
        integer(C_INT) SHT_name_len
        logical(C_BOOL) SH_flag
        SHT_name_len = len(name, kind=C_INT)
        SH_flag = flag  ! coerce to C_BOOL
        SHT_prv = c_class1_return_this_buffer_bufferify(obj%cxxmem, &
            name, SHT_name_len, SH_flag, SHT_rv%cxxmem)
        ! splicer end class.Class1.method.return_this_buffer
    end function class1_return_this_buffer
    ! end class1_return_this_buffer

    ! ----------------------------------------
    ! Function:  Class1 * getclass3
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_*_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    !>
    !! \brief Test const method
    !!
    !<
    ! start class1_getclass3
    function class1_getclass3(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        class(class1) :: obj
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Class1.method.getclass3
        SHT_prv = c_class1_getclass3(obj%cxxmem, SHT_rv%cxxmem)
        ! splicer end class.Class1.method.getclass3
    end function class1_getclass3
    ! end class1_getclass3

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string & getName
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_&_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    !>
    !! \brief test helper
    !!
    !<
    ! start class1_get_name
    function class1_get_name(obj) &
            result(SHT_rv)
        class(class1) :: obj
        character(len=:), allocatable :: SHT_rv
        ! splicer begin class.Class1.method.get_name
        type(CLA_SHROUD_array) :: SHT_rv_cdesc
        call c_class1_get_name_bufferify(obj%cxxmem, SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call CLA_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end class.Class1.method.get_name
    end function class1_get_name
    ! end class1_get_name

    ! ----------------------------------------
    ! Function:  DIRECTION directionFunc
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  DIRECTION arg +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! start class1_direction_func
    function class1_direction_func(obj, arg) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(class1) :: obj
        integer(C_INT), value, intent(IN) :: arg
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Class1.method.direction_func
        SHT_rv = c_class1_direction_func(obj%cxxmem, arg)
        ! splicer end class.Class1.method.direction_func
    end function class1_direction_func
    ! end class1_direction_func

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getM_flag
    ! Attrs:     +intent(getter)
    ! Requested: f_getter_native_scalar
    ! Match:     f_getter
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start class1_get_m_flag
    function class1_get_m_flag(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(class1) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Class1.method.get_m_flag
        SHT_rv = c_class1_get_m_flag(obj%cxxmem)
        ! splicer end class.Class1.method.get_m_flag
    end function class1_get_m_flag
    ! end class1_get_m_flag

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getTest
    ! Attrs:     +intent(getter)
    ! Requested: f_getter_native_scalar
    ! Match:     f_getter
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start class1_get_test
    function class1_get_test(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(class1) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Class1.method.get_test
        SHT_rv = c_class1_get_test(obj%cxxmem)
        ! splicer end class.Class1.method.get_test
    end function class1_get_test
    ! end class1_get_test

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void setTest
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Requested: f_setter_native_scalar
    ! Match:     f_setter_native
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start class1_set_test
    subroutine class1_set_test(obj, val)
        use iso_c_binding, only : C_INT
        class(class1) :: obj
        integer(C_INT), value, intent(IN) :: val
        ! splicer begin class.Class1.method.set_test
        call c_class1_set_test(obj%cxxmem, val)
        ! splicer end class.Class1.method.set_test
    end subroutine class1_set_test
    ! end class1_set_test

    ! Generated by getter/setter - arg_to_buffer
    ! ----------------------------------------
    ! Function:  std::string getM_name
    ! Attrs:     +deref(allocatable)+intent(getter)
    ! Exact:     f_getter_string_scalar_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(getter)
    ! Requested: c_getter_string_scalar_cdesc_allocatable
    ! Match:     c_getter_string_scalar_cdesc
    ! start class1_get_m_name
    function class1_get_m_name(obj) &
            result(SHT_rv)
        class(class1) :: obj
        character(len=:), allocatable :: SHT_rv
        ! splicer begin class.Class1.method.get_m_name
        type(CLA_SHROUD_array) :: SHT_rv_cdesc
        call c_class1_get_m_name_bufferify(obj%cxxmem, SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call CLA_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end class.Class1.method.get_m_name
    end function class1_get_m_name
    ! end class1_get_m_name

    ! Generated by getter/setter - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void setM_name
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  std::string val +intent(in)
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter_string_scalar_buf
    ! Attrs:     +api(buf)+intent(setter)
    ! Exact:     c_setter_string_scalar_buf
    ! start class1_set_m_name
    subroutine class1_set_m_name(obj, val)
        use iso_c_binding, only : C_INT
        class(class1) :: obj
        character(len=*), intent(IN) :: val
        ! splicer begin class.Class1.method.set_m_name
        integer(C_INT) SHT_val_len
        SHT_val_len = len(val, kind=C_INT)
        call c_class1_set_m_name_bufferify(obj%cxxmem, val, SHT_val_len)
        ! splicer end class.Class1.method.set_m_name
    end subroutine class1_set_m_name
    ! end class1_set_m_name

    ! Return pointer to C++ memory.
    function class1_get_instance(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(class1), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function class1_get_instance

    subroutine class1_set_instance(obj, cxxmem)
        use iso_c_binding, only: C_PTR
        class(class1), intent(INOUT) :: obj
        type(C_PTR), intent(IN) :: cxxmem
        obj%cxxmem%addr = cxxmem
        obj%cxxmem%idtor = 0
    end subroutine class1_set_instance

    function class1_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(class1), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function class1_associated

    ! splicer begin class.Class1.additional_functions
    ! splicer end class.Class1.additional_functions

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string & getName
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_&_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    !>
    !! \brief test helper
    !!
    !<
    function class2_get_name(obj) &
            result(SHT_rv)
        class(class2) :: obj
        character(len=:), allocatable :: SHT_rv
        ! splicer begin class.Class2.method.get_name
        type(CLA_SHROUD_array) :: SHT_rv_cdesc
        call c_class2_get_name_bufferify(obj%cxxmem, SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call CLA_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end class.Class2.method.get_name
    end function class2_get_name

    ! Return pointer to C++ memory.
    function class2_get_instance(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(class2), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function class2_get_instance

    subroutine class2_set_instance(obj, cxxmem)
        use iso_c_binding, only: C_PTR
        class(class2), intent(INOUT) :: obj
        type(C_PTR), intent(IN) :: cxxmem
        obj%cxxmem%addr = cxxmem
        obj%cxxmem%idtor = 0
    end subroutine class2_set_instance

    function class2_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(class2), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function class2_associated

    ! splicer begin class.Class2.additional_functions
    ! splicer end class.Class2.additional_functions

    ! ----------------------------------------
    ! Function:  static Singleton & getReference
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_&_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_&_capptr
    function singleton_get_reference() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(singleton) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Singleton.method.get_reference
        SHT_prv = c_singleton_get_reference(SHT_rv%cxxmem)
        ! splicer end class.Singleton.method.get_reference
    end function singleton_get_reference

    ! Return pointer to C++ memory.
    function singleton_get_instance(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(singleton), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function singleton_get_instance

    subroutine singleton_set_instance(obj, cxxmem)
        use iso_c_binding, only: C_PTR
        class(singleton), intent(INOUT) :: obj
        type(C_PTR), intent(IN) :: cxxmem
        obj%cxxmem%addr = cxxmem
        obj%cxxmem%idtor = 0
    end subroutine singleton_set_instance

    function singleton_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(singleton), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function singleton_associated

    ! splicer begin class.Singleton.additional_functions
    ! splicer end class.Singleton.additional_functions

    ! ----------------------------------------
    ! Function:  Shape
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     f_ctor_shadow_scalar_capptr
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    function shape_ctor() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(shape) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Shape.method.ctor
        SHT_prv = c_shape_ctor(SHT_rv%cxxmem)
        ! splicer end class.Shape.method.ctor
    end function shape_ctor

    ! ----------------------------------------
    ! Function:  int get_ivar
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    function shape_get_ivar(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(shape) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Shape.method.get_ivar
        SHT_rv = c_shape_get_ivar(obj%cxxmem)
        ! splicer end class.Shape.method.get_ivar
    end function shape_get_ivar

    ! Return pointer to C++ memory.
    function shape_get_instance(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(shape), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function shape_get_instance

    subroutine shape_set_instance(obj, cxxmem)
        use iso_c_binding, only: C_PTR
        class(shape), intent(INOUT) :: obj
        type(C_PTR), intent(IN) :: cxxmem
        obj%cxxmem%addr = cxxmem
        obj%cxxmem%idtor = 0
    end subroutine shape_set_instance

    function shape_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(shape), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function shape_associated

    ! splicer begin class.Shape.additional_functions
    ! splicer end class.Shape.additional_functions

    ! ----------------------------------------
    ! Function:  Circle
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     f_ctor_shadow_scalar_capptr
    ! Attrs:     +api(capptr)+intent(ctor)
    ! Exact:     c_ctor_shadow_scalar_capptr
    function circle_ctor() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(circle) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin class.Circle.method.ctor
        SHT_prv = c_circle_ctor(SHT_rv%cxxmem)
        ! splicer end class.Circle.method.ctor
    end function circle_ctor

    ! splicer begin class.Circle.additional_functions
    ! splicer end class.Circle.additional_functions

    ! ----------------------------------------
    ! Function:  void passClassByValue
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  Class1 arg +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_shadow_scalar
    ! Match:     f_in_shadow
    ! Attrs:     +intent(in)
    ! Exact:     c_in_shadow_scalar
    !>
    !! \brief Pass arguments to a function.
    !!
    !<
    subroutine pass_class_by_value(arg)
        type(class1), intent(IN) :: arg
        ! splicer begin function.pass_class_by_value
        call c_pass_class_by_value(arg%cxxmem)
        ! splicer end function.pass_class_by_value
    end subroutine pass_class_by_value

    ! ----------------------------------------
    ! Function:  int useclass
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Class1 * arg
    ! Attrs:     +intent(in)
    ! Requested: f_in_shadow_*
    ! Match:     f_in_shadow
    ! Attrs:     +intent(in)
    ! Exact:     c_in_shadow_*
    function useclass(arg) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        type(class1), intent(IN) :: arg
        integer(C_INT) :: SHT_rv
        ! splicer begin function.useclass
        SHT_rv = c_useclass(arg%cxxmem)
        ! splicer end function.useclass
    end function useclass

    ! ----------------------------------------
    ! Function:  const Class1 * getclass2
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_*_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    !>
    !! \brief Return const class pointer
    !!
    !<
    function getclass2() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin function.getclass2
        SHT_prv = c_getclass2(SHT_rv%cxxmem)
        ! splicer end function.getclass2
    end function getclass2

    ! ----------------------------------------
    ! Function:  Class1 * getclass3
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_*_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_*_capptr
    !>
    !! \brief Return class pointer
    !!
    !<
    function getclass3() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin function.getclass3
        SHT_prv = c_getclass3(SHT_rv%cxxmem)
        ! splicer end function.getclass3
    end function getclass3

    ! ----------------------------------------
    ! Function:  const Class1 * getclass2_void
    ! Attrs:     +api(capsule)+intent(function)
    ! Exact:     f_function_shadow_*_capsule
    ! Attrs:     +api(capsule)+intent(function)
    ! Exact:     c_function_shadow_*_capsule
    !>
    !! \brief C wrapper will return void
    !!
    !<
    function getclass2_void() &
            result(SHT_rv)
        type(class1) :: SHT_rv
        ! splicer begin function.getclass2_void
        call c_getclass2_void(SHT_rv%cxxmem)
        ! splicer end function.getclass2_void
    end function getclass2_void

    ! ----------------------------------------
    ! Function:  Class1 * getclass3_void
    ! Attrs:     +api(capsule)+intent(function)
    ! Exact:     f_function_shadow_*_capsule
    ! Attrs:     +api(capsule)+intent(function)
    ! Exact:     c_function_shadow_*_capsule
    !>
    !! \brief C wrapper will return void
    !!
    !<
    function getclass3_void() &
            result(SHT_rv)
        type(class1) :: SHT_rv
        ! splicer begin function.getclass3_void
        call c_getclass3_void(SHT_rv%cxxmem)
        ! splicer end function.getclass3_void
    end function getclass3_void

    ! ----------------------------------------
    ! Function:  const Class1 & getConstClassReference
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_&_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_&_capptr
    function get_const_class_reference() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin function.get_const_class_reference
        SHT_prv = c_get_const_class_reference(SHT_rv%cxxmem)
        ! splicer end function.get_const_class_reference
    end function get_const_class_reference

    ! ----------------------------------------
    ! Function:  Class1 & getClassReference
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_&_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_&_capptr
    function get_class_reference() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin function.get_class_reference
        SHT_prv = c_get_class_reference(SHT_rv%cxxmem)
        ! splicer end function.get_class_reference
    end function get_class_reference

    ! ----------------------------------------
    ! Function:  Class1 getClassCopy
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     f_function_shadow_scalar_capptr
    ! Attrs:     +api(capptr)+intent(function)
    ! Exact:     c_function_shadow_scalar_capptr
    ! ----------------------------------------
    ! Argument:  int flag +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    !>
    !! \brief Return Class1 instance by value, uses copy constructor
    !!
    !<
    function get_class_copy(flag) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        integer(C_INT), value, intent(IN) :: flag
        type(class1) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin function.get_class_copy
        SHT_prv = c_get_class_copy(flag, SHT_rv%cxxmem)
        ! splicer end function.get_class_copy
    end function get_class_copy

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string & LastFunctionCalled +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_&_buf_copy
    ! Match:     f_function_string_&_buf
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_buf_copy
    ! Match:     c_function_string_&_buf
    function last_function_called() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.last_function_called
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_last_function_called_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.last_function_called
    end function last_function_called

    ! splicer begin additional_functions
    ! splicer end additional_functions

    function class1_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(class1), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function class1_eq

    function class1_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(class1), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function class1_ne

    function class2_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(class2), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function class2_eq

    function class2_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(class2), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function class2_ne

    function singleton_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(singleton), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function singleton_eq

    function singleton_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(singleton), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function singleton_ne

    function shape_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(shape), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function shape_eq

    function shape_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(shape), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function shape_ne

    function circle_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(circle), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function circle_eq

    function circle_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(circle), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function circle_ne

end module classes_mod

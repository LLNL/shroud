// luaUserLibrarymodule.cpp
// This file is generated by Shroud nowrite-version. Do not edit.
// Copyright (c) 2017-2023, Lawrence Livermore National Security, LLC and
// other Shroud Project Developers.
// See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)
//

// shroud
#include "luaUserLibrarymodule.hpp"
#ifdef __cplusplus
extern "C" {
#endif
#include "lauxlib.h"
#ifdef __cplusplus
}
#endif

// splicer begin include
// splicer end include
// splicer begin C_definition
// splicer end C_definition

// ExClass1(void)
// ExClass1(const string * name)
// ----------------------------------------
// Function:  ExClass1
// Attrs:     +api(capptr)+intent(ctor)
// Requested: lua_ctor_scalar
// Match:     lua_ctor
// ----------------------------------------
// Function:  ExClass1
// Attrs:     +api(capptr)+intent(ctor)
// Requested: lua_ctor_scalar
// Match:     lua_ctor
// ----------------------------------------
// Argument:  const string * name
// Attrs:     +intent(in)
// Exact:     lua_in_string_*
/**
 * \brief constructor
 *
 * longer description
 * usually multiple lines
 *
 * \return return new instance
 */
static int l_example_nested_ExClass1_ctor(lua_State *L)
{
    // splicer begin class.ExClass1.method.ctor
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    switch (SH_nargs) {
    case 0:
        {
            l_ExClass1_Type * SH_this =
                (l_ExClass1_Type *) lua_newuserdata(L, sizeof(*SH_this));
            SH_this->self = new example::nested::ExClass1();
            /* Add the metatable to the stack. */
            luaL_getmetatable(L, "ExClass1.metatable");
            /* Set the metatable on the userdata. */
            lua_setmetatable(L, -2);
            SH_nresult = 1;
        }
        break;
    case 1:
        if (SH_itype1 == LUA_TSTRING) {
            const char * name = lua_tostring(L, 1);
            l_ExClass1_Type * SH_this =
                (l_ExClass1_Type *) lua_newuserdata(L, sizeof(*SH_this));
            SH_this->self = new example::nested::ExClass1(name);
            /* Add the metatable to the stack. */
            luaL_getmetatable(L, "ExClass1.metatable");
            /* Set the metatable on the userdata. */
            lua_setmetatable(L, -2);
            SH_nresult = 1;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end class.ExClass1.method.ctor
}

// ~ExClass1(void)
// ----------------------------------------
// Function:  ~ExClass1
// Attrs:     +intent(dtor)
// Requested: lua_dtor_scalar
// Match:     lua_dtor
/**
 * \brief destructor
 *
 * longer description joined with previous line
 */
static int l_example_nested_ExClass1_dtor(lua_State *L)
{
    // splicer begin class.ExClass1.method.__gc
    l_ExClass1_Type * SH_this = (l_ExClass1_Type *) luaL_checkudata(
        L, 1, "ExClass1.metatable");
    delete SH_this->self;
    SH_this->self = NULL;
    return 0;
    // splicer end class.ExClass1.method.__gc
}

// int incrementCount(int incr +value)
// ----------------------------------------
// Function:  int incrementCount
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
// ----------------------------------------
// Argument:  int incr +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_ExClass1_incrementCount(lua_State *L)
{
    // splicer begin class.ExClass1.method.incrementCount
    int incr = lua_tointeger(L, 1);
    l_ExClass1_Type * SH_this = (l_ExClass1_Type *) luaL_checkudata(
        L, 1, "ExClass1.metatable");
    int SHCXX_rv = SH_this->self->incrementCount(incr);
    lua_pushinteger(L, SHCXX_rv);
    return 1;
    // splicer end class.ExClass1.method.incrementCount
}

// const string & getNameErrorCheck(void) const
// ----------------------------------------
// Function:  const string & getNameErrorCheck
// Attrs:     +deref(allocatable)+intent(function)
// Exact:     lua_function_string_&
static int l_example_nested_ExClass1_getNameErrorCheck(lua_State *L)
{
    // splicer begin class.ExClass1.method.getNameErrorCheck
    l_ExClass1_Type * SH_this = (l_ExClass1_Type *) luaL_checkudata(
        L, 1, "ExClass1.metatable");
    const std::string & SHCXX_rv = SH_this->self->getNameErrorCheck();
    lua_pushstring(L, SHCXX_rv.c_str());
    return 1;
    // splicer end class.ExClass1.method.getNameErrorCheck
}

// const string & getNameArg(void) const
// ----------------------------------------
// Function:  const string & getNameArg
// Attrs:     +intent(function)
// Exact:     lua_function_string_&
static int l_example_nested_ExClass1_getNameArg(lua_State *L)
{
    // splicer begin class.ExClass1.method.getNameArg
    l_ExClass1_Type * SH_this = (l_ExClass1_Type *) luaL_checkudata(
        L, 1, "ExClass1.metatable");
    const std::string & SHCXX_rv = SH_this->self->getNameArg();
    lua_pushstring(L, SHCXX_rv.c_str());
    return 1;
    // splicer end class.ExClass1.method.getNameArg
}

// int getValue(int value +value)
// long getValue(long value +value)
// ----------------------------------------
// Function:  int getValue
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
// ----------------------------------------
// Argument:  int value +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Function:  long getValue
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
// ----------------------------------------
// Argument:  long value +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_ExClass1_getValue(lua_State *L)
{
    // splicer begin class.ExClass1.method.getValue
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    switch (SH_nargs) {
    case 1:
        if (SH_itype1 == LUA_TNUMBER) {
            int value = lua_tointeger(L, 1);
            l_ExClass1_Type * SH_this = (l_ExClass1_Type *)
                luaL_checkudata(L, 1, "ExClass1.metatable");
            int SHCXX_rv = SH_this->self->getValue(value);
            lua_pushinteger(L, SHCXX_rv);
            SH_nresult = 1;
        }
        else if (SH_itype1 == LUA_TNUMBER) {
            long value = lua_tointeger(L, 1);
            l_ExClass1_Type * SH_this = (l_ExClass1_Type *)
                luaL_checkudata(L, 1, "ExClass1.metatable");
            long SHCXX_rv = SH_this->self->getValue(value);
            lua_pushinteger(L, SHCXX_rv);
            SH_nresult = 1;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end class.ExClass1.method.getValue
}

// bool hasAddr(bool in +value)
// ----------------------------------------
// Function:  bool hasAddr
// Attrs:     +intent(function)
// Exact:     lua_function_bool_scalar
// ----------------------------------------
// Argument:  bool in +value
// Attrs:     +intent(in)
// Exact:     lua_in_bool_scalar
static int l_example_nested_ExClass1_hasAddr(lua_State *L)
{
    // splicer begin class.ExClass1.method.hasAddr
    bool in = lua_toboolean(L, 1);
    l_ExClass1_Type * SH_this = (l_ExClass1_Type *) luaL_checkudata(
        L, 1, "ExClass1.metatable");
    bool SHCXX_rv = SH_this->self->hasAddr(in);
    lua_pushboolean(L, SHCXX_rv);
    return 1;
    // splicer end class.ExClass1.method.hasAddr
}

// void SplicerSpecial(void)
// ----------------------------------------
// Function:  void SplicerSpecial
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
static int l_example_nested_ExClass1_SplicerSpecial(lua_State *L)
{
    // splicer begin class.ExClass1.method.SplicerSpecial
    l_ExClass1_Type * SH_this = (l_ExClass1_Type *) luaL_checkudata(
        L, 1, "ExClass1.metatable");
    SH_this->self->SplicerSpecial();
    return 0;
    // splicer end class.ExClass1.method.SplicerSpecial
}

// splicer begin class.ExClass1.additional_functions
// splicer end class.ExClass1.additional_functions

static const struct luaL_Reg l_ExClass1_Reg [] = {
    {"__gc", l_example_nested_ExClass1_dtor},
    {"incrementCount", l_example_nested_ExClass1_incrementCount},
    {"getNameErrorCheck", l_example_nested_ExClass1_getNameErrorCheck},
    {"getNameArg", l_example_nested_ExClass1_getNameArg},
    {"getValue", l_example_nested_ExClass1_getValue},
    {"hasAddr", l_example_nested_ExClass1_hasAddr},
    {"SplicerSpecial", l_example_nested_ExClass1_SplicerSpecial},
    // splicer begin class.ExClass1.register
    // splicer end class.ExClass1.register
    {NULL, NULL}   /*sentinel */
};

// ExClass2(const string * name +len_trim(trim_name))
// ----------------------------------------
// Function:  ExClass2
// Attrs:     +api(capptr)+intent(ctor)
// Requested: lua_ctor_scalar
// Match:     lua_ctor
// ----------------------------------------
// Argument:  const string * name +len_trim(trim_name)
// Attrs:     +intent(in)
// Exact:     lua_in_string_*
/**
 * \brief constructor
 *
 */
static int l_example_nested_ExClass2_ctor(lua_State *L)
{
    // splicer begin class.ExClass2.method.ctor
    const char * name = lua_tostring(L, 1);
    l_ExClass2_Type * SH_this =
        (l_ExClass2_Type *) lua_newuserdata(L, sizeof(*SH_this));
    SH_this->self = new example::nested::ExClass2(name);
    /* Add the metatable to the stack. */
    luaL_getmetatable(L, "ExClass2.metatable");
    /* Set the metatable on the userdata. */
    lua_setmetatable(L, -2);
    return 1;
    // splicer end class.ExClass2.method.ctor
}

// ~ExClass2(void)
// ----------------------------------------
// Function:  ~ExClass2
// Attrs:     +intent(dtor)
// Requested: lua_dtor_scalar
// Match:     lua_dtor
/**
 * \brief destructor
 *
 */
static int l_example_nested_ExClass2_dtor(lua_State *L)
{
    // splicer begin class.ExClass2.method.__gc
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    delete SH_this->self;
    SH_this->self = NULL;
    return 0;
    // splicer end class.ExClass2.method.__gc
}

// const string & getName(void) const +len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
// ----------------------------------------
// Function:  const string & getName +len(aa_exclass2_get_name_length({F_this}%{F_derived_member}))
// Attrs:     +deref(copy)+intent(function)
// Exact:     lua_function_string_&
static int l_example_nested_ExClass2_getName(lua_State *L)
{
    // splicer begin class.ExClass2.method.getName
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    const std::string & SHCXX_rv = SH_this->self->getName();
    lua_pushstring(L, SHCXX_rv.c_str());
    return 1;
    // splicer end class.ExClass2.method.getName
}

// const string & getName2(void)
// ----------------------------------------
// Function:  const string & getName2
// Attrs:     +deref(allocatable)+intent(function)
// Exact:     lua_function_string_&
static int l_example_nested_ExClass2_getName2(lua_State *L)
{
    // splicer begin class.ExClass2.method.getName2
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    const std::string & SHCXX_rv = SH_this->self->getName2();
    lua_pushstring(L, SHCXX_rv.c_str());
    return 1;
    // splicer end class.ExClass2.method.getName2
}

// string & getName3(void) const
// ----------------------------------------
// Function:  string & getName3
// Attrs:     +deref(allocatable)+intent(function)
// Exact:     lua_function_string_&
static int l_example_nested_ExClass2_getName3(lua_State *L)
{
    // splicer begin class.ExClass2.method.getName3
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    std::string & SHCXX_rv = SH_this->self->getName3();
    lua_pushstring(L, SHCXX_rv.c_str());
    return 1;
    // splicer end class.ExClass2.method.getName3
}

// string & getName4(void)
// ----------------------------------------
// Function:  string & getName4
// Attrs:     +deref(allocatable)+intent(function)
// Exact:     lua_function_string_&
static int l_example_nested_ExClass2_getName4(lua_State *L)
{
    // splicer begin class.ExClass2.method.getName4
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    std::string & SHCXX_rv = SH_this->self->getName4();
    lua_pushstring(L, SHCXX_rv.c_str());
    return 1;
    // splicer end class.ExClass2.method.getName4
}

// int GetNameLength(void) const
// ----------------------------------------
// Function:  int GetNameLength
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
/**
 * \brief helper function for Fortran
 *
 */
static int l_example_nested_ExClass2_GetNameLength(lua_State *L)
{
    // splicer begin class.ExClass2.method.GetNameLength
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    int SHCXX_rv = SH_this->self->GetNameLength();
    lua_pushinteger(L, SHCXX_rv);
    return 1;
    // splicer end class.ExClass2.method.GetNameLength
}

// ExClass1 * get_class1(const ExClass1 * in)
// ----------------------------------------
// Function:  ExClass1 * get_class1
// Attrs:     +api(capptr)+intent(function)
// Exact:     lua_function_shadow_*
// ----------------------------------------
// Argument:  const ExClass1 * in
// Attrs:     +intent(in)
// Exact:     lua_in_shadow_*
static int l_example_nested_ExClass2_get_class1(lua_State *L)
{
    // splicer begin class.ExClass2.method.get_class1
    example::nested::ExClass1 * in =
        static_cast<example::nested::ExClass1 *>((l_ExClass2_Type *)
        luaL_checkudata(L, 1, "ExClass2.metatable")->addr);
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    example::nested::ExClass1 * SHCXX_rv =
        SH_this->self->get_class1(in);
    PUSH;
    return 1;
    // splicer end class.ExClass2.method.get_class1
}

// void * declare(TypeID type +value, SidreLength len=1 +value)
// ----------------------------------------
// Function:  void * declare
// Attrs:     +intent(function)
// Exact:     lua_function_void_*
// ----------------------------------------
// Argument:  TypeID type +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Function:  void * declare
// Attrs:     +intent(function)
// Exact:     lua_function_void_*
// ----------------------------------------
// Argument:  TypeID type +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  SidreLength len=1 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_ExClass2_declare(lua_State *L)
{
    // splicer begin class.ExClass2.method.declare
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    int SH_itype2 = lua_type(L, 2);
    switch (SH_nargs) {
    case 1:
        if (SH_itype1 == LUA_TNUMBER) {
            TypeID type = getTypeID(lua_tointeger(L, 1));
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            void * SHCXX_rv = SH_this->self->declare(type);
            SH_nresult = 1;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    case 2:
        if (SH_itype1 == LUA_TNUMBER &&
            SH_itype2 == LUA_TNUMBER) {
            TypeID type = getTypeID(lua_tointeger(L, 1));
            SidreLength len = lua_tointeger(L, 2);
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            void * SHCXX_rv = SH_this->self->declare(type, len);
            SH_nresult = 1;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end class.ExClass2.method.declare
}

// void destroyall(void)
// ----------------------------------------
// Function:  void destroyall
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
static int l_example_nested_ExClass2_destroyall(lua_State *L)
{
    // splicer begin class.ExClass2.method.destroyall
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    SH_this->self->destroyall();
    return 0;
    // splicer end class.ExClass2.method.destroyall
}

// TypeID getTypeID(void) const
// ----------------------------------------
// Function:  TypeID getTypeID
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
static int l_example_nested_ExClass2_getTypeID(lua_State *L)
{
    // splicer begin class.ExClass2.method.getTypeID
    l_ExClass2_Type * SH_this = (l_ExClass2_Type *) luaL_checkudata(
        L, 1, "ExClass2.metatable");
    TypeID SHCXX_rv = SH_this->self->getTypeID();
    lua_pushinteger(L, static_cast<int>(SHCXX_rv));
    return 1;
    // splicer end class.ExClass2.method.getTypeID
}

// void setValue(int value +value)
// void setValue(long value +value)
// void setValue(float value +value)
// void setValue(double value +value)
// ----------------------------------------
// Function:  void setValue
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  int value +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Function:  void setValue
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  long value +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Function:  void setValue
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  float value +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Function:  void setValue
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  double value +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_ExClass2_setValue(lua_State *L)
{
    // splicer begin class.ExClass2.method.setValue
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    switch (SH_nargs) {
    case 1:
        if (SH_itype1 == LUA_TNUMBER) {
            int value = lua_tointeger(L, 1);
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            SH_this->self->setValue(value);
            SH_nresult = 0;
        }
        else if (SH_itype1 == LUA_TNUMBER) {
            long value = lua_tointeger(L, 1);
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            SH_this->self->setValue(value);
            SH_nresult = 0;
        }
        else if (SH_itype1 == LUA_TNUMBER) {
            float value = lua_tonumber(L, 1);
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            SH_this->self->setValue(value);
            SH_nresult = 0;
        }
        else if (SH_itype1 == LUA_TNUMBER) {
            double value = lua_tonumber(L, 1);
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            SH_this->self->setValue(value);
            SH_nresult = 0;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end class.ExClass2.method.setValue
}

// int getValue(void)
// double getValue(void)
// ----------------------------------------
// Function:  int getValue
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
// ----------------------------------------
// Function:  double getValue
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
static int l_example_nested_ExClass2_getValue(lua_State *L)
{
    // splicer begin class.ExClass2.method.getValue
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    switch (SH_nargs) {
    case 0:
        {
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            int SHCXX_rv = SH_this->self->getValue();
            lua_pushinteger(L, SHCXX_rv);
            SH_nresult = 1;
        }
        {
            l_ExClass2_Type * SH_this = (l_ExClass2_Type *)
                luaL_checkudata(L, 1, "ExClass2.metatable");
            double SHCXX_rv = SH_this->self->getValue();
            lua_pushnumber(L, SHCXX_rv);
            SH_nresult = 1;
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end class.ExClass2.method.getValue
}

// splicer begin class.ExClass2.additional_functions
// splicer end class.ExClass2.additional_functions

static const struct luaL_Reg l_ExClass2_Reg [] = {
    {"__gc", l_example_nested_ExClass2_dtor},
    {"getName", l_example_nested_ExClass2_getName},
    {"getName2", l_example_nested_ExClass2_getName2},
    {"getName3", l_example_nested_ExClass2_getName3},
    {"getName4", l_example_nested_ExClass2_getName4},
    {"GetNameLength", l_example_nested_ExClass2_GetNameLength},
    {"get_class1", l_example_nested_ExClass2_get_class1},
    {"declare", l_example_nested_ExClass2_declare},
    {"destroyall", l_example_nested_ExClass2_destroyall},
    {"getTypeID", l_example_nested_ExClass2_getTypeID},
    {"setValue", l_example_nested_ExClass2_setValue},
    {"getValue", l_example_nested_ExClass2_getValue},
    // splicer begin class.ExClass2.register
    // splicer end class.ExClass2.register
    {NULL, NULL}   /*sentinel */
};

// void local_function1(void)
// ----------------------------------------
// Function:  void local_function1
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
static int l_example_nested_local_function1(lua_State *)
{
    // splicer begin function.local_function1
    example::nested::local_function1();
    return 0;
    // splicer end function.local_function1
}

// bool isNameValid(const std::string & name)
// ----------------------------------------
// Function:  bool isNameValid
// Attrs:     +intent(function)
// Exact:     lua_function_bool_scalar
// ----------------------------------------
// Argument:  const std::string & name
// Attrs:     +intent(in)
// Exact:     lua_in_string_&
static int l_example_nested_isNameValid(lua_State *L)
{
    // splicer begin function.isNameValid
    const char * name = lua_tostring(L, 1);
    bool SHCXX_rv = example::nested::isNameValid(name);
    lua_pushboolean(L, SHCXX_rv);
    return 1;
    // splicer end function.isNameValid
}

// bool isInitialized(void)
// ----------------------------------------
// Function:  bool isInitialized
// Attrs:     +intent(function)
// Exact:     lua_function_bool_scalar
static int l_example_nested_isInitialized(lua_State *L)
{
    // splicer begin function.isInitialized
    bool SHCXX_rv = example::nested::isInitialized();
    lua_pushboolean(L, SHCXX_rv);
    return 1;
    // splicer end function.isInitialized
}

// void test_names(const std::string & name)
// void test_names(const std::string & name, int flag +value)
// ----------------------------------------
// Function:  void test_names
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  const std::string & name
// Attrs:     +intent(in)
// Exact:     lua_in_string_&
// ----------------------------------------
// Function:  void test_names
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  const std::string & name
// Attrs:     +intent(in)
// Exact:     lua_in_string_&
// ----------------------------------------
// Argument:  int flag +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_test_names(lua_State *L)
{
    // splicer begin function.test_names
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    int SH_itype2 = lua_type(L, 2);
    switch (SH_nargs) {
    case 1:
        if (SH_itype1 == LUA_TSTRING) {
            const char * name = lua_tostring(L, 1);
            example::nested::test_names(name);
            SH_nresult = 0;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    case 2:
        if (SH_itype1 == LUA_TSTRING &&
            SH_itype2 == LUA_TNUMBER) {
            const char * name = lua_tostring(L, 1);
            int flag = lua_tointeger(L, 2);
            example::nested::test_names(name, flag);
            SH_nresult = 0;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end function.test_names
}

// void testoptional(int i=1 +value, long j=2 +value)
// ----------------------------------------
// Function:  void testoptional
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Function:  void testoptional
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  int i=1 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Function:  void testoptional
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  int i=1 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  long j=2 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_testoptional(lua_State *L)
{
    // splicer begin function.testoptional
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    int SH_itype2 = lua_type(L, 2);
    switch (SH_nargs) {
    case 0:
        {
            example::nested::testoptional();
            SH_nresult = 0;
        }
        break;
    case 1:
        if (SH_itype1 == LUA_TNUMBER) {
            int i = lua_tointeger(L, 1);
            example::nested::testoptional(i);
            SH_nresult = 0;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    case 2:
        if (SH_itype1 == LUA_TNUMBER &&
            SH_itype2 == LUA_TNUMBER) {
            int i = lua_tointeger(L, 1);
            long j = lua_tointeger(L, 2);
            example::nested::testoptional(i, j);
            SH_nresult = 0;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end function.testoptional
}

// size_t test_size_t(void)
// ----------------------------------------
// Function:  size_t test_size_t
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
static int l_example_nested_test_size_t(lua_State *L)
{
    // splicer begin function.test_size_t
    size_t SHCXX_rv = example::nested::test_size_t();
    lua_pushinteger(L, SHCXX_rv);
    return 1;
    // splicer end function.test_size_t
}

// void testmpi(MPI_Comm comm +value)
// void testmpi(void)
// ----------------------------------------
// Function:  void testmpi
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Function:  void testmpi
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  MPI_Comm comm +value
// Attrs:     +intent(in)
// Requested: lua_in_unknown_scalar
// Match:     lua_default
static int l_example_nested_testmpi(lua_State *L)
{
    // splicer begin function.testmpi
    int SH_nresult = 0;
    int SH_nargs = lua_gettop(L);
    int SH_itype1 = lua_type(L, 1);
    switch (SH_nargs) {
    case 0:
        {
            example::nested::testmpi();
            SH_nresult = 0;
        }
        break;
    case 1:
        if (SH_itype1 == LUA_TNONE) {
            example::nested::testmpi(comm);
            SH_nresult = 0;
        }
        else {
            luaL_error(L, "error with arguments");
        }
        break;
    default:
        luaL_error(L, "error with arguments");
        break;
    }
    return SH_nresult;
    // splicer end function.testmpi
}

// void FuncPtr1(void ( * get)(void) +value)
// ----------------------------------------
// Function:  void FuncPtr1
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  void ( * get)(void) +value
// Attrs:     +intent(in)
// Requested: lua_in_void_scalar
// Match:     lua_default
/**
 * \brief subroutine
 *
 */
static int l_example_nested_FuncPtr1(lua_State *)
{
    // splicer begin function.FuncPtr1
    example::nested::FuncPtr1(get);
    return 0;
    // splicer end function.FuncPtr1
}

// void FuncPtr2(double * ( * get)(void))
// ----------------------------------------
// Function:  void FuncPtr2
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  double * ( * get)(void)
// Attrs:     +intent(in)
// Requested: lua_in_native_*
// Match:     lua_default
/**
 * \brief return a pointer
 *
 */
static int l_example_nested_FuncPtr2(lua_State *)
{
    // splicer begin function.FuncPtr2
    example::nested::FuncPtr2(get);
    return 0;
    // splicer end function.FuncPtr2
}

// void FuncPtr3(double ( * get)(int i +value, int +value) +value)
// ----------------------------------------
// Function:  void FuncPtr3
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  double ( * get)(int i +value, int +value) +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
/**
 * \brief abstract argument
 *
 */
static int l_example_nested_FuncPtr3(lua_State *L)
{
    // splicer begin function.FuncPtr3
    double get = lua_tonumber(L, 1);
    example::nested::FuncPtr3(get);
    return 0;
    // splicer end function.FuncPtr3
}

// void FuncPtr5(void ( * get)(int verylongname1 +value, int verylongname2 +value, int verylongname3 +value, int verylongname4 +value, int verylongname5 +value, int verylongname6 +value, int verylongname7 +value, int verylongname8 +value, int verylongname9 +value, int verylongname10 +value) +value)
// ----------------------------------------
// Function:  void FuncPtr5
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  void ( * get)(int verylongname1 +value, int verylongname2 +value, int verylongname3 +value, int verylongname4 +value, int verylongname5 +value, int verylongname6 +value, int verylongname7 +value, int verylongname8 +value, int verylongname9 +value, int verylongname10 +value) +value
// Attrs:     +intent(in)
// Requested: lua_in_void_scalar
// Match:     lua_default
static int l_example_nested_FuncPtr5(lua_State *)
{
    // splicer begin function.FuncPtr5
    example::nested::FuncPtr5(get);
    return 0;
    // splicer end function.FuncPtr5
}

// void verylongfunctionname1(int * verylongname1 +intent(inout), int * verylongname2 +intent(inout), int * verylongname3 +intent(inout), int * verylongname4 +intent(inout), int * verylongname5 +intent(inout), int * verylongname6 +intent(inout), int * verylongname7 +intent(inout), int * verylongname8 +intent(inout), int * verylongname9 +intent(inout), int * verylongname10 +intent(inout))
// ----------------------------------------
// Function:  void verylongfunctionname1
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  int * verylongname1 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname2 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname3 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname4 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname5 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname6 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname7 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname8 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname9 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
// ----------------------------------------
// Argument:  int * verylongname10 +intent(inout)
// Attrs:     +intent(inout)
// Exact:     lua_inout_native_*
static int l_example_nested_verylongfunctionname1(lua_State *L)
{
    // splicer begin function.verylongfunctionname1
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    // lua_native_*_inout;
    example::nested::verylongfunctionname1(verylongname1, verylongname2,
        verylongname3, verylongname4, verylongname5, verylongname6,
        verylongname7, verylongname8, verylongname9, verylongname10);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    lua_pushinteger(L, XXXpush_arg);
    return 0;
    // splicer end function.verylongfunctionname1
}

// int verylongfunctionname2(int verylongname1 +value, int verylongname2 +value, int verylongname3 +value, int verylongname4 +value, int verylongname5 +value, int verylongname6 +value, int verylongname7 +value, int verylongname8 +value, int verylongname9 +value, int verylongname10 +value)
// ----------------------------------------
// Function:  int verylongfunctionname2
// Attrs:     +intent(function)
// Exact:     lua_function_native_scalar
// ----------------------------------------
// Argument:  int verylongname1 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname2 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname3 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname4 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname5 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname6 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname7 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname8 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname9 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
// ----------------------------------------
// Argument:  int verylongname10 +value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
static int l_example_nested_verylongfunctionname2(lua_State *L)
{
    // splicer begin function.verylongfunctionname2
    int verylongname1 = lua_tointeger(L, 1);
    int verylongname2 = lua_tointeger(L, 2);
    int verylongname3 = lua_tointeger(L, 3);
    int verylongname4 = lua_tointeger(L, 4);
    int verylongname5 = lua_tointeger(L, 5);
    int verylongname6 = lua_tointeger(L, 6);
    int verylongname7 = lua_tointeger(L, 7);
    int verylongname8 = lua_tointeger(L, 8);
    int verylongname9 = lua_tointeger(L, 9);
    int verylongname10 = lua_tointeger(L, 10);
    int SHCXX_rv = example::nested::verylongfunctionname2(verylongname1,
        verylongname2, verylongname3, verylongname4, verylongname5,
        verylongname6, verylongname7, verylongname8, verylongname9,
        verylongname10);
    lua_pushinteger(L, SHCXX_rv);
    return 1;
    // splicer end function.verylongfunctionname2
}

// void cos_doubles(double * in +intent(in)+rank(2), double * out +dimension(shape(in))+intent(out), int sizein +implied(size(in))+value)
// ----------------------------------------
// Function:  void cos_doubles
// Attrs:     +intent(subroutine)
// Exact:     lua_subroutine
// ----------------------------------------
// Argument:  double * in +intent(in)+rank(2)
// Attrs:     +intent(in)
// Requested: lua_in_native_*
// Match:     lua_default
// ----------------------------------------
// Argument:  double * out +dimension(shape(in))+intent(out)
// Attrs:     +intent(out)
// Requested: lua_out_native_*
// Match:     lua_default
// ----------------------------------------
// Argument:  int sizein +implied(size(in))+value
// Attrs:     +intent(in)
// Exact:     lua_in_native_scalar
/**
 * \brief Test multidimensional arrays with allocatable
 *
 */
static int l_example_nested_cos_doubles(lua_State *L)
{
    // splicer begin function.cos_doubles
    int sizein = lua_tointeger(L, 2);
    example::nested::cos_doubles(in, out, sizein);
    lua_pushnumber(L, XXXpush_arg);
    return 0;
    // splicer end function.cos_doubles
}

// splicer begin additional_functions
// splicer end additional_functions

static const struct luaL_Reg l_UserLibrary_Reg [] = {
    {"ExClass1", l_example_nested_ExClass1_ctor},
    {"ExClass2", l_example_nested_ExClass2_ctor},
    {"local_function1", l_example_nested_local_function1},
    {"isNameValid", l_example_nested_isNameValid},
    {"isInitialized", l_example_nested_isInitialized},
    {"test_names", l_example_nested_test_names},
    {"testoptional", l_example_nested_testoptional},
    {"test_size_t", l_example_nested_test_size_t},
    {"testmpi", l_example_nested_testmpi},
    {"FuncPtr1", l_example_nested_FuncPtr1},
    {"FuncPtr2", l_example_nested_FuncPtr2},
    {"FuncPtr3", l_example_nested_FuncPtr3},
    {"FuncPtr5", l_example_nested_FuncPtr5},
    {"verylongfunctionname1", l_example_nested_verylongfunctionname1},
    {"verylongfunctionname2", l_example_nested_verylongfunctionname2},
    {"cos_doubles", l_example_nested_cos_doubles},
    // splicer begin register
    // splicer end register
    {NULL, NULL}   /*sentinel */
};

#ifdef __cplusplus
extern "C" {
#endif
int luaopen_userlibrary(lua_State *L) {

    /* Create the metatable and put it on the stack. */
    luaL_newmetatable(L, "ExClass1.metatable");
    /* Duplicate the metatable on the stack (We now have 2). */
    lua_pushvalue(L, -1);
    /* Pop the first metatable off the stack and assign it to __index
     * of the second one. We set the metatable for the table to itself.
     * This is equivalent to the following in lua:
     * metatable = {}
     * metatable.__index = metatable
     */
    lua_setfield(L, -2, "__index");

    /* Set the methods to the metatable that should be accessed via object:func */
#if LUA_VERSION_NUM < 502
    luaL_register(L, NULL, l_ExClass1_Reg);
#else
    luaL_setfuncs(L, l_ExClass1_Reg, 0);
#endif


    /* Create the metatable and put it on the stack. */
    luaL_newmetatable(L, "ExClass2.metatable");
    /* Duplicate the metatable on the stack (We now have 2). */
    lua_pushvalue(L, -1);
    /* Pop the first metatable off the stack and assign it to __index
     * of the second one. We set the metatable for the table to itself.
     * This is equivalent to the following in lua:
     * metatable = {}
     * metatable.__index = metatable
     */
    lua_setfield(L, -2, "__index");

    /* Set the methods to the metatable that should be accessed via object:func */
#if LUA_VERSION_NUM < 502
    luaL_register(L, NULL, l_ExClass2_Reg);
#else
    luaL_setfuncs(L, l_ExClass2_Reg, 0);
#endif


#if LUA_VERSION_NUM < 502
    luaL_register(L, "userlibrary", l_UserLibrary_Reg);
#else
    luaL_newlib(L, l_UserLibrary_Reg);
#endif
    return 1;
}
#ifdef __cplusplus
}
#endif

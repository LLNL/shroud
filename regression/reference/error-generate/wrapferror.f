! wrapferror.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright Shroud Project Developers. See LICENSE file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
!>
!! \file wrapferror.f
!! \brief Shroud generated wrapper for error library
!<
! splicer begin file_top
! splicer end file_top
module error_mod
    use iso_c_binding, only : C_INT, C_PTR
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! typedef none
    ! splicer begin typedef.none
    integer, parameter :: none = C_INT
    ! splicer end typedef.none


    type, bind(C) :: struct1
        integer(C_INT) :: arg1
        integer(C_INT) :: narg2
        type(C_PTR) :: arg2
    end type struct1


    type, bind(C) :: nested
        integer(C_INT) :: sublevels
    end type nested

    interface

        ! ----------------------------------------
        ! Function:  void AssignValues
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  const int *from
        ! Statement: f_in_native*
        ! ----------------------------------------
        ! Argument:  int nfrom
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  int *to +intent(out)
        ! Statement: f_out_native*
        ! ----------------------------------------
        ! Argument:  int nto
        ! Statement: f_in_native
        subroutine c_assign_values_bufferify(from, nfrom, to, nto) &
                bind(C, name="ERR_AssignValues_bufferify")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), intent(IN) :: from
            integer(C_INT), value, intent(IN) :: nfrom
            integer(C_INT), intent(OUT) :: to
            integer(C_INT), value, intent(IN) :: nto
        end subroutine c_assign_values_bufferify

        ! Generated by getter/setter
        ! ----------------------------------------
        ! Function:  int *struct1_get_arg2 +deref(pointerxx)+dimension(narg2)+intent(getter)
        ! Statement: f_mixin_unknown
        ! ----------------------------------------
        ! Argument:  struct1 *SH_this +intent(in)
        ! Statement: f_in_struct*
        function struct1_get_arg2(SH_this, ===>SHT_rv i_dummy_arg<===) &
                result(SHT_rv) &
                bind(C, name="ERR_struct1_get_arg2")
            import :: struct1
            implicit none
            type(struct1), intent(IN) :: SH_this
            ===>SHT_rv i_dummy_decl<===
            ===>SHT_rv i_result_decl<===
        end function struct1_get_arg2

        ! Generated by getter/setter
        ! ----------------------------------------
        ! Function:  void struct1_set_arg2 +intent(setter)
        ! Statement: f_setter
        ! ----------------------------------------
        ! Argument:  struct1 *SH_this
        ! Statement: f_inout_struct*
        ! ----------------------------------------
        ! Argument:  int *val +intent(setter)+rank(1)
        ! Statement: f_setter_native*
        subroutine struct1_set_arg2(SH_this, val) &
                bind(C, name="ERR_struct1_set_arg2")
            use iso_c_binding, only : C_INT
            import :: struct1
            implicit none
            type(struct1), intent(INOUT) :: SH_this
            integer(C_INT), intent(IN) :: val(*)
        end subroutine struct1_set_arg2
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int *struct1_get_arg2 +deref(pointerxx)+dimension(narg2)+intent(getter)
    ! Statement: f_mixin_unknown
    ! ----------------------------------------
    ! Argument:  struct1 *SH_this +intent(in)
    ! Statement: f_in_struct*
    function struct1_get_arg2(SH_this, ===>SHT_rv f_dummy_arg<===) &
            result(SHT_rv)
        type(struct1), intent(IN) :: SH_this
        ===>SHT_rv f_dummy_decl<===
        ! splicer begin function.struct1_get_arg2
        SHT_rv = c_struct1_get_arg2(SH_this, ===>SHT_rv f_arg_call<===)
        ! splicer end function.struct1_get_arg2
    end function struct1_get_arg2
#endif

#if 0
    ! Only the interface is needed
    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void struct1_set_arg2 +intent(setter)
    ! Statement: f_setter
    ! ----------------------------------------
    ! Argument:  struct1 *SH_this
    ! Statement: f_inout_struct*
    ! ----------------------------------------
    ! Argument:  int *val +intent(setter)+rank(1)
    ! Statement: f_setter_native*
    subroutine struct1_set_arg2(SH_this, val)
        use iso_c_binding, only : C_INT
        type(struct1), intent(INOUT) :: SH_this
        integer(C_INT), intent(IN) :: val(:)
        ! splicer begin function.struct1_set_arg2
        call c_struct1_set_arg2(SH_this, val)
        ! splicer end function.struct1_set_arg2
    end subroutine struct1_set_arg2
#endif

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module error_mod

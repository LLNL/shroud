! wrapfstrings.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright Shroud Project Developers. See LICENSE file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
#include "shroud/features.h"
!>
!! \file wrapfstrings.f
!! \brief Shroud generated wrapper for strings library
!<
! splicer begin file_top
! splicer end file_top
module strings_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper type_defines
    ! Shroud type defines from helper type_defines
    integer, parameter, private :: &
        SH_TYPE_SIGNED_CHAR= 1, &
        SH_TYPE_SHORT      = 2, &
        SH_TYPE_INT        = 3, &
        SH_TYPE_LONG       = 4, &
        SH_TYPE_LONG_LONG  = 5, &
        SH_TYPE_SIZE_T     = 6, &
        SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &
        SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &
        SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &
        SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &
        SH_TYPE_INT8_T    =  7, &
        SH_TYPE_INT16_T   =  8, &
        SH_TYPE_INT32_T   =  9, &
        SH_TYPE_INT64_T   = 10, &
        SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &
        SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &
        SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &
        SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &
        SH_TYPE_FLOAT       = 22, &
        SH_TYPE_DOUBLE      = 23, &
        SH_TYPE_LONG_DOUBLE = 24, &
        SH_TYPE_FLOAT_COMPLEX      = 25, &
        SH_TYPE_DOUBLE_COMPLEX     = 26, &
        SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &
        SH_TYPE_BOOL      = 28, &
        SH_TYPE_CHAR      = 29, &
        SH_TYPE_CPTR      = 30, &
        SH_TYPE_STRUCT    = 31, &
        SH_TYPE_OTHER     = 32

    ! start helper array_context
    ! helper array_context
    type, bind(C) :: STR_SHROUD_array
        ! address of data
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type STR_SHROUD_array
    ! end helper array_context

    ! start helper capsule_data
    ! helper capsule_data
    type, bind(C) :: STR_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
        integer(C_INT) :: cmemflags = 0   ! memory flags
    end type STR_SHROUD_capsule_data
    ! end helper capsule_data

    ! helper capsule_helper
    type :: STR_SHROUD_capsule
        private
        type(STR_SHROUD_capsule_data) :: mem
    contains
        final :: SHROUD_capsule_final
        procedure :: delete => SHROUD_capsule_delete
    end type STR_SHROUD_capsule

    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    interface
        subroutine init_test() &
                bind(C, name="STR_init_test")
            implicit none
        end subroutine init_test
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Statement: f_function_string_buf_copy
    interface
        subroutine c_get_const_string_len_bufferify(SHT_rv, SHT_rv_len) &
                bind(C, name="STR_getConstStringLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringAlloc
    ! Statement: c_function_string
    interface
        function c_get_const_string_alloc(SHT_rv_capsule) &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringAlloc")
            use iso_c_binding, only : C_PTR
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringAlloc
    ! Statement: f_function_string_cdesc_allocatable
    interface
        subroutine c_get_const_string_alloc_bufferify(SHT_rv_cdesc, &
                SHT_rv_capsule) &
                bind(C, name="STR_getConstStringAlloc_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
        end subroutine c_get_const_string_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringPointer +deref(pointer)
    ! Statement: f_function_string_cdesc_pointer
    interface
        subroutine c_get_const_string_pointer_bufferify(SHT_rv_capsule, &
                SHT_rv_cdesc) &
                bind(C, name="STR_getConstStringPointer_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
        end subroutine c_get_const_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringRaw +deref(raw)
    ! Statement: f_function_string_raw
    interface
        function c_get_const_string_raw_bufferify(SHT_rv_capsule) &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRaw_bufferify")
            use iso_c_binding, only : C_PTR
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_raw_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringAsArg +deref(copy)+funcarg
    ! Statement: f_function_string_buf_funcarg_copy
    interface
        subroutine c_get_const_string_as_arg_bufferify(output, noutput) &
                bind(C, name="STR_getConstStringAsArg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: noutput
        end subroutine c_get_const_string_as_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLen +len(30)
    ! Statement: c_function_string&
    interface
        function c_get_const_string_ref_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ref_len
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLen +len(30)
    ! Statement: f_function_string&_buf_copy
    interface
        subroutine c_get_const_string_ref_len_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="STR_getConstStringRefLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_ref_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLenEmpty +len(30)
    ! Statement: c_function_string&
    interface
        function c_get_const_string_ref_len_empty() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLenEmpty")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ref_len_empty
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLenEmpty +len(30)
    ! Statement: f_function_string&_buf_copy
    interface
        subroutine c_get_const_string_ref_len_empty_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="STR_getConstStringRefLenEmpty_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_ref_len_empty_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string &getConstStringRefAlloc
    ! Statement: c_function_string&
    ! start c_get_const_string_ref_alloc
    interface
        function c_get_const_string_ref_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ref_alloc
    end interface
    ! end c_get_const_string_ref_alloc

    ! ----------------------------------------
    ! Function:  const std::string &getConstStringRefAlloc
    ! Statement: f_function_string&_cdesc_allocatable
    ! start c_get_const_string_ref_alloc_bufferify
    interface
        subroutine c_get_const_string_ref_alloc_bufferify(SHT_rv_cdesc, &
                SHT_rv_capsule) &
                bind(C, name="STR_getConstStringRefAlloc_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
        end subroutine c_get_const_string_ref_alloc_bufferify
    end interface
    ! end c_get_const_string_ref_alloc_bufferify

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefAsArg +deref(copy)+funcarg
    ! Statement: c_function_string&
    interface
        function c_get_const_string_ref_as_arg() &
                result(output) &
                bind(C, name="STR_getConstStringRefAsArg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: output
        end function c_get_const_string_ref_as_arg
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefAsArg +deref(copy)+funcarg
    ! Statement: f_function_string&_buf_funcarg_copy
    interface
        subroutine c_get_const_string_ref_as_arg_bufferify(output, &
                noutput) &
                bind(C, name="STR_getConstStringRefAsArg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: noutput
        end subroutine c_get_const_string_ref_as_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string *getConstStringPtrLen +len(30)
    ! Statement: c_function_string*
    interface
        function c_get_const_string_ptr_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_len
    end interface

    ! ----------------------------------------
    ! Function:  const string *getConstStringPtrLen +len(30)
    ! Statement: f_function_string*_buf_copy
    interface
        subroutine c_get_const_string_ptr_len_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="STR_getConstStringPtrLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_ptr_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrAlloc +owner(library)
    ! Statement: c_function_string*_library
    interface
        function c_get_const_string_ptr_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrAlloc +owner(library)
    ! Statement: f_function_string*_cdesc_allocatable_library
    interface
        subroutine c_get_const_string_ptr_alloc_bufferify(SHT_rv_cdesc, &
                SHT_rv_capsule) &
                bind(C, name="STR_getConstStringPtrAlloc_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
        end subroutine c_get_const_string_ptr_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAlloc +owner(caller)
    ! Statement: c_function_string*_caller
    interface
        function c_get_const_string_ptr_owns_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_owns_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAlloc +owner(caller)
    ! Statement: f_function_string*_cdesc_allocatable_caller
    interface
        subroutine c_get_const_string_ptr_owns_alloc_bufferify( &
                SHT_rv_cdesc, SHT_rv_capsule) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
        end subroutine c_get_const_string_ptr_owns_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAllocPattern +destructor_name(C_string_free)+owner(caller)
    ! Statement: c_function_string*_caller
    interface
        function c_get_const_string_ptr_owns_alloc_pattern() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_owns_alloc_pattern
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAllocPattern +destructor_name(C_string_free)+owner(caller)
    ! Statement: f_function_string*_cdesc_allocatable_caller
    interface
        subroutine c_get_const_string_ptr_owns_alloc_pattern_bufferify( &
                SHT_rv_cdesc, SHT_rv_capsule) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
        end subroutine c_get_const_string_ptr_owns_alloc_pattern_bufferify
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Statement: c_function_string*_library
    interface
        function c_get_const_string_ptr_pointer() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_pointer
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Statement: f_function_string*_cdesc_pointer_library
    interface
        subroutine c_get_const_string_ptr_pointer_bufferify( &
                SHT_rv_cdesc) &
                bind(C, name="STR_getConstStringPtrPointer_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
        end subroutine c_get_const_string_ptr_pointer_bufferify
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string &arg1
    ! Statement: c_in_string&
    interface
        subroutine c_accept_string_const_reference(arg1) &
                bind(C, name="STR_acceptStringConstReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string &arg1
    ! Statement: f_in_string&_buf
    interface
        subroutine c_accept_string_const_reference_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringConstReference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_const_reference_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1 +intent(out)
    ! Statement: c_out_string&
    interface
        subroutine c_accept_string_reference_out(arg1) &
                bind(C, name="STR_acceptStringReferenceOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1 +intent(out)
    ! Statement: f_out_string&_buf
    interface
        subroutine c_accept_string_reference_out_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringReferenceOut_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_reference_out_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1
    ! Statement: c_inout_string&
    ! start c_accept_string_reference
    interface
        subroutine c_accept_string_reference(arg1) &
                bind(C, name="STR_acceptStringReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_reference
    end interface
    ! end c_accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1
    ! Statement: f_inout_string&_buf
    ! start c_accept_string_reference_bufferify
    interface
        subroutine c_accept_string_reference_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringReference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_reference_bufferify
    end interface
    ! end c_accept_string_reference_bufferify

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string *arg1
    ! Statement: c_in_string*
    interface
        subroutine c_accept_string_pointer_const(arg1) &
                bind(C, name="STR_acceptStringPointerConst")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string *arg1
    ! Statement: f_in_string*_buf
    interface
        subroutine c_accept_string_pointer_const_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringPointerConst_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_pointer_const_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: c_inout_string*
    interface
        subroutine c_accept_string_pointer(arg1) &
                bind(C, name="STR_acceptStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_buf
    interface
        subroutine c_accept_string_pointer_bufferify(arg1, SHT_arg1_len) &
                bind(C, name="STR_acceptStringPointer_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: c_out_string*
    interface
        subroutine c_fetch_string_pointer(arg1) &
                bind(C, name="STR_fetchStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_buf
    interface
        subroutine c_fetch_string_pointer_bufferify(arg1, SHT_arg1_len) &
                bind(C, name="STR_fetchStringPointer_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_fetch_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: c_inout_string*
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_acceptStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_buf
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    interface
        subroutine c_accept_string_pointer_len_bufferify(arg1, &
                SHT_arg1_len, nlen) &
                bind(C, name="STR_acceptStringPointerLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: c_out_string*
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetchStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_buf
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    interface
        subroutine c_fetch_string_pointer_len_bufferify(arg1, &
                SHT_arg1_len, nlen) &
                bind(C, name="STR_fetchStringPointerLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Statement: c_function_native
    ! ----------------------------------------
    ! Argument:  std::string arg1
    ! Statement: c_in_string
    interface
        function c_accept_string_instance(arg1) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT) :: SHT_rv
        end function c_accept_string_instance
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  std::string arg1
    ! Statement: f_in_string_buf
    interface
        function c_accept_string_instance_bufferify(arg1, SHT_arg1_len) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
            integer(C_INT) :: SHT_rv
        end function c_accept_string_instance_bufferify
    end interface

#if 0
    ! Not Implemented
    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +dimension(nstrs)+intent(out)
    ! Statement: c_out_string**
    ! ----------------------------------------
    ! Argument:  int *nstrs +hidden+intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_array_string_arg(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringArg")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT), value :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_arg
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cdesc_copy
    interface
        subroutine c_fetch_array_string_arg_bufferify(SHT_strs_cdesc) &
                bind(C, name="STR_fetchArrayStringArg_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_strs_cdesc
        end subroutine c_fetch_array_string_arg_bufferify
    end interface

#if 0
    ! Not Implemented
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Statement: c_out_string**
    ! ----------------------------------------
    ! Argument:  int *nstrs +hidden+intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_array_string_alloc(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAlloc")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT), value :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cdesc_allocatable
    interface
        subroutine c_fetch_array_string_alloc_bufferify(SHT_strs_cdesc, &
                SHT_strs_capsule) &
                bind(C, name="STR_fetchArrayStringAlloc_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_strs_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_strs_capsule
        end subroutine c_fetch_array_string_alloc_bufferify
    end interface

#if 0
    ! Not Implemented
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Statement: c_out_string**
    ! ----------------------------------------
    ! Argument:  int *nstrs +hidden+intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_array_string_alloc_len(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAllocLen")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT), value :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc_len
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Statement: f_out_string**_cdesc_allocatable
    interface
        subroutine c_fetch_array_string_alloc_len_bufferify( &
                SHT_strs_cdesc, SHT_strs_capsule) &
                bind(C, name="STR_fetchArrayStringAllocLen_bufferify")
            import :: STR_SHROUD_array, STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_strs_cdesc
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_strs_capsule
        end subroutine c_fetch_array_string_alloc_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine cpass_char(status) &
                bind(C, name="CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    interface
        subroutine c_creturn_char(SHT_rv) &
                bind(C, name="STR_CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  int *count +intent(in)+rank(1)
    ! Statement: c_in_native*
    ! ----------------------------------------
    ! Argument:  std::string &name
    ! Statement: c_inout_string&
    interface
        subroutine c_post_declare(count, name) &
                bind(C, name="STR_PostDeclare")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
        end subroutine c_post_declare
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int *count +intent(in)+rank(1)
    ! Statement: f_in_native*
    ! ----------------------------------------
    ! Argument:  std::string &name
    ! Statement: f_inout_string&_buf
    interface
        subroutine c_post_declare_bufferify(count, name, SHT_name_len) &
                bind(C, name="STR_PostDeclare_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
        end subroutine c_post_declare_bufferify
    end interface

    interface
        ! helper array_string_allocatable
        subroutine STR_SHROUD_cdesc_array_string_allocatable(dest, src) &
             bind(c,name="STR_ShroudCDescArrayStringAllocatable")
            import STR_SHROUD_array, STR_SHROUD_capsule_data
            type(STR_SHROUD_array), intent(IN) :: dest
            type(STR_SHROUD_capsule_data), intent(IN) :: src
        end subroutine STR_SHROUD_cdesc_array_string_allocatable
    end interface

    interface
        ! helper capsule_dtor
        ! Delete memory in a capsule.
        subroutine STR_SHROUD_capsule_dtor(ptr) &
            bind(C, name="STR_SHROUD_memory_destructor")
            import STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(INOUT) :: ptr
        end subroutine STR_SHROUD_capsule_dtor
    end interface

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine STR_SHROUD_copy_string(context, c_var, c_var_size) &
             bind(c,name="STR_ShroudCopyString")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import STR_SHROUD_array
            type(STR_SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine STR_SHROUD_copy_string
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    subroutine init_test()
        ! splicer begin function.init_test
        call c_init_test()
        ! splicer end function.init_test
    end subroutine init_test
#endif

    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Statement: f_function_string_buf_copy
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    function get_const_string_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_string_len
    end function get_const_string_len

    ! ----------------------------------------
    ! Function:  const string getConstStringAlloc
    ! Statement: f_function_string_cdesc_allocatable
    !>
    !! Return an ALLOCATABLE CHARACTER from std::string.
    !! The language=C wrapper will return a const char *
    !<
    function get_const_string_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_rv_capsule
        call c_get_const_string_alloc_bufferify(SHT_rv_cdesc, &
            SHT_rv_capsule)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        call STR_SHROUD_capsule_dtor(SHT_rv_capsule)
        ! splicer end function.get_const_string_alloc
    end function get_const_string_alloc

    ! ----------------------------------------
    ! Function:  const string getConstStringPointer +deref(pointer)
    ! Statement: f_function_string_cdesc_pointer
    !>
    !! Return an POINTER CHARACTER from std::string.
    !! The language=C wrapper will return a const char *
    !<
    function get_const_string_pointer(Crv) &
            result(SHT_rv)
        type(STR_SHROUD_capsule), intent(OUT) :: Crv
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_const_string_pointer
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_pointer_bufferify(Crv%mem, SHT_rv_cdesc)
        call STR_SHROUD_pointer_string(SHT_rv_cdesc, SHT_rv)
        ! splicer end function.get_const_string_pointer
    end function get_const_string_pointer

    ! ----------------------------------------
    ! Function:  const string getConstStringRaw +deref(raw)
    ! Statement: f_function_string_raw
    !>
    !! Return an type(C_PTR) from std::string.
    !! The language=C wrapper will return a const char *
    !<
    function get_const_string_raw(Crv) &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(C_PTR) :: SHT_rv
        type(STR_SHROUD_capsule), intent(OUT) :: Crv
        ! splicer begin function.get_const_string_raw
        SHT_rv = c_get_const_string_raw_bufferify(Crv%mem)
        ! splicer end function.get_const_string_raw
    end function get_const_string_raw

    ! ----------------------------------------
    ! Function:  const string getConstStringAsArg +deref(copy)+funcarg
    ! Statement: f_function_string_buf_funcarg_copy
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    subroutine get_const_string_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_as_arg
        integer(C_INT) noutput
        noutput = len(output, kind=C_INT)
        call c_get_const_string_as_arg_bufferify(output, noutput)
        ! splicer end function.get_const_string_as_arg
    end subroutine get_const_string_as_arg

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLen +len(30)
    ! Statement: f_function_string&_buf_copy
    !>
    !! \brief return 'const string&' with fixed size (len=30)
    !!
    !! Since +len(30) is provided, the result of the function
    !! will be copied directly into memory provided by Fortran.
    !! The function will not be ALLOCATABLE.
    !<
    function get_const_string_ref_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_ref_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_string_ref_len
    end function get_const_string_ref_len

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLenEmpty +len(30)
    ! Statement: f_function_string&_buf_copy
    !>
    !! \brief Test returning empty string reference
    !!
    !<
    function get_const_string_ref_len_empty() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len_empty
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_ref_len_empty_bufferify(SHT_rv, &
            SHT_rv_len)
        ! splicer end function.get_const_string_ref_len_empty
    end function get_const_string_ref_len_empty

    ! ----------------------------------------
    ! Function:  const std::string &getConstStringRefAlloc
    ! Statement: f_function_string&_cdesc_allocatable
    !>
    !! \brief return a 'const string&' as ALLOCATABLE character
    !!
    !<
    ! start get_const_string_ref_alloc
    function get_const_string_ref_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_rv_capsule
        call c_get_const_string_ref_alloc_bufferify(SHT_rv_cdesc, &
            SHT_rv_capsule)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        call STR_SHROUD_capsule_dtor(SHT_rv_capsule)
        ! splicer end function.get_const_string_ref_alloc
    end function get_const_string_ref_alloc
    ! end get_const_string_ref_alloc

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefAsArg +deref(copy)+funcarg
    ! Statement: f_function_string&_buf_funcarg_copy
    !>
    !! \brief return a 'const string&' as argument
    !!
    !! Pass an additional argument which will be used as the return value.
    !! The length of the output variable is declared by the caller.
    !<
    subroutine get_const_string_ref_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_ref_as_arg
        integer(C_INT) noutput
        noutput = len(output, kind=C_INT)
        call c_get_const_string_ref_as_arg_bufferify(output, noutput)
        ! splicer end function.get_const_string_ref_as_arg
    end subroutine get_const_string_ref_as_arg

    ! ----------------------------------------
    ! Function:  const string *getConstStringPtrLen +len(30)
    ! Statement: f_function_string*_buf_copy
    !>
    !! \brief return a 'const string *' as character(30)
    !!
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished with C_finalize_buf which is possible
    !! because +len(30) so the contents are copied before returning.
    !<
    function get_const_string_ptr_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ptr_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_ptr_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_string_ptr_len
    end function get_const_string_ptr_len

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrAlloc +owner(library)
    ! Statement: f_function_string*_cdesc_allocatable_library
    function get_const_string_ptr_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_rv_capsule
        call c_get_const_string_ptr_alloc_bufferify(SHT_rv_cdesc, &
            SHT_rv_capsule)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        call STR_SHROUD_capsule_dtor(SHT_rv_capsule)
        ! splicer end function.get_const_string_ptr_alloc
    end function get_const_string_ptr_alloc

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAlloc +owner(caller)
    ! Statement: f_function_string*_cdesc_allocatable_caller
    !>
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished +owner(caller) which sets idtor.
    !! The contents are copied by Fortran so they must outlast
    !! the return from the C wrapper.
    !<
    function get_const_string_ptr_owns_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_rv_capsule
        call c_get_const_string_ptr_owns_alloc_bufferify(SHT_rv_cdesc, &
            SHT_rv_capsule)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        call STR_SHROUD_capsule_dtor(SHT_rv_capsule)
        ! splicer end function.get_const_string_ptr_owns_alloc
    end function get_const_string_ptr_owns_alloc

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAllocPattern +destructor_name(C_string_free)+owner(caller)
    ! Statement: f_function_string*_cdesc_allocatable_caller
    !>
    !! Similar to getConstStringPtrOwnsAlloc, but uses pattern to release memory.
    !<
    function get_const_string_ptr_owns_alloc_pattern() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc_pattern
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_rv_capsule
        call c_get_const_string_ptr_owns_alloc_pattern_bufferify(SHT_rv_cdesc, &
            SHT_rv_capsule)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        call STR_SHROUD_capsule_dtor(SHT_rv_capsule)
        ! splicer end function.get_const_string_ptr_owns_alloc_pattern
    end function get_const_string_ptr_owns_alloc_pattern

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Statement: f_function_string*_cdesc_pointer_library
    function get_const_string_ptr_pointer() &
            result(SHT_rv)
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_const_string_ptr_pointer
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ptr_pointer_bufferify(SHT_rv_cdesc)
        call STR_SHROUD_pointer_string(SHT_rv_cdesc, SHT_rv)
        ! splicer end function.get_const_string_ptr_pointer
    end function get_const_string_ptr_pointer
#endif

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string &arg1
    ! Statement: f_in_string&_buf
    !>
    !! \brief Accept a const string reference
    !!
    !! Save contents of arg1.
    !! arg1 is assumed to be intent(IN) since it is const
    !! Will copy in.
    !<
    subroutine accept_string_const_reference(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_const_reference
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_const_reference_bufferify(arg1, &
            SHT_arg1_len)
        ! splicer end function.accept_string_const_reference
    end subroutine accept_string_const_reference

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1 +intent(out)
    ! Statement: f_out_string&_buf
    !>
    !! \brief Accept a string reference
    !!
    !! Set out to a constant string.
    !! arg1 is intent(OUT)
    !! Must copy out.
    !<
    subroutine accept_string_reference_out(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.accept_string_reference_out
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_reference_out_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_reference_out
    end subroutine accept_string_reference_out

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1
    ! Statement: f_inout_string&_buf
    !>
    !! \brief Accept a string reference
    !!
    !! Append "dog" to the end of arg1.
    !! arg1 is assumed to be intent(INOUT)
    !! Must copy in and copy out.
    !<
    ! start accept_string_reference
    subroutine accept_string_reference(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_reference
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_reference_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_reference
    end subroutine accept_string_reference
    ! end accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string *arg1
    ! Statement: f_in_string*_buf
    !>
    !! \brief Accept a const string pointer - intent(in)
    !!
    !<
    subroutine accept_string_pointer_const(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_pointer_const
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_pointer_const_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_pointer_const
    end subroutine accept_string_pointer_const

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_buf
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !<
    subroutine accept_string_pointer(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_pointer
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_pointer_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_pointer
    end subroutine accept_string_pointer

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_buf
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !<
    subroutine fetch_string_pointer(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.fetch_string_pointer
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_fetch_string_pointer_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.fetch_string_pointer
    end subroutine fetch_string_pointer

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_buf
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine accept_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.accept_string_pointer_len
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_pointer_len_bufferify(arg1, SHT_arg1_len, &
            nlen)
        ! splicer end function.accept_string_pointer_len
    end subroutine accept_string_pointer_len

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_buf
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine fetch_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.fetch_string_pointer_len
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_fetch_string_pointer_len_bufferify(arg1, SHT_arg1_len, &
            nlen)
        ! splicer end function.fetch_string_pointer_len
    end subroutine fetch_string_pointer_len

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  std::string arg1
    ! Statement: f_in_string_buf
    !>
    !! \brief Accept a string instance
    !!
    !<
    function accept_string_instance(arg1) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        integer(C_INT) :: SHT_rv
        ! splicer begin function.accept_string_instance
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        SHT_rv = c_accept_string_instance_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_instance
    end function accept_string_instance

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cdesc_copy
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !<
    subroutine fetch_array_string_arg(strs)
        use iso_c_binding, only : C_LOC
        character(len=*), intent(OUT), target :: strs(:)
        ! splicer begin function.fetch_array_string_arg
        type(STR_SHROUD_array) :: SHT_strs_cdesc
        SHT_strs_cdesc%base_addr = C_LOC(strs)
        SHT_strs_cdesc%type = SH_TYPE_CHAR
        SHT_strs_cdesc%elem_len = len(strs)
        SHT_strs_cdesc%size = size(strs)
        SHT_strs_cdesc%rank = rank(strs)
        SHT_strs_cdesc%shape(1:1) = shape(strs)
        call c_fetch_array_string_arg_bufferify(SHT_strs_cdesc)
        ! splicer end function.fetch_array_string_arg
    end subroutine fetch_array_string_arg

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cdesc_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the maximum string length.
    !<
    subroutine fetch_array_string_alloc(strs)
        use iso_c_binding, only : C_LOC
        character(len=:), intent(OUT), allocatable, target :: strs(:)
        ! splicer begin function.fetch_array_string_alloc
        type(STR_SHROUD_array) :: SHT_strs_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_strs_capsule
        call c_fetch_array_string_alloc_bufferify(SHT_strs_cdesc, &
            SHT_strs_capsule)
        allocate(character(len=SHT_strs_cdesc%elem_len) :: &
            strs(SHT_strs_cdesc%size))
        SHT_strs_cdesc%base_addr = C_LOC(strs)
        call STR_SHROUD_cdesc_array_string_allocatable(SHT_strs_cdesc, SHT_strs_capsule)
        call STR_SHROUD_capsule_dtor(SHT_strs_capsule)
        ! splicer end function.fetch_array_string_alloc
    end subroutine fetch_array_string_alloc

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Statement: f_out_string**_cdesc_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the len attribute.
    !<
    subroutine fetch_array_string_alloc_len(strs)
        use iso_c_binding, only : C_LOC
        character(len=:), intent(OUT), allocatable, target :: strs(:)
        ! splicer begin function.fetch_array_string_alloc_len
        type(STR_SHROUD_array) :: SHT_strs_cdesc
        type(STR_SHROUD_capsule_data) :: SHT_strs_capsule
        call c_fetch_array_string_alloc_len_bufferify(SHT_strs_cdesc, &
            SHT_strs_capsule)
        allocate(character(len=SHT_strs_cdesc%elem_len) :: &
            strs(SHT_strs_cdesc%size))
        SHT_strs_cdesc%base_addr = C_LOC(strs)
        call STR_SHROUD_cdesc_array_string_allocatable(SHT_strs_cdesc, SHT_strs_capsule)
        call STR_SHROUD_capsule_dtor(SHT_strs_capsule)
        ! splicer end function.fetch_array_string_alloc_len
    end subroutine fetch_array_string_alloc_len

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! \brief pass a single char argument as a scalar, extern "C"
    !!
    !<
    subroutine cpass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.cpass_char
        call c_cpass_char(status)
        ! splicer end function.cpass_char
    end subroutine cpass_char
#endif

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char(SHT_rv)
        ! splicer end function.creturn_char
    end function creturn_char

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int *count +intent(in)+rank(1)
    ! Statement: f_in_native*
    ! ----------------------------------------
    ! Argument:  std::string &name
    ! Statement: f_inout_string&_buf
    !>
    !! Test post_declare.
    !! The std::string in py_string_inout must be declared before the
    !! goto added by py_native_*_in_pointer_list to avoid
    !! "jump to label 'fail' crosses initialization of" error.
    !<
    subroutine post_declare(count, name)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(IN) :: count(:)
        character(len=*), intent(INOUT) :: name
        ! splicer begin function.post_declare
        integer(C_INT) SHT_name_len
        SHT_name_len = len(name, kind=C_INT)
        call c_post_declare_bufferify(count, name, SHT_name_len)
        ! splicer end function.post_declare
    end subroutine post_declare

    ! splicer begin additional_functions
    ! splicer end additional_functions

    ! helper capsule_helper
    ! finalize a static STR_SHROUD_capsule_data
    subroutine SHROUD_capsule_final(cap)
        type(STR_SHROUD_capsule), intent(INOUT) :: cap
        call STR_SHROUD_capsule_dtor(cap%mem)
    end subroutine SHROUD_capsule_final

    subroutine SHROUD_capsule_delete(cap)
        class(STR_SHROUD_capsule) :: cap
        call STR_SHROUD_capsule_dtor(cap%mem)
    end subroutine SHROUD_capsule_delete

    ! start helper pointer_string
    ! helper pointer_string
    ! Assign context to an assumed-length character pointer
    subroutine STR_SHROUD_pointer_string(context, var)
        use iso_c_binding, only : c_associated, c_f_pointer, C_PTR
        implicit none
        type(STR_SHROUD_array), intent(IN) :: context
        character(len=:), pointer, intent(OUT) :: var
        character(len=context%elem_len), pointer :: fptr
        if (c_associated(context%base_addr)) then
            call c_f_pointer(context%base_addr, fptr)
            var => fptr
        else
            nullify(var)
        endif
    end subroutine STR_SHROUD_pointer_string
    ! end helper pointer_string

end module strings_mod

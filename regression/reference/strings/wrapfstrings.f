! wrapfstrings.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2023, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
#include "shroud/features.h"
!>
!! \file wrapfstrings.f
!! \brief Shroud generated wrapper for strings library
!<
! splicer begin file_top
! splicer end file_top
module strings_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper ShroudTypeDefines
    ! Shroud type defines from helper ShroudTypeDefines
    integer, parameter, private :: &
        SH_TYPE_SIGNED_CHAR= 1, &
        SH_TYPE_SHORT      = 2, &
        SH_TYPE_INT        = 3, &
        SH_TYPE_LONG       = 4, &
        SH_TYPE_LONG_LONG  = 5, &
        SH_TYPE_SIZE_T     = 6, &
        SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &
        SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &
        SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &
        SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &
        SH_TYPE_INT8_T    =  7, &
        SH_TYPE_INT16_T   =  8, &
        SH_TYPE_INT32_T   =  9, &
        SH_TYPE_INT64_T   = 10, &
        SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &
        SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &
        SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &
        SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &
        SH_TYPE_FLOAT       = 22, &
        SH_TYPE_DOUBLE      = 23, &
        SH_TYPE_LONG_DOUBLE = 24, &
        SH_TYPE_FLOAT_COMPLEX      = 25, &
        SH_TYPE_DOUBLE_COMPLEX     = 26, &
        SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &
        SH_TYPE_BOOL      = 28, &
        SH_TYPE_CHAR      = 29, &
        SH_TYPE_CPTR      = 30, &
        SH_TYPE_STRUCT    = 31, &
        SH_TYPE_OTHER     = 32

    ! start helper capsule_data_helper
    ! helper capsule_data_helper
    type, bind(C) :: STR_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type STR_SHROUD_capsule_data
    ! end helper capsule_data_helper

    ! start array_context
    ! helper array_context
    type, bind(C) :: STR_SHROUD_array
        ! address of C++ memory
        type(STR_SHROUD_capsule_data) :: cxx
        ! address of data in cxx
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type STR_SHROUD_array
    ! end array_context

    ! ----------------------------------------
    ! Function:  void init_test
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    interface
        subroutine init_test() &
                bind(C, name="STR_init_test")
            implicit none
        end subroutine init_test
    end interface

    ! ----------------------------------------
    ! Function:  void passChar
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    interface
        subroutine pass_char(status) &
                bind(C, name="STR_passChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine pass_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    interface
        subroutine c_pass_char_force(status) &
                bind(C, name="STR_passCharForce")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine c_pass_char_force
    end interface

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    interface
        subroutine c_return_char(SHT_rv) &
                bind(C, name="STR_returnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_return_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    ! start c_pass_char_ptr
    interface
        subroutine c_pass_char_ptr(dest, src) &
                bind(C, name="STR_passCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr
    end interface
    ! end c_pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    ! start c_pass_char_ptr_bufferify
    interface
        subroutine c_pass_char_ptr_bufferify(dest, SHT_dest_len, src) &
                bind(C, name="STR_passCharPtr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: SHT_dest_len
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr_bufferify
    end interface
    ! end c_pass_char_ptr_bufferify

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Attrs:     +intent(inout)
    ! Requested: c_inout_char_*
    ! Match:     c_default
    interface
        subroutine c_pass_char_ptr_in_out(s) &
                bind(C, name="STR_passCharPtrInOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
        end subroutine c_pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_char_*_buf
    interface
        subroutine c_pass_char_ptr_in_out_bufferify(s, SHT_s_len) &
                bind(C, name="STR_passCharPtrInOut_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
            integer(C_INT), value, intent(IN) :: SHT_s_len
        end subroutine c_pass_char_ptr_in_out_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const char * getCharPtr1
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_char_*_allocatable
    ! Match:     c_function_char_*
    ! start c_get_char_ptr1
    interface
        function c_get_char_ptr1() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr1")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr1
    end interface
    ! end c_get_char_ptr1

    ! ----------------------------------------
    ! Function:  const char * getCharPtr1
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Requested: c_function_char_*_cdesc_allocatable
    ! Match:     c_function_char_*_cdesc
    ! start c_get_char_ptr1_bufferify
    interface
        subroutine c_get_char_ptr1_bufferify(SHT_rv) &
                bind(C, name="STR_getCharPtr1_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_char_ptr1_bufferify
    end interface
    ! end c_get_char_ptr1_bufferify

    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_char_*_copy
    ! Match:     c_function_char_*
    ! start c_get_char_ptr2
    interface
        function c_get_char_ptr2() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr2")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr2
    end interface
    ! end c_get_char_ptr2

    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +len(30)
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_char_*_buf_copy
    ! Match:     c_function_char_*_buf
    ! start c_get_char_ptr2_bufferify
    interface
        subroutine c_get_char_ptr2_bufferify(SHT_rv, SHT_rv_len) &
                bind(C, name="STR_getCharPtr2_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_char_ptr2_bufferify
    end interface
    ! end c_get_char_ptr2_bufferify

    ! ----------------------------------------
    ! Function:  const char * getCharPtr3
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_*
    ! start c_get_char_ptr3
    interface
        function c_get_char_ptr3() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr3")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr3
    end interface
    ! end c_get_char_ptr3

    ! ----------------------------------------
    ! Function:  void getCharPtr3
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * output
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: c_function_char_*_buf_result
    ! Match:     c_function_char_*_buf
    ! start c_get_char_ptr3_bufferify
    interface
        subroutine c_get_char_ptr3_bufferify(output, SHT_output_len) &
                bind(C, name="STR_getCharPtr3_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: SHT_output_len
        end subroutine c_get_char_ptr3_bufferify
    end interface
    ! end c_get_char_ptr3_bufferify

    ! ----------------------------------------
    ! Function:  const char * getCharPtr4 +deref(raw)
    ! Attrs:     +deref(raw)+intent(function)
    ! Requested: c_function_char_*_raw
    ! Match:     c_function_char_*
    interface
        function get_char_ptr4() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr4")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function get_char_ptr4
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char * getCharPtr5 +deref(pointer)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_char_*_pointer
    ! Match:     c_function_char_*
    interface
        function c_get_char_ptr5() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr5")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr5
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char * getCharPtr5 +deref(pointer)
    ! Attrs:     +api(cdesc)+deref(pointer)+intent(function)
    ! Requested: c_function_char_*_cdesc_pointer
    ! Match:     c_function_char_*_cdesc
    interface
        subroutine c_get_char_ptr5_bufferify(SHT_rv) &
                bind(C, name="STR_getCharPtr5_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_char_ptr5_bufferify
    end interface
#endif

    ! ----------------------------------------
    ! Function:  const string getConstStringResult
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cdesc_allocatable
    interface
        subroutine c_get_const_string_result_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringResult_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_result_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_scalar_buf_copy
    ! Match:     c_function_string_scalar_buf
    interface
        subroutine c_get_const_string_len_bufferify(SHT_rv, SHT_rv_len) &
                bind(C, name="STR_getConstStringLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringAsArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string * output
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_*_buf_result
    ! Match:     c_function_string_*_buf
    interface
        subroutine c_get_const_string_as_arg_bufferify(output, &
                SHT_output_len) &
                bind(C, name="STR_getConstStringAsArg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: SHT_output_len
        end subroutine c_get_const_string_as_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string getConstStringAlloc
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cdesc_allocatable
    interface
        subroutine c_get_const_string_alloc_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringAlloc_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_&_allocatable
    ! Match:     c_function_string_&
    ! start c_get_const_string_ref_pure
    interface
        function c_get_const_string_ref_pure() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefPure")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_pure
    end interface
    ! end c_get_const_string_ref_pure

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    ! start c_get_const_string_ref_pure_bufferify
    interface
        subroutine c_get_const_string_ref_pure_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringRefPure_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ref_pure_bufferify
    end interface
    ! end c_get_const_string_ref_pure_bufferify

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_&_copy
    ! Match:     c_function_string_&
    interface
        function c_get_const_string_ref_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_len
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +len(30)
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_buf_copy
    ! Match:     c_function_string_&_buf
    interface
        subroutine c_get_const_string_ref_len_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="STR_getConstStringRefLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_ref_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefAsArg
    ! Attrs:     +intent(function)
    ! Exact:     c_function_string_&
    interface
        function c_get_const_string_ref_as_arg() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefAsArg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_as_arg
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringRefAsArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string & output
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_&_buf_result
    ! Match:     c_function_string_&_buf
    interface
        subroutine c_get_const_string_ref_as_arg_bufferify(output, &
                SHT_output_len) &
                bind(C, name="STR_getConstStringRefAsArg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: SHT_output_len
        end subroutine c_get_const_string_ref_as_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_&_copy
    ! Match:     c_function_string_&
    interface
        function c_get_const_string_ref_len_empty() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLenEmpty")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_len_empty
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +len(30)
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_buf_copy
    ! Match:     c_function_string_&_buf
    interface
        subroutine c_get_const_string_ref_len_empty_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="STR_getConstStringRefLenEmpty_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_ref_len_empty_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_&_allocatable
    ! Match:     c_function_string_&
    interface
        function c_get_const_string_ref_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    interface
        subroutine c_get_const_string_ref_alloc_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ref_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_*_copy
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_len
    end interface

    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +len(30)
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_*_buf_copy
    ! Match:     c_function_string_*_buf
    interface
        subroutine c_get_const_string_ptr_len_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="STR_getConstStringPtrLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_string_ptr_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +owner(library)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_*_allocatable
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +owner(library)
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cdesc_allocatable
    interface
        subroutine c_get_const_string_ptr_alloc_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ptr_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_*_allocatable
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_owns_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_owns_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +owner(caller)
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cdesc_allocatable
    interface
        subroutine c_get_const_string_ptr_owns_alloc_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ptr_owns_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +free_pattern(C_string_free)+owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_*_allocatable
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_owns_alloc_pattern() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_owns_alloc_pattern
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +free_pattern(C_string_free)+owner(caller)
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cdesc_allocatable
    interface
        subroutine c_get_const_string_ptr_owns_alloc_pattern_bufferify( &
                SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ptr_owns_alloc_pattern_bufferify
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_string_*_pointer
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_pointer() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_pointer
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Attrs:     +api(cdesc)+deref(pointer)+intent(function)
    ! Exact:     c_function_string_*_cdesc_pointer
    interface
        subroutine c_get_const_string_ptr_pointer_bufferify(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ptr_pointer_bufferify
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string & arg1
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_&
    interface
        subroutine c_accept_string_const_reference(arg1) &
                bind(C, name="STR_acceptStringConstReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string & arg1
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_&_buf
    interface
        subroutine c_accept_string_const_reference_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringConstReference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_const_reference_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     c_out_string_&
    interface
        subroutine c_accept_string_reference_out(arg1) &
                bind(C, name="STR_acceptStringReferenceOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_string_&_buf
    interface
        subroutine c_accept_string_reference_out_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringReferenceOut_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_reference_out_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_&
    ! start c_accept_string_reference
    interface
        subroutine c_accept_string_reference(arg1) &
                bind(C, name="STR_acceptStringReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_reference
    end interface
    ! end c_accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_&_buf
    ! start c_accept_string_reference_bufferify
    interface
        subroutine c_accept_string_reference_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringReference_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_reference_bufferify
    end interface
    ! end c_accept_string_reference_bufferify

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string * arg1
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_*
    interface
        subroutine c_accept_string_pointer_const(arg1) &
                bind(C, name="STR_acceptStringPointerConst")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string * arg1
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_*_buf
    interface
        subroutine c_accept_string_pointer_const_bufferify(arg1, &
                SHT_arg1_len) &
                bind(C, name="STR_acceptStringPointerConst_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_pointer_const_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_*
    interface
        subroutine c_accept_string_pointer(arg1) &
                bind(C, name="STR_acceptStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_*_buf
    interface
        subroutine c_accept_string_pointer_bufferify(arg1, SHT_arg1_len) &
                bind(C, name="STR_acceptStringPointer_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_accept_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     c_out_string_*
    interface
        subroutine c_fetch_string_pointer(arg1) &
                bind(C, name="STR_fetchStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_string_*_buf
    interface
        subroutine c_fetch_string_pointer_bufferify(arg1, SHT_arg1_len) &
                bind(C, name="STR_fetchStringPointer_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
        end subroutine c_fetch_string_pointer_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_*
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_acceptStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_*_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_accept_string_pointer_len_bufferify(arg1, &
                SHT_arg1_len, nlen) &
                bind(C, name="STR_acceptStringPointerLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     c_out_string_*
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetchStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_string_*_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_string_pointer_len_bufferify(arg1, &
                SHT_arg1_len, nlen) &
                bind(C, name="STR_fetchStringPointerLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  std::string arg1 +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_scalar
    interface
        function c_accept_string_instance(arg1) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT) :: SHT_rv
        end function c_accept_string_instance
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  std::string arg1 +value
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_scalar_buf
    interface
        function c_accept_string_instance_bufferify(arg1, SHT_arg1_len) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT), value, intent(IN) :: SHT_arg1_len
            integer(C_INT) :: SHT_rv
        end function c_accept_string_instance_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +dimension(nstrs)+intent(out)
    ! Attrs:     +deref(copy)+intent(out)
    ! Exact:     c_out_string_**_copy
    ! ----------------------------------------
    ! Argument:  int * nstrs +hidden+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_array_string_arg(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringArg")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_arg
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +dimension(nstrs)+intent(out)
    ! Attrs:     +api(cdesc)+deref(copy)+intent(out)
    ! Exact:     c_out_string_**_cdesc_copy
    interface
        subroutine c_fetch_array_string_arg_bufferify(SHT_strs_cdesc) &
                bind(C, name="STR_fetchArrayStringArg_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_strs_cdesc
        end subroutine c_fetch_array_string_arg_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_allocatable
    ! ----------------------------------------
    ! Argument:  int * nstrs +hidden+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_array_string_alloc(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAlloc")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_cdesc_allocatable
    interface
        subroutine c_fetch_array_string_alloc_bufferify(SHT_strs_cdesc) &
                bind(C, name="STR_fetchArrayStringAlloc_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_strs_cdesc
        end subroutine c_fetch_array_string_alloc_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_allocatable
    ! ----------------------------------------
    ! Argument:  int * nstrs +hidden+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_array_string_alloc_len(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAllocLen")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_cdesc_allocatable
    interface
        subroutine c_fetch_array_string_alloc_len_bufferify( &
                SHT_strs_cdesc) &
                bind(C, name="STR_fetchArrayStringAllocLen_bufferify")
            import :: STR_SHROUD_array
            implicit none
            type(STR_SHROUD_array), intent(OUT) :: SHT_strs_cdesc
        end subroutine c_fetch_array_string_alloc_len_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(in)+len_trim(AAlen)
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        subroutine c_explicit1(name) &
                bind(C, name="STR_explicit1")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
        end subroutine c_explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    interface
        subroutine c_explicit2(name) &
                bind(C, name="STR_explicit2")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
        end subroutine c_explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    interface
        subroutine c_explicit2_bufferify(name, SHT_name_len) &
                bind(C, name="STR_explicit2_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
        end subroutine c_explicit2_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    interface
        subroutine cpass_char(status) &
                bind(C, name="CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    interface
        subroutine c_creturn_char(SHT_rv) &
                bind(C, name="STR_CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +blanknull
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        subroutine c_cpass_char_ptr(dest, src) &
                bind(C, name="CpassCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    ! ----------------------------------------
    ! Argument:  const char * src +blanknull
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_char_*_buf
    interface
        subroutine c_cpass_char_ptr_bufferify(dest, SHT_dest_len, src, &
                SHT_src_len) &
                bind(C, name="STR_CpassCharPtr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: SHT_dest_len
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: SHT_src_len
        end subroutine c_cpass_char_ptr_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        subroutine c_cpass_char_ptr_blank(dest, src) &
                bind(C, name="STR_CpassCharPtrBlank")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr_blank
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_char_*_buf
    interface
        subroutine c_cpass_char_ptr_blank_bufferify(dest, SHT_dest_len, &
                src, SHT_src_len) &
                bind(C, name="STR_CpassCharPtrBlank_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: SHT_dest_len
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: SHT_src_len
        end subroutine c_cpass_char_ptr_blank_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_&
    interface
        subroutine c_post_declare(count, name) &
                bind(C, name="STR_PostDeclare")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
        end subroutine c_post_declare
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_&_buf
    interface
        subroutine c_post_declare_bufferify(count, name, SHT_name_len) &
                bind(C, name="STR_PostDeclare_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
        end subroutine c_post_declare_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        function c_cpass_char_ptr_notrim(src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrNotrim")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_notrim
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_char_*_buf
    interface
        function c_cpass_char_ptr_notrim_bufferify(src, SHT_src_len) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrNotrim_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: SHT_src_len
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_notrim_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  void * addr +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_void_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    interface
        function cpass_char_ptr_capi(addr, src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrCAPI")
            use iso_c_binding, only : C_CHAR, C_INT, C_PTR
            implicit none
            type(C_PTR), value, intent(IN) :: addr
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_capi
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * in
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    interface
        function c_cpass_char_ptr_capi2(in, src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrCAPI2")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: in(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_capi2
    end interface

    interface
        ! helper array_string_allocatable
        ! Copy the char* or std::string in context into c_var.
        subroutine STR_SHROUD_array_string_allocatable(out, in) &
             bind(c,name="STR_ShroudArrayStringAllocatable")
            import STR_SHROUD_array, STR_SHROUD_capsule_data
            type(STR_SHROUD_array), intent(IN) :: out
            type(STR_SHROUD_array), intent(IN) :: in
        end subroutine STR_SHROUD_array_string_allocatable
    end interface

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine STR_SHROUD_copy_string_and_free(context, c_var, c_var_size) &
             bind(c,name="STR_ShroudCopyStringAndFree")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import STR_SHROUD_array
            type(STR_SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine STR_SHROUD_copy_string_and_free
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void init_test
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    subroutine init_test()
        ! splicer begin function.init_test
        call c_init_test()
        ! splicer end function.init_test
    end subroutine init_test
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void passChar
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_scalar
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    !>
    !! \brief pass a single char argument as a scalar.
    !!
    !<
    subroutine pass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char
        call c_pass_char(status)
        ! splicer end function.pass_char
    end subroutine pass_char
#endif

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_scalar
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    !>
    !! By default no Fortran wrapper is created.
    !! Force one so it can be tested.
    !<
    subroutine pass_char_force(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char_force
        call c_pass_char_force(status)
        ! splicer end function.pass_char_force
    end subroutine pass_char_force

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Attrs:     +intent(function)
    ! Exact:     f_function_char_scalar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    !>
    !! \brief return a char argument (non-pointer)
    !!
    !<
    function return_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.return_char
        call c_return_char(SHT_rv)
        ! splicer end function.return_char
    end function return_char

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_char_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! In Python, src must not be over 40 characters, defined by charlen.
    !<
    ! start pass_char_ptr
    subroutine pass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.pass_char_ptr
        integer(C_INT) SHT_dest_len
        SHT_dest_len = len(dest, kind=C_INT)
        call c_pass_char_ptr_bufferify(dest, SHT_dest_len, &
            trim(src)//C_NULL_CHAR)
        ! splicer end function.pass_char_ptr
    end subroutine pass_char_ptr
    ! end pass_char_ptr

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Attrs:     +intent(inout)
    ! Exact:     f_inout_char_*_buf
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_char_*_buf
    !>
    !! \brief toupper
    !!
    !! Change a string in-place.
    !! For Python, return a new string since strings are immutable.
    !<
    subroutine pass_char_ptr_in_out(s)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: s
        ! splicer begin function.pass_char_ptr_in_out
        integer(C_INT) SHT_s_len
        SHT_s_len = len(s, kind=C_INT)
        call c_pass_char_ptr_in_out_bufferify(s, SHT_s_len)
        ! splicer end function.pass_char_ptr_in_out
    end subroutine pass_char_ptr_in_out

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const char * getCharPtr1
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_char_*_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Requested: c_function_char_*_cdesc_allocatable
    ! Match:     c_function_char_*_cdesc
    !>
    !! \brief return a 'const char *' as character(*)
    !!
    !<
    ! start get_char_ptr1
    function get_char_ptr1() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_char_ptr1
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_char_ptr1_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_char_ptr1
    end function get_char_ptr1
    ! end get_char_ptr1

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_char_*_buf_copy
    ! Match:     f_function_char_*_buf
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_char_*_buf_copy
    ! Match:     c_function_char_*_buf
    !>
    !! \brief return 'const char *' with fixed size (len=30)
    !!
    !<
    ! start get_char_ptr2
    function get_char_ptr2() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_char_ptr2
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_char_ptr2_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_char_ptr2
    end function get_char_ptr2
    ! end get_char_ptr2

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getCharPtr3
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * output
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: f_function_char_*_buf_result
    ! Match:     f_function_char_*_buf
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: c_function_char_*_buf_result
    ! Match:     c_function_char_*_buf
    !>
    !! \brief return a 'const char *' as argument
    !!
    !<
    ! start get_char_ptr3
    subroutine get_char_ptr3(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_char_ptr3
        integer(C_INT) SHT_output_len
        SHT_output_len = len(output, kind=C_INT)
        call c_get_char_ptr3_bufferify(output, SHT_output_len)
        ! splicer end function.get_char_ptr3
    end subroutine get_char_ptr3
    ! end get_char_ptr3

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  const char * getCharPtr4 +deref(raw)
    ! Attrs:     +deref(raw)+intent(function)
    ! Exact:     f_function_char_*_raw
    ! Attrs:     +deref(raw)+intent(function)
    ! Requested: c_function_char_*_raw
    ! Match:     c_function_char_*
    !>
    !! \brief return a 'const char *' as type(C_PTR)
    !!
    !<
    function get_char_ptr4() &
            result(SHT_rv)
        type(C_PTR) :: SHT_rv
        ! splicer begin function.get_char_ptr4
        SHT_rv = c_get_char_ptr4()
        ! splicer end function.get_char_ptr4
    end function get_char_ptr4
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const char * getCharPtr5 +deref(pointer)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Exact:     f_function_char_*_cdesc_pointer
    ! Attrs:     +api(cdesc)+deref(pointer)+intent(function)
    ! Requested: c_function_char_*_cdesc_pointer
    ! Match:     c_function_char_*_cdesc
    !>
    !! \brief return a 'const char *' as character(:) pointer
    !!
    !<
    function get_char_ptr5() &
            result(SHT_rv)
        use iso_c_binding, only : c_f_pointer
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_char_ptr5
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_char_ptr5_bufferify(SHT_rv_cdesc)
        call STR_SHROUD_pointer_string(SHT_rv_cdesc, SHT_rv)
        ! splicer end function.get_char_ptr5
    end function get_char_ptr5
#endif

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string getConstStringResult
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_scalar_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cdesc_allocatable
    !>
    !! \brief return an ALLOCATABLE CHARACTER from std::string
    !!
    !<
    function get_const_string_result() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_result
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_result_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_result
    end function get_const_string_result

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_scalar_buf_copy
    ! Match:     f_function_string_scalar_buf
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_scalar_buf_copy
    ! Match:     c_function_string_scalar_buf
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    function get_const_string_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_string_len
    end function get_const_string_len

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getConstStringAsArg
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string * output
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: f_function_string_*_buf_result
    ! Match:     f_function_string_*_buf
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_*_buf_result
    ! Match:     c_function_string_*_buf
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    subroutine get_const_string_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_as_arg
        integer(C_INT) SHT_output_len
        SHT_output_len = len(output, kind=C_INT)
        call c_get_const_string_as_arg_bufferify(output, SHT_output_len)
        ! splicer end function.get_const_string_as_arg
    end subroutine get_const_string_as_arg

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string getConstStringAlloc
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_scalar_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cdesc_allocatable
    function get_const_string_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_alloc_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_alloc
    end function get_const_string_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_&_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    !>
    !! \brief return a 'const string&' as ALLOCATABLE character
    !!
    !<
    ! start get_const_string_ref_pure
    function get_const_string_ref_pure() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_pure
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ref_pure_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_ref_pure
    end function get_const_string_ref_pure
    ! end get_const_string_ref_pure

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_&_buf_copy
    ! Match:     f_function_string_&_buf
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_buf_copy
    ! Match:     c_function_string_&_buf
    !>
    !! \brief return 'const string&' with fixed size (len=30)
    !!
    !! Since +len(30) is provided, the result of the function
    !! will be copied directly into memory provided by Fortran.
    !! The function will not be ALLOCATABLE.
    !<
    function get_const_string_ref_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_ref_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_string_ref_len
    end function get_const_string_ref_len

    ! Generated by arg_to_buffer - arg_to_buffer
    ! ----------------------------------------
    ! Function:  void getConstStringRefAsArg
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string & output
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: f_function_string_&_buf_result
    ! Match:     f_function_string_&_buf
    ! Attrs:     +api(buf)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_&_buf_result
    ! Match:     c_function_string_&_buf
    !>
    !! \brief return a 'const string&' as argument
    !!
    !! Pass an additional argument which will be used as the return value.
    !! The length of the output variable is declared by the caller.
    !<
    subroutine get_const_string_ref_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_ref_as_arg
        integer(C_INT) SHT_output_len
        SHT_output_len = len(output, kind=C_INT)
        call c_get_const_string_ref_as_arg_bufferify(output, &
            SHT_output_len)
        ! splicer end function.get_const_string_ref_as_arg
    end subroutine get_const_string_ref_as_arg

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_&_buf_copy
    ! Match:     f_function_string_&_buf
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_buf_copy
    ! Match:     c_function_string_&_buf
    !>
    !! \brief Test returning empty string reference
    !!
    !<
    function get_const_string_ref_len_empty() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len_empty
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_ref_len_empty_bufferify(SHT_rv, &
            SHT_rv_len)
        ! splicer end function.get_const_string_ref_len_empty
    end function get_const_string_ref_len_empty

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_&_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cdesc_allocatable
    function get_const_string_ref_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ref_alloc_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_ref_alloc
    end function get_const_string_ref_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_*_buf_copy
    ! Match:     f_function_string_*_buf
    ! Attrs:     +api(buf)+deref(copy)+intent(function)
    ! Requested: c_function_string_*_buf_copy
    ! Match:     c_function_string_*_buf
    !>
    !! \brief return a 'const string *' as character(30)
    !!
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished with C_finalize_buf which is possible
    !! because +len(30) so the contents are copied before returning.
    !<
    function get_const_string_ptr_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ptr_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_string_ptr_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_string_ptr_len
    end function get_const_string_ptr_len

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +owner(library)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: f_function_string_*_cdesc_allocatable_library
    ! Match:     f_function_string_*_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cdesc_allocatable
    function get_const_string_ptr_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ptr_alloc_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_ptr_alloc
    end function get_const_string_ptr_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: f_function_string_*_cdesc_allocatable_caller
    ! Match:     f_function_string_*_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cdesc_allocatable
    !>
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished +owner(caller) which sets idtor.
    !! The contents are copied by Fortran so they must outlast
    !! the return from the C wrapper.
    !<
    function get_const_string_ptr_owns_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ptr_owns_alloc_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_ptr_owns_alloc
    end function get_const_string_ptr_owns_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +free_pattern(C_string_free)+owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: f_function_string_*_cdesc_allocatable_caller
    ! Match:     f_function_string_*_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cdesc_allocatable
    !>
    !! Similar to getConstStringPtrOwnsAlloc, but uses pattern to release memory.
    !<
    function get_const_string_ptr_owns_alloc_pattern() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc_pattern
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ptr_owns_alloc_pattern_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call STR_SHROUD_copy_string_and_free(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_const_string_ptr_owns_alloc_pattern
    end function get_const_string_ptr_owns_alloc_pattern

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: f_function_string_*_cdesc_pointer_library
    ! Match:     f_function_string_*_cdesc_pointer
    ! Attrs:     +api(cdesc)+deref(pointer)+intent(function)
    ! Exact:     c_function_string_*_cdesc_pointer
    function get_const_string_ptr_pointer() &
            result(SHT_rv)
        use iso_c_binding, only : c_f_pointer
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_const_string_ptr_pointer
        type(STR_SHROUD_array) :: SHT_rv_cdesc
        call c_get_const_string_ptr_pointer_bufferify(SHT_rv_cdesc)
        call STR_SHROUD_pointer_string(SHT_rv_cdesc, SHT_rv)
        ! splicer end function.get_const_string_ptr_pointer
    end function get_const_string_ptr_pointer
#endif

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string & arg1
    ! Attrs:     +intent(in)
    ! Exact:     f_in_string_&_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_&_buf
    !>
    !! \brief Accept a const string reference
    !!
    !! Save contents of arg1.
    !! arg1 is assumed to be intent(IN) since it is const
    !! Will copy in.
    !<
    subroutine accept_string_const_reference(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_const_reference
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_const_reference_bufferify(arg1, &
            SHT_arg1_len)
        ! splicer end function.accept_string_const_reference
    end subroutine accept_string_const_reference

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_string_&_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_string_&_buf
    !>
    !! \brief Accept a string reference
    !!
    !! Set out to a constant string.
    !! arg1 is intent(OUT)
    !! Must copy out.
    !<
    subroutine accept_string_reference_out(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.accept_string_reference_out
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_reference_out_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_reference_out
    end subroutine accept_string_reference_out

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1
    ! Attrs:     +intent(inout)
    ! Exact:     f_inout_string_&_buf
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_&_buf
    !>
    !! \brief Accept a string reference
    !!
    !! Append "dog" to the end of arg1.
    !! arg1 is assumed to be intent(INOUT)
    !! Must copy in and copy out.
    !<
    ! start accept_string_reference
    subroutine accept_string_reference(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_reference
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_reference_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_reference
    end subroutine accept_string_reference
    ! end accept_string_reference

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string * arg1
    ! Attrs:     +intent(in)
    ! Exact:     f_in_string_*_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_*_buf
    !>
    !! \brief Accept a const string pointer - intent(in)
    !!
    !<
    subroutine accept_string_pointer_const(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_pointer_const
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_pointer_const_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_pointer_const
    end subroutine accept_string_pointer_const

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Exact:     f_inout_string_*_buf
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_*_buf
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !<
    subroutine accept_string_pointer(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_pointer
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_pointer_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_pointer
    end subroutine accept_string_pointer

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_string_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_string_*_buf
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !<
    subroutine fetch_string_pointer(arg1)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.fetch_string_pointer
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_fetch_string_pointer_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.fetch_string_pointer
    end subroutine fetch_string_pointer

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Exact:     f_inout_string_*_buf
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_*_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_native_*
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine accept_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.accept_string_pointer_len
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_accept_string_pointer_len_bufferify(arg1, SHT_arg1_len, &
            nlen)
        ! splicer end function.accept_string_pointer_len
    end subroutine accept_string_pointer_len

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_string_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_string_*_buf
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_native_*
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine fetch_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.fetch_string_pointer_len
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        call c_fetch_string_pointer_len_bufferify(arg1, SHT_arg1_len, &
            nlen)
        ! splicer end function.fetch_string_pointer_len
    end subroutine fetch_string_pointer_len

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  std::string arg1 +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_string_scalar_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_string_scalar_buf
    !>
    !! \brief Accept a string instance
    !!
    !<
    function accept_string_instance(arg1) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        integer(C_INT) :: SHT_rv
        ! splicer begin function.accept_string_instance
        integer(C_INT) SHT_arg1_len
        SHT_arg1_len = len(arg1, kind=C_INT)
        SHT_rv = c_accept_string_instance_bufferify(arg1, SHT_arg1_len)
        ! splicer end function.accept_string_instance
    end function accept_string_instance

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +dimension(nstrs)+intent(out)
    ! Attrs:     +deref(copy)+intent(out)
    ! Exact:     f_out_string_**_cdesc_copy
    ! Attrs:     +api(cdesc)+deref(copy)+intent(out)
    ! Exact:     c_out_string_**_cdesc_copy
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !<
    subroutine fetch_array_string_arg(strs)
        use iso_c_binding, only : C_LOC
        character(*), intent(OUT), target :: strs(:)
        ! splicer begin function.fetch_array_string_arg
        type(STR_SHROUD_array) :: SHT_strs_cdesc
        SHT_strs_cdesc%cxx%addr = C_LOC(strs)
        SHT_strs_cdesc%base_addr = C_LOC(strs)
        SHT_strs_cdesc%type = SH_TYPE_CHAR
        SHT_strs_cdesc%elem_len = len(strs)
        SHT_strs_cdesc%size = size(strs)
        SHT_strs_cdesc%rank = rank(strs)
        SHT_strs_cdesc%shape(1:1) = shape(strs)
        call c_fetch_array_string_arg_bufferify(SHT_strs_cdesc)
        ! splicer end function.fetch_array_string_arg
    end subroutine fetch_array_string_arg

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Exact:     f_out_string_**_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_cdesc_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the maximum string length.
    !<
    subroutine fetch_array_string_alloc(strs)
        use iso_c_binding, only : C_LOC
        character(:), intent(out), allocatable, target :: strs(:)
        ! splicer begin function.fetch_array_string_alloc
        type(STR_SHROUD_array) :: SHT_strs_cdesc
        type(STR_SHROUD_array) :: SHT_strs_out
        call c_fetch_array_string_alloc_bufferify(SHT_strs_out)
        SHT_strs_cdesc%size = SHT_strs_out%size;
        SHT_strs_cdesc%elem_len = SHT_strs_out%elem_len;
        allocate(character(len=SHT_strs_cdesc%elem_len) :: &
            strs(SHT_strs_cdesc%size))
        SHT_strs_cdesc%cxx%addr = C_LOC(strs);
        SHT_strs_cdesc%base_addr = C_LOC(strs);
        call STR_SHROUD_array_string_allocatable(SHT_strs_cdesc, SHT_strs_out)
        ! splicer end function.fetch_array_string_alloc
    end subroutine fetch_array_string_alloc

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Exact:     f_out_string_**_cdesc_allocatable
    ! Attrs:     +api(cdesc)+deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_cdesc_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the len attribute.
    !<
    subroutine fetch_array_string_alloc_len(strs)
        use iso_c_binding, only : C_LOC
        character(len=20), intent(out), allocatable, target :: strs(:)
        ! splicer begin function.fetch_array_string_alloc_len
        type(STR_SHROUD_array) :: SHT_strs_cdesc
        type(STR_SHROUD_array) :: SHT_strs_out
        call c_fetch_array_string_alloc_len_bufferify(SHT_strs_out)
        SHT_strs_cdesc%size = SHT_strs_out%size;
        SHT_strs_cdesc%elem_len = SHT_strs_out%elem_len;
        allocate(strs(SHT_strs_cdesc%size))
        SHT_strs_cdesc%cxx%addr = C_LOC(strs);
        SHT_strs_cdesc%base_addr = C_LOC(strs);
        call STR_SHROUD_array_string_allocatable(SHT_strs_cdesc, SHT_strs_out)
        ! splicer end function.fetch_array_string_alloc_len
    end subroutine fetch_array_string_alloc_len

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    subroutine explicit1(name)
        use iso_c_binding, only : C_NULL_CHAR
        character(len=*), intent(IN) :: name
        ! splicer begin function.explicit1
        call c_explicit1(trim(name)//C_NULL_CHAR)
        ! splicer end function.explicit1
    end subroutine explicit1

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void explicit2
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_char_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    subroutine explicit2(name)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: name
        ! splicer begin function.explicit2
        integer(C_INT) SHT_name_len
        SHT_name_len = len(name, kind=C_INT)
        call c_explicit2_bufferify(name, SHT_name_len)
        ! splicer end function.explicit2
    end subroutine explicit2

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_scalar
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    !>
    !! \brief pass a single char argument as a scalar, extern "C"
    !!
    !<
    subroutine cpass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.cpass_char
        call c_cpass_char(status)
        ! splicer end function.cpass_char
    end subroutine cpass_char
#endif

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Attrs:     +intent(function)
    ! Exact:     f_function_char_scalar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char(SHT_rv)
        ! splicer end function.creturn_char
    end function creturn_char

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_char_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    ! ----------------------------------------
    ! Argument:  const char * src +blanknull
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_*_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_char_*_buf
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! extern "C"
    !! If src is a blank string, pass a NULL pointer to C library function.
    !<
    subroutine cpass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr
        integer(C_INT) SHT_dest_len
        integer(C_INT) SHT_src_len
        SHT_dest_len = len(dest, kind=C_INT)
        SHT_src_len = len(src, kind=C_INT)
        call c_cpass_char_ptr_bufferify(dest, SHT_dest_len, src, &
            SHT_src_len)
        ! splicer end function.cpass_char_ptr
    end subroutine cpass_char_ptr

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_char_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_*_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_char_*_buf
    !>
    !! \brief Test F_blanknull option
    !!
    !<
    subroutine cpass_char_ptr_blank(dest, src)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr_blank
        integer(C_INT) SHT_dest_len
        integer(C_INT) SHT_src_len
        SHT_dest_len = len(dest, kind=C_INT)
        SHT_src_len = len(src, kind=C_INT)
        call c_cpass_char_ptr_blank_bufferify(dest, SHT_dest_len, src, &
            SHT_src_len)
        ! splicer end function.cpass_char_ptr_blank
    end subroutine cpass_char_ptr_blank

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_*
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name
    ! Attrs:     +intent(inout)
    ! Exact:     f_inout_string_&_buf
    ! Attrs:     +api(buf)+intent(inout)
    ! Exact:     c_inout_string_&_buf
    !>
    !! Test post_declare.
    !! The std::string in py_string_inout must be declared before the
    !! goto added by py_native_*_in_pointer_list to avoid
    !! "jump to label 'fail' crosses initialization of" error.
    !<
    subroutine post_declare(count, name)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(IN) :: count(:)
        character(len=*), intent(INOUT) :: name
        ! splicer begin function.post_declare
        integer(C_INT) SHT_name_len
        SHT_name_len = len(name, kind=C_INT)
        call c_post_declare_bufferify(count, name, SHT_name_len)
        ! splicer end function.post_declare
    end subroutine post_declare

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_*_buf
    ! Attrs:     +api(buf)+intent(in)
    ! Exact:     c_in_char_*_buf
    !>
    !! \brief NULL terminate input string in C, not in Fortran.
    !!
    !<
    function cpass_char_ptr_notrim(src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_notrim
        integer(C_INT) SHT_src_len
        SHT_src_len = len(src, kind=C_INT)
        SHT_rv = c_cpass_char_ptr_notrim_bufferify(src, SHT_src_len)
        ! splicer end function.cpass_char_ptr_notrim
    end function cpass_char_ptr_notrim

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  void * addr +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_void_*
    ! Attrs:     +intent(in)
    ! Requested: c_in_void_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: f_in_char_*_capi
    ! Match:     f_default
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    !>
    !! \brief Do not NULL terminate input string
    !!
    !! The C library function should get the same address
    !! for addr and src.
    !! Used when the C function needs the true address of the argument.
    !! Skips null-termination. Useful to create an interface for
    !! a function which is already callable by Fortran.
    !! For example, the length is passed explicitly.
    !! This example will not create a Fortran wrapper since C can be
    !! called directly.
    !<
    function cpass_char_ptr_capi(addr, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        type(C_PTR), intent(IN) :: addr
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi
        SHT_rv = c_cpass_char_ptr_capi(addr, src)
        ! splicer end function.cpass_char_ptr_capi
    end function cpass_char_ptr_capi
#endif

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: f_in_char_*_capi
    ! Match:     f_default
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    !>
    !! \brief Mix api(buf) and api(capi)
    !!
    !<
    function cpass_char_ptr_capi2(in, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(IN) :: in
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi2
        SHT_rv = c_cpass_char_ptr_capi2(trim(in)//C_NULL_CHAR, src)
        ! splicer end function.cpass_char_ptr_capi2
    end function cpass_char_ptr_capi2

    ! splicer begin additional_functions
    ! splicer end additional_functions

    ! helper pointer_string
    ! Assign context to an assumed-length character pointer
    subroutine STR_SHROUD_pointer_string(context, var)
        use iso_c_binding, only : c_f_pointer, C_PTR
        implicit none
        type(STR_SHROUD_array), intent(IN) :: context
        character(len=:), pointer, intent(OUT) :: var
        character(len=context%elem_len), pointer :: fptr
        call c_f_pointer(context%base_addr, fptr)
        var => fptr
    end subroutine STR_SHROUD_pointer_string

end module strings_mod

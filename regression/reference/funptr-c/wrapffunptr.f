! wrapffunptr.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2024, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
!>
!! \file wrapffunptr.f
!! \brief Shroud generated wrapper for funptr library
!<
! splicer begin file_top
! splicer end file_top
module funptr_mod
    use iso_c_binding, only : C_INT
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! typedef TypeID
    ! splicer begin typedef.TypeID
    integer, parameter :: type_id = C_INT
    ! splicer end typedef.TypeID

    abstract interface

        subroutine callback1_external_incr() bind(C)
            implicit none
        end subroutine callback1_external_incr

        subroutine callback1_incr() bind(C)
            implicit none
        end subroutine callback1_incr

        subroutine callback1_wrap_incr() bind(C)
            implicit none
        end subroutine callback1_wrap_incr

        function callback4_actor(ilow, nargs) bind(C)
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), intent(IN) :: ilow(*)
            integer(C_INT), value, intent(IN) :: nargs
            integer(C_INT) :: callback4_actor
        end function callback4_actor

        function callback_ptr_get() bind(C)
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: callback_ptr_get
        end function callback_ptr_get

        function custom_funptr(XX0arg, XX1arg) bind(C)
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), value :: XX0arg
            integer(C_INT), value :: XX1arg
            integer(C_INT) :: custom_funptr
        end function custom_funptr

        function get(arg0, arg1) bind(C)
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            real(C_DOUBLE), value :: arg0
            integer(C_INT), value :: arg1
            integer(C_INT) :: get
        end function get

        subroutine incrtype(i, j) bind(C)
            use iso_c_binding, only : C_INT
            import :: type_id
            implicit none
            integer(C_INT), value :: i
            integer(type_id), value :: j
        end subroutine incrtype

    end interface

    interface

        ! ----------------------------------------
        ! Function:  void callback1
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  void ( * incr)(void)
        ! Statement: f_in_procedure
        subroutine callback1(incr) &
                bind(C, name="callback1")
            import :: callback1_incr
            implicit none
            procedure(callback1_incr) :: incr
        end subroutine callback1

        ! ----------------------------------------
        ! Function:  void callback1_wrap
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  void ( * incr)(void)
        ! Statement: f_in_procedure
        subroutine c_callback1_wrap(incr) &
                bind(C, name="callback1_wrap")
            import :: callback1_wrap_incr
            implicit none
            procedure(callback1_wrap_incr) :: incr
        end subroutine c_callback1_wrap

        ! ----------------------------------------
        ! Function:  void callback1_external
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  void ( * incr)(void) +external
        ! Statement: f_in_procedure_external
        subroutine c_callback1_external(incr) &
                bind(C, name="callback1_external")
            import :: callback1_external_incr
            implicit none
            procedure(callback1_external_incr) :: incr
        end subroutine c_callback1_external

        ! ----------------------------------------
        ! Function:  void callback1_funptr
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  void ( * incr)(void) +funptr
        ! Statement: f_in_procedure_funptr
        ! start callback1_funptr
        subroutine callback1_funptr(incr) &
                bind(C, name="callback1_funptr")
            use iso_c_binding, only : C_FUNPTR
            implicit none
            type(C_FUNPTR), value :: incr
        end subroutine callback1_funptr
        ! end callback1_funptr

        ! ----------------------------------------
        ! Function:  void callback2
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  const char * name
        ! Statement: f_in_char*
        ! ----------------------------------------
        ! Argument:  int ival
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  incrtype incr
        ! Statement: f_in_procedure
        subroutine c_callback2(name, ival, incr) &
                bind(C, name="callback2")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: incrtype
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: ival
            procedure(incrtype) :: incr
        end subroutine c_callback2

        ! ----------------------------------------
        ! Function:  void callback2_external
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  const char * name
        ! Statement: f_in_char*
        ! ----------------------------------------
        ! Argument:  int ival
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  incrtype incr +external
        ! Statement: f_in_procedure
        subroutine c_callback2_external(name, ival, incr) &
                bind(C, name="callback2_external")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: incrtype
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: ival
            procedure(incrtype) :: incr
        end subroutine c_callback2_external

        ! ----------------------------------------
        ! Function:  void callback2_funptr
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  const char * name
        ! Statement: f_in_char*
        ! ----------------------------------------
        ! Argument:  int ival
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  incrtype incr +funptr
        ! Statement: f_in_procedure
        subroutine c_callback2_funptr(name, ival, incr) &
                bind(C, name="callback2_funptr")
            use iso_c_binding, only : C_CHAR, C_FUNPTR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: ival
            type(C_FUNPTR), value :: incr
        end subroutine c_callback2_funptr

        ! ----------------------------------------
        ! Function:  void callback3
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  int type
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  void * in +assumedtype+intent(in)
        ! Statement: f_in_void*
        ! ----------------------------------------
        ! Argument:  void ( * incr)(void) +funptr
        ! Statement: f_in_procedure_funptr
        subroutine callback3(type, in, incr) &
                bind(C, name="callback3")
            use iso_c_binding, only : C_FUNPTR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: type
            type(*) :: in
            type(C_FUNPTR), value :: incr
        end subroutine callback3

        ! ----------------------------------------
        ! Function:  int callback4
        ! Statement: f_function_native
        ! ----------------------------------------
        ! Argument:  int * ilow +intent(in)+rank(1)
        ! Statement: f_in_native*
        ! ----------------------------------------
        ! Argument:  int nargs +implied(size(ilow))
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  int ( * actor)(int * ilow +intent(in)+rank(1), int nargs +intent(in))
        ! Statement: f_in_procedure
        function c_callback4(ilow, nargs, actor) &
                result(SHT_rv) &
                bind(C, name="callback4")
            use iso_c_binding, only : C_INT
            import :: callback4_actor
            implicit none
            integer(C_INT), intent(IN) :: ilow(*)
            integer(C_INT), value, intent(IN) :: nargs
            procedure(callback4_actor) :: actor
            integer(C_INT) :: SHT_rv
        end function c_callback4

        ! ----------------------------------------
        ! Function:  void callback_ptr
        ! Statement: f_subroutine
        ! ----------------------------------------
        ! Argument:  int * ( * get)(void)
        ! Statement: f_in_procedure
        subroutine callback_ptr(get) &
                bind(C, name="callback_ptr")
            import :: callback_ptr_get
            implicit none
            procedure(callback_ptr_get) :: get
        end subroutine callback_ptr

        ! ----------------------------------------
        ! Function:  int abstract1
        ! Statement: f_function_native
        ! ----------------------------------------
        ! Argument:  int input
        ! Statement: f_in_native
        ! ----------------------------------------
        ! Argument:  int ( * get)(double, int)
        ! Statement: f_in_procedure
        function c_abstract1(input, get) &
                result(SHT_rv) &
                bind(C, name="abstract1")
            use iso_c_binding, only : C_INT
            import :: custom_funptr
            implicit none
            integer(C_INT), value, intent(IN) :: input
            procedure(custom_funptr) :: get
            integer(C_INT) :: SHT_rv
        end function c_abstract1
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void callback1
    ! Statement: f_subroutine
    !>
    !! \brief Create abstract interface for function
    !!
    !<
    subroutine callback1(incr)
        procedure(callback1_incr) :: incr
        ! splicer begin function.callback1
        call c_callback1(incr)
        ! splicer end function.callback1
    end subroutine callback1
#endif

    ! ----------------------------------------
    ! Function:  void callback1_wrap
    ! Statement: f_subroutine
    !>
    !! \brief Create abstract interface for function
    !!
    !! Create a Fortran wrapper to call the bind(C) interface.
    !<
    subroutine callback1_wrap(incr)
        procedure(callback1_wrap_incr) :: incr
        ! splicer begin function.callback1_wrap
        call c_callback1_wrap(incr)
        ! splicer end function.callback1_wrap
    end subroutine callback1_wrap

    ! ----------------------------------------
    ! Function:  void callback1_external
    ! Statement: f_subroutine
    !>
    !! \brief Declare callback as external
    !!
    !<
    subroutine callback1_external(incr)
        external :: incr
        ! splicer begin function.callback1_external
        call c_callback1_external(incr)
        ! splicer end function.callback1_external
    end subroutine callback1_external

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void callback1_funptr
    ! Statement: f_subroutine
    !>
    !! \brief Declare callback as c_funptr
    !!
    !! The caller is responsible for using c_funloc to pass the function address.
    !<
    ! start callback1_funptr
    subroutine callback1_funptr(incr)
        use iso_c_binding, only : C_FUNPTR
        type(C_FUNPTR) :: incr
        ! splicer begin function.callback1_funptr
        call c_callback1_funptr(incr)
        ! splicer end function.callback1_funptr
    end subroutine callback1_funptr
    ! end callback1_funptr
#endif

    ! ----------------------------------------
    ! Function:  void callback2
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int ival
    ! Statement: f_in_native
    !>
    !! \brief Create abstract interface for function
    !!
    !<
    subroutine callback2(name, ival, incr)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(IN) :: name
        integer(C_INT), value, intent(IN) :: ival
        procedure(incrtype) :: incr
        ! splicer begin function.callback2
        call c_callback2(trim(name)//C_NULL_CHAR, ival, incr)
        ! splicer end function.callback2
    end subroutine callback2

    ! ----------------------------------------
    ! Function:  void callback2_external
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int ival
    ! Statement: f_in_native
    !>
    !! \brief Declare callback as external
    !!
    !<
    subroutine callback2_external(name, ival, incr)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(IN) :: name
        integer(C_INT), value, intent(IN) :: ival
        external :: incr
        ! splicer begin function.callback2_external
        call c_callback2_external(trim(name)//C_NULL_CHAR, ival, incr)
        ! splicer end function.callback2_external
    end subroutine callback2_external

    ! ----------------------------------------
    ! Function:  void callback2_funptr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int ival
    ! Statement: f_in_native
    !>
    !! \brief Declare callback as c_funptr
    !!
    !! The caller is responsible for using c_funloc to pass the function address.
    !! Allows any function to be passed as an argument.
    !<
    subroutine callback2_funptr(name, ival, incr)
        use iso_c_binding, only : C_FUNPTR, C_INT, C_NULL_CHAR
        character(len=*), intent(IN) :: name
        integer(C_INT), value, intent(IN) :: ival
        type(C_FUNPTR) :: incr
        ! splicer begin function.callback2_funptr
        call c_callback2_funptr(trim(name)//C_NULL_CHAR, ival, incr)
        ! splicer end function.callback2_funptr
    end subroutine callback2_funptr

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void callback3
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int type
    ! Statement: f_in_native
    !>
    !! \brief Test function pointer with assumedtype
    !!
    !<
    subroutine callback3(type, in, incr)
        use iso_c_binding, only : C_FUNPTR, C_INT
        integer(C_INT), value, intent(IN) :: type
        type(*) :: in
        type(C_FUNPTR) :: incr
        ! splicer begin function.callback3
        call c_callback3(type, in, incr)
        ! splicer end function.callback3
    end subroutine callback3
#endif

    ! ----------------------------------------
    ! Function:  int callback4
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  int * ilow +intent(in)+rank(1)
    ! Statement: f_in_native*
    !>
    !! \brief Test attributes on callback arguments
    !!
    !<
    function callback4(ilow, actor) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(IN) :: ilow(:)
        integer(C_INT) :: SH_nargs
        procedure(callback4_actor) :: actor
        integer(C_INT) :: SHT_rv
        ! splicer begin function.callback4
        SH_nargs = size(ilow,kind=C_INT)
        SHT_rv = c_callback4(ilow, SH_nargs, actor)
        ! splicer end function.callback4
    end function callback4

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void callback_ptr
    ! Statement: f_subroutine
    !>
    !! \brief Return a C_PTR
    !!
    !! No other arguments to test that a function result
    !! uses iso_c_binding C_PTR.
    !<
    subroutine callback_ptr(get)
        procedure(callback_ptr_get) :: get
        ! splicer begin function.callback_ptr
        call c_callback_ptr(get)
        ! splicer end function.callback_ptr
    end subroutine callback_ptr
#endif

    ! ----------------------------------------
    ! Function:  int abstract1
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  int input
    ! Statement: f_in_native
    !>
    !! \brief abstract argument
    !!
    !<
    function abstract1(input, get) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: input
        procedure(custom_funptr) :: get
        integer(C_INT) :: SHT_rv
        ! splicer begin function.abstract1
        SHT_rv = c_abstract1(input, get)
        ! splicer end function.abstract1
    end function abstract1

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module funptr_mod

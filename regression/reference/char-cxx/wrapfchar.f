! wrapfchar.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
#include "shroud/features.h"
!>
!! \file wrapfchar.f
!! \brief Shroud generated wrapper for char library
!<
! splicer begin file_top
! splicer end file_top
module char_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper type_defines
    ! Shroud type defines from helper type_defines
    integer, parameter, private :: &
        SH_TYPE_SIGNED_CHAR= 1, &
        SH_TYPE_SHORT      = 2, &
        SH_TYPE_INT        = 3, &
        SH_TYPE_LONG       = 4, &
        SH_TYPE_LONG_LONG  = 5, &
        SH_TYPE_SIZE_T     = 6, &
        SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &
        SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &
        SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &
        SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &
        SH_TYPE_INT8_T    =  7, &
        SH_TYPE_INT16_T   =  8, &
        SH_TYPE_INT32_T   =  9, &
        SH_TYPE_INT64_T   = 10, &
        SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &
        SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &
        SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &
        SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &
        SH_TYPE_FLOAT       = 22, &
        SH_TYPE_DOUBLE      = 23, &
        SH_TYPE_LONG_DOUBLE = 24, &
        SH_TYPE_FLOAT_COMPLEX      = 25, &
        SH_TYPE_DOUBLE_COMPLEX     = 26, &
        SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &
        SH_TYPE_BOOL      = 28, &
        SH_TYPE_CHAR      = 29, &
        SH_TYPE_CPTR      = 30, &
        SH_TYPE_STRUCT    = 31, &
        SH_TYPE_OTHER     = 32

    ! start helper array_context
    ! helper array_context
    type, bind(C) :: CHA_SHROUD_array
        ! address of data
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type CHA_SHROUD_array
    ! end helper array_context

    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    interface
        subroutine init_test() &
                bind(C, name="CHA_init_test")
            implicit none
        end subroutine init_test
    end interface

    ! ----------------------------------------
    ! Function:  void passChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine pass_char(status) &
                bind(C, name="CHA_passChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine pass_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine c_pass_char_force(status) &
                bind(C, name="CHA_passCharForce")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine c_pass_char_force
    end interface

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Statement: f_function_char
    interface
        subroutine c_return_char(SHT_rv) &
                bind(C, name="CHA_returnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_return_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +charlen(40)+intent(out)
    ! Statement: c_out_char*
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: c_in_char*
    ! start c_pass_char_ptr
    interface
        subroutine c_pass_char_ptr(dest, src) &
                bind(C, name="CHA_passCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr
    end interface
    ! end c_pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +charlen(40)+intent(out)
    ! Statement: f_out_char*_buf
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*
    ! start c_pass_char_ptr_bufferify
    interface
        subroutine c_pass_char_ptr_bufferify(dest, SHT_dest_len, src) &
                bind(C, name="CHA_passCharPtr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: SHT_dest_len
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr_bufferify
    end interface
    ! end c_pass_char_ptr_bufferify

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *s +intent(inout)
    ! Statement: c_inout_char*
    interface
        subroutine c_pass_char_ptr_in_out(s) &
                bind(C, name="CHA_passCharPtrInOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
        end subroutine c_pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *s +intent(inout)
    ! Statement: f_inout_char*_buf
    interface
        subroutine c_pass_char_ptr_in_out_bufferify(s, SHT_s_len) &
                bind(C, name="CHA_passCharPtrInOut_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
            integer(C_INT), value, intent(IN) :: SHT_s_len
        end subroutine c_pass_char_ptr_in_out_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const char *getCharPtr1
    ! Statement: c_function_char*
    ! start c_get_char_ptr1
    interface
        function c_get_char_ptr1() &
                result(SHT_rv) &
                bind(C, name="CHA_getCharPtr1")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_char_ptr1
    end interface
    ! end c_get_char_ptr1

    ! ----------------------------------------
    ! Function:  const char *getCharPtr1
    ! Statement: f_function_char*_cdesc_allocatable
    ! start c_get_char_ptr1_bufferify
    interface
        subroutine c_get_char_ptr1_bufferify(SHT_rv_cdesc) &
                bind(C, name="CHA_getCharPtr1_bufferify")
            import :: CHA_SHROUD_array
            implicit none
            type(CHA_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
        end subroutine c_get_char_ptr1_bufferify
    end interface
    ! end c_get_char_ptr1_bufferify

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrLen +len(30)
    ! Statement: c_function_char*
    ! start c_get_const_char_ptr_len
    interface
        function c_get_const_char_ptr_len() &
                result(SHT_rv) &
                bind(C, name="CHA_getConstCharPtrLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_char_ptr_len
    end interface
    ! end c_get_const_char_ptr_len

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrLen +len(30)
    ! Statement: f_function_char*_buf_copy
    ! start c_get_const_char_ptr_len_bufferify
    interface
        subroutine c_get_const_char_ptr_len_bufferify(SHT_rv, &
                SHT_rv_len) &
                bind(C, name="CHA_getConstCharPtrLen_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv(*)
            integer(C_INT), value, intent(IN) :: SHT_rv_len
        end subroutine c_get_const_char_ptr_len_bufferify
    end interface
    ! end c_get_const_char_ptr_len_bufferify

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrAsArg
    ! Statement: c_function_char*
    ! start c_get_const_char_ptr_as_arg
    interface
        function c_get_const_char_ptr_as_arg() &
                result(SHT_rv) &
                bind(C, name="CHA_getConstCharPtrAsArg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_char_ptr_as_arg
    end interface
    ! end c_get_const_char_ptr_as_arg

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrAsArg
    ! Statement: f_function_char*_buf_arg
    ! start c_get_const_char_ptr_as_arg_bufferify
    interface
        subroutine c_get_const_char_ptr_as_arg_bufferify(output, &
                noutput) &
                bind(C, name="CHA_getConstCharPtrAsArg_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: output(*)
            integer(C_INT), value, intent(IN) :: noutput
        end subroutine c_get_const_char_ptr_as_arg_bufferify
    end interface
    ! end c_get_const_char_ptr_as_arg_bufferify

    ! ----------------------------------------
    ! Function:  const char *getCharPtr4 +deref(raw)
    ! Statement: f_function_char*_raw
    interface
        function get_char_ptr4() &
                result(SHT_rv) &
                bind(C, name="CHA_getCharPtr4")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function get_char_ptr4
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char *getCharPtr5 +deref(pointer)
    ! Statement: c_function_char*
    interface
        function c_get_char_ptr5() &
                result(SHT_rv) &
                bind(C, name="CHA_getCharPtr5")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_char_ptr5
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char *getCharPtr5 +deref(pointer)
    ! Statement: f_function_char*_cdesc_pointer
    interface
        subroutine c_get_char_ptr5_bufferify(SHT_rv_cdesc) &
                bind(C, name="CHA_getCharPtr5_bufferify")
            import :: CHA_SHROUD_array
            implicit none
            type(CHA_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
        end subroutine c_get_char_ptr5_bufferify
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(in)+len_trim(AAlen)
    ! Statement: f_in_char*
    interface
        subroutine c_explicit1(name) &
                bind(C, name="CHA_explicit1")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
        end subroutine c_explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(out)+len(AAtrim)
    ! Statement: c_out_char*
    interface
        subroutine c_explicit2(name) &
                bind(C, name="CHA_explicit2")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
        end subroutine c_explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(out)+len(AAtrim)
    ! Statement: f_out_char*_buf
    interface
        subroutine c_explicit2_bufferify(name, SHT_name_len) &
                bind(C, name="CHA_explicit2_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
        end subroutine c_explicit2_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine cpass_char(status) &
                bind(C, name="CHA_CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    interface
        subroutine c_creturn_char(SHT_rv) &
                bind(C, name="CHA_CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: c_out_char*
    ! ----------------------------------------
    ! Argument:  const char *src +blanknull
    ! Statement: c_in_char*
    interface
        subroutine c_cpass_char_ptr(dest, src) &
                bind(C, name="CpassCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_buf
    ! ----------------------------------------
    ! Argument:  const char *src +blanknull
    ! Statement: f_in_char*_buf
    interface
        subroutine c_cpass_char_ptr_bufferify(dest, SHT_dest_len, src, &
                SHT_src_len) &
                bind(C, name="CHA_CpassCharPtr_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: SHT_dest_len
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: SHT_src_len
        end subroutine c_cpass_char_ptr_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: c_out_char*
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: c_in_char*
    interface
        subroutine c_cpass_char_ptr_blank(dest, src) &
                bind(C, name="CHA_CpassCharPtrBlank")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr_blank
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_buf
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_buf
    interface
        subroutine c_cpass_char_ptr_blank_bufferify(dest, SHT_dest_len, &
                src, SHT_src_len) &
                bind(C, name="CHA_CpassCharPtrBlank_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            integer(C_INT), value, intent(IN) :: SHT_dest_len
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: SHT_src_len
        end subroutine c_cpass_char_ptr_blank_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Statement: c_function_native
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: c_in_char*
    interface
        function c_cpass_char_ptr_notrim(src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrNotrim")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_notrim
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_buf
    interface
        function c_cpass_char_ptr_notrim_bufferify(src, SHT_src_len) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrNotrim_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT), value, intent(IN) :: SHT_src_len
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_notrim_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  void *addr
    ! Statement: f_in_void*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    interface
        function cpass_char_ptr_capi(addr, src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrCAPI")
            use iso_c_binding, only : C_CHAR, C_INT, C_PTR
            implicit none
            type(C_PTR), value, intent(IN) :: addr
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_capi
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *in
    ! Statement: f_in_char*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    interface
        function c_cpass_char_ptr_capi2(in, src) &
                result(SHT_rv) &
                bind(C, name="CHA_CpassCharPtrCAPI2")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: in(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_capi2
    end interface

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine CHA_SHROUD_copy_string(context, c_var, c_var_size) &
             bind(c,name="CHA_ShroudCopyString")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import CHA_SHROUD_array
            type(CHA_SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine CHA_SHROUD_copy_string
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    subroutine init_test()
        ! splicer begin function.init_test
        call c_init_test()
        ! splicer end function.init_test
    end subroutine init_test
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void passChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! \brief pass a single char argument as a scalar.
    !!
    !<
    subroutine pass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char
        call c_pass_char(status)
        ! splicer end function.pass_char
    end subroutine pass_char
#endif

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! By default no Fortran wrapper is created.
    !! Force one so it can be tested.
    !<
    subroutine pass_char_force(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char_force
        call c_pass_char_force(status)
        ! splicer end function.pass_char_force
    end subroutine pass_char_force

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Statement: f_function_char
    !>
    !! \brief return a char argument (non-pointer)
    !!
    !<
    function return_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.return_char
        call c_return_char(SHT_rv)
        ! splicer end function.return_char
    end function return_char

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +charlen(40)+intent(out)
    ! Statement: f_out_char*_buf
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! In Python, src must not be over 40 characters, defined by charlen.
    !<
    ! start pass_char_ptr
    subroutine pass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.pass_char_ptr
        integer(C_INT) SHT_dest_len
        SHT_dest_len = len(dest, kind=C_INT)
        call c_pass_char_ptr_bufferify(dest, SHT_dest_len, &
            trim(src)//C_NULL_CHAR)
        ! splicer end function.pass_char_ptr
    end subroutine pass_char_ptr
    ! end pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *s +intent(inout)
    ! Statement: f_inout_char*_buf
    !>
    !! \brief toupper
    !!
    !! Change a string in-place.
    !! For Python, return a new string since strings are immutable.
    !<
    subroutine pass_char_ptr_in_out(s)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: s
        ! splicer begin function.pass_char_ptr_in_out
        integer(C_INT) SHT_s_len
        SHT_s_len = len(s, kind=C_INT)
        call c_pass_char_ptr_in_out_bufferify(s, SHT_s_len)
        ! splicer end function.pass_char_ptr_in_out
    end subroutine pass_char_ptr_in_out

    ! ----------------------------------------
    ! Function:  const char *getCharPtr1
    ! Statement: f_function_char*_cdesc_allocatable
    !>
    !! Return an ALLOCATABLE CHARACTER from char *.
    !<
    ! start get_char_ptr1
    function get_char_ptr1() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_char_ptr1
        type(CHA_SHROUD_array) :: SHT_rv_cdesc
        call c_get_char_ptr1_bufferify(SHT_rv_cdesc)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call CHA_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        ! splicer end function.get_char_ptr1
    end function get_char_ptr1
    ! end get_char_ptr1

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrLen +len(30)
    ! Statement: f_function_char*_buf_copy
    !>
    !! \brief return 'const char *' with fixed size (len=30)
    !!
    !<
    ! start get_const_char_ptr_len
    function get_const_char_ptr_len() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_char_ptr_len
        integer(C_INT) SHT_rv_len
        SHT_rv_len = len(SHT_rv, kind=C_INT)
        call c_get_const_char_ptr_len_bufferify(SHT_rv, SHT_rv_len)
        ! splicer end function.get_const_char_ptr_len
    end function get_const_char_ptr_len
    ! end get_const_char_ptr_len

    ! ----------------------------------------
    ! Function:  const char *getConstCharPtrAsArg
    ! Statement: f_function_char*_buf_arg
    !>
    !! \brief return a 'const char *' as argument
    !!
    !<
    ! start get_const_char_ptr_as_arg
    subroutine get_const_char_ptr_as_arg(output)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_char_ptr_as_arg
        integer(C_INT) noutput
        noutput = len(output, kind=C_INT)
        call c_get_const_char_ptr_as_arg_bufferify(output, noutput)
        ! splicer end function.get_const_char_ptr_as_arg
    end subroutine get_const_char_ptr_as_arg
    ! end get_const_char_ptr_as_arg

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  const char *getCharPtr4 +deref(raw)
    ! Statement: f_function_char*_raw
    !>
    !! \brief return a 'const char *' as type(C_PTR)
    !!
    !<
    function get_char_ptr4() &
            result(SHT_rv)
        type(C_PTR) :: SHT_rv
        ! splicer begin function.get_char_ptr4
        SHT_rv = c_get_char_ptr4()
        ! splicer end function.get_char_ptr4
    end function get_char_ptr4
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char *getCharPtr5 +deref(pointer)
    ! Statement: f_function_char*_cdesc_pointer
    !>
    !! \brief return a 'const char *' as character(:) pointer
    !!
    !<
    function get_char_ptr5() &
            result(SHT_rv)
        use iso_c_binding, only : c_f_pointer
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_char_ptr5
        type(CHA_SHROUD_array) :: SHT_rv_cdesc
        call c_get_char_ptr5_bufferify(SHT_rv_cdesc)
        call CHA_SHROUD_pointer_string(SHT_rv_cdesc, SHT_rv)
        ! splicer end function.get_char_ptr5
    end function get_char_ptr5
#endif

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(in)+len_trim(AAlen)
    ! Statement: f_in_char*
    subroutine explicit1(name)
        use iso_c_binding, only : C_NULL_CHAR
        character(len=*), intent(IN) :: name
        ! splicer begin function.explicit1
        call c_explicit1(trim(name)//C_NULL_CHAR)
        ! splicer end function.explicit1
    end subroutine explicit1

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *name +intent(out)+len(AAtrim)
    ! Statement: f_out_char*_buf
    subroutine explicit2(name)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: name
        ! splicer begin function.explicit2
        integer(C_INT) SHT_name_len
        SHT_name_len = len(name, kind=C_INT)
        call c_explicit2_bufferify(name, SHT_name_len)
        ! splicer end function.explicit2
    end subroutine explicit2

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! \brief pass a single char argument as a scalar, extern "C"
    !!
    !<
    subroutine cpass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.cpass_char
        call c_cpass_char(status)
        ! splicer end function.cpass_char
    end subroutine cpass_char
#endif

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char(SHT_rv)
        ! splicer end function.creturn_char
    end function creturn_char

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_buf
    ! ----------------------------------------
    ! Argument:  const char *src +blanknull
    ! Statement: f_in_char*_buf
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! extern "C"
    !! If src is a blank string, pass a NULL pointer to C library function.
    !<
    subroutine cpass_char_ptr(dest, src)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr
        integer(C_INT) SHT_dest_len
        integer(C_INT) SHT_src_len
        SHT_dest_len = len(dest, kind=C_INT)
        SHT_src_len = len(src, kind=C_INT)
        call c_cpass_char_ptr_bufferify(dest, SHT_dest_len, src, &
            SHT_src_len)
        ! splicer end function.cpass_char_ptr
    end subroutine cpass_char_ptr

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char *dest +intent(out)
    ! Statement: f_out_char*_buf
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_buf
    !>
    !! \brief Test F_blanknull option
    !!
    !<
    subroutine cpass_char_ptr_blank(dest, src)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr_blank
        integer(C_INT) SHT_dest_len
        integer(C_INT) SHT_src_len
        SHT_dest_len = len(dest, kind=C_INT)
        SHT_src_len = len(src, kind=C_INT)
        call c_cpass_char_ptr_blank_bufferify(dest, SHT_dest_len, src, &
            SHT_src_len)
        ! splicer end function.cpass_char_ptr_blank
    end subroutine cpass_char_ptr_blank

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *src
    ! Statement: f_in_char*_buf
    !>
    !! \brief NULL terminate input string in C, not in Fortran.
    !!
    !<
    function cpass_char_ptr_notrim(src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_notrim
        integer(C_INT) SHT_src_len
        SHT_src_len = len(src, kind=C_INT)
        SHT_rv = c_cpass_char_ptr_notrim_bufferify(src, SHT_src_len)
        ! splicer end function.cpass_char_ptr_notrim
    end function cpass_char_ptr_notrim

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  void *addr
    ! Statement: f_in_void*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    !>
    !! \brief Do not NULL terminate input string
    !!
    !! The C library function should get the same address
    !! for addr and src.
    !! Used when the C function needs the true address of the argument.
    !! Skips null-termination. Useful to create an interface for
    !! a function which is already callable by Fortran.
    !! For example, the length is passed explicitly.
    !! This example will not create a Fortran wrapper since C can be
    !! called directly.
    !<
    function cpass_char_ptr_capi(addr, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        type(C_PTR), intent(IN) :: addr
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi
        SHT_rv = c_cpass_char_ptr_capi(addr, src)
        ! splicer end function.cpass_char_ptr_capi
    end function cpass_char_ptr_capi
#endif

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  const char *in
    ! Statement: f_in_char*
    ! ----------------------------------------
    ! Argument:  const char *src +api(capi)
    ! Statement: f_in_char*_capi
    !>
    !! \brief Mix api(buf) and api(capi)
    !!
    !<
    function cpass_char_ptr_capi2(in, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_NULL_CHAR
        character(len=*), intent(IN) :: in
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi2
        SHT_rv = c_cpass_char_ptr_capi2(trim(in)//C_NULL_CHAR, src)
        ! splicer end function.cpass_char_ptr_capi2
    end function cpass_char_ptr_capi2

    ! splicer begin additional_functions
    ! splicer end additional_functions

    ! helper pointer_string
    ! Assign context to an assumed-length character pointer
    subroutine CHA_SHROUD_pointer_string(context, var)
        use iso_c_binding, only : c_f_pointer, C_PTR
        implicit none
        type(CHA_SHROUD_array), intent(IN) :: context
        character(len=:), pointer, intent(OUT) :: var
        character(len=context%elem_len), pointer :: fptr
        call c_f_pointer(context%base_addr, fptr)
        var => fptr
    end subroutine CHA_SHROUD_pointer_string

end module char_mod

// wrapchar.cpp
// This file is generated by Shroud nowrite-version. Do not edit.
// Copyright (c) 2017-2024, Lawrence Livermore National Security, LLC and
// other Shroud Project Developers.
// See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)
//

// cxx_header
#include "char.h"
#include "shroud/features.h"
// shroud
#include <cstdlib>
#include <cstring>
#include "wrapchar.h"

// splicer begin CXX_definitions
// splicer end CXX_definitions

extern "C" {


// helper char_len_trim
// Returns the length of character string src with length nsrc,
// ignoring any trailing blanks.
static int ShroudCharLenTrim(const char *src, int nsrc) {
    int i;

    for (i = nsrc - 1; i >= 0; i--) {
        if (src[i] != ' ') {
            break;
        }
    }

    return i + 1;
}


// helper char_alloc
// Copy src into new memory and null terminate.
// If ntrim is 0, return NULL pointer.
// If blanknull is 1, return NULL when string is blank.
static char *ShroudCharAlloc(const char *src, int nsrc, int blanknull)
{
    int ntrim = ShroudCharLenTrim(src, nsrc);
    if (ntrim == 0 && blanknull == 1) {
        return nullptr;
    }
    char *rv = (char *) std::malloc(nsrc + 1);
    if (ntrim > 0) {
        std::memcpy(rv, src, ntrim);
    }
    rv[ntrim] = '\0';
    return rv;
}

// helper char_blank_fill
// blank fill dest starting at trailing NULL.
static void ShroudCharBlankFill(char *dest, int ndest)
{
    int nm = std::strlen(dest);
    if(ndest > nm) std::memset(dest+nm,' ',ndest-nm);
}

// helper ShroudCharCopy
// Copy src into dest, blank fill to ndest characters
// Truncate if dest is too short.
// dest will not be NULL terminated.
static void ShroudCharCopy(char *dest, int ndest, const char *src, int nsrc)
{
    if (src == NULL) {
        std::memset(dest,' ',ndest); // convert NULL pointer to blank filled string
    } else {
        if (nsrc < 0) nsrc = std::strlen(src);
        int nm = nsrc < ndest ? nsrc : ndest;
        std::memcpy(dest,src,nm);
        if(ndest > nm) std::memset(dest+nm,' ',ndest-nm); // blank fill
    }
}

// helper char_free
// Release memory allocated by ShroudCharAlloc
static void ShroudCharFree(char *src)
{
    if (src != NULL) {
        std::free(src);
    }
}

// splicer begin C_definitions
// splicer end C_definitions

// ----------------------------------------
// Function:  void init_test
// Statement: c_subroutine
void CHA_init_test(void)
{
    // splicer begin function.init_test
    init_test();
    // splicer end function.init_test
}

/**
 * \brief pass a single char argument as a scalar.
 *
 */
// ----------------------------------------
// Function:  void passChar
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
void CHA_passChar(char status)
{
    // splicer begin function.passChar
    passChar(status);
    // splicer end function.passChar
}

/**
 * By default no Fortran wrapper is created.
 * Force one so it can be tested.
 */
// ----------------------------------------
// Function:  void passCharForce
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
void CHA_passCharForce(char status)
{
    // splicer begin function.passCharForce
    passCharForce(status);
    // splicer end function.passCharForce
}

/**
 * \brief return a char argument (non-pointer)
 *
 */
// ----------------------------------------
// Function:  char returnChar
// Statement: c_function_char
void CHA_returnChar(char *SHC_rv)
{
    // splicer begin function.returnChar
    *SHC_rv = returnChar();
    // splicer end function.returnChar
}

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * In Python, src must not be over 40 characters, defined by charlen.
 */
// ----------------------------------------
// Function:  void passCharPtr
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *dest +charlen(40)+intent(out)
// Statement: c_out_char*
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_passCharPtr
void CHA_passCharPtr(char *dest, const char *src)
{
    // splicer begin function.passCharPtr
    passCharPtr(dest, src);
    // splicer end function.passCharPtr
}
// end CHA_passCharPtr

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * In Python, src must not be over 40 characters, defined by charlen.
 */
// ----------------------------------------
// Function:  void passCharPtr
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +charlen(40)+intent(out)
// Statement: f_out_char*_buf
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*
// start CHA_passCharPtr_bufferify
void CHA_passCharPtr_bufferify(char *dest, int SHT_dest_len,
    const char *src)
{
    // splicer begin function.passCharPtr_bufferify
    passCharPtr(dest, src);
    ShroudCharBlankFill(dest, SHT_dest_len);
    // splicer end function.passCharPtr_bufferify
}
// end CHA_passCharPtr_bufferify

/**
 * \brief toupper
 *
 * Change a string in-place.
 * For Python, return a new string since strings are immutable.
 */
// ----------------------------------------
// Function:  void passCharPtrInOut
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *s +intent(inout)
// Statement: c_inout_char*
void CHA_passCharPtrInOut(char *s)
{
    // splicer begin function.passCharPtrInOut
    passCharPtrInOut(s);
    // splicer end function.passCharPtrInOut
}

/**
 * \brief toupper
 *
 * Change a string in-place.
 * For Python, return a new string since strings are immutable.
 */
// ----------------------------------------
// Function:  void passCharPtrInOut
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *s +intent(inout)
// Statement: f_inout_char*_buf
void CHA_passCharPtrInOut_bufferify(char *s, int SHT_s_len)
{
    // splicer begin function.passCharPtrInOut_bufferify
    char * SHT_s_str = ShroudCharAlloc(s, SHT_s_len, 0);
    passCharPtrInOut(SHT_s_str);
    ShroudCharCopy(s, SHT_s_len, SHT_s_str, -1);
    ShroudCharFree(SHT_s_str);
    // splicer end function.passCharPtrInOut_bufferify
}

/**
 * Return an ALLOCATABLE CHARACTER from char *.
 */
// ----------------------------------------
// Function:  const char *getCharPtr1
// Statement: c_function_char*
// start CHA_getCharPtr1
const char * CHA_getCharPtr1(void)
{
    // splicer begin function.getCharPtr1
    const char *SHC_rv = getCharPtr1();
    return SHC_rv;
    // splicer end function.getCharPtr1
}
// end CHA_getCharPtr1

/**
 * Return an ALLOCATABLE CHARACTER from char *.
 */
// ----------------------------------------
// Function:  const char *getCharPtr1
// Statement: f_function_char*_cdesc_allocatable
// start CHA_getCharPtr1_bufferify
void CHA_getCharPtr1_bufferify(CHA_SHROUD_array *SHT_rv_cdesc)
{
    // splicer begin function.getCharPtr1_bufferify
    const char *SHC_rv = getCharPtr1();
    SHT_rv_cdesc->base_addr = const_cast<char *>(SHC_rv);
    SHT_rv_cdesc->type = SH_TYPE_OTHER;
    SHT_rv_cdesc->elem_len = SHC_rv == nullptr ? 0 : std::strlen(SHC_rv);
    SHT_rv_cdesc->size = 1;
    SHT_rv_cdesc->rank = 0;
    // splicer end function.getCharPtr1_bufferify
}
// end CHA_getCharPtr1_bufferify

/**
 * \brief return 'const char *' with fixed size (len=30)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrLen +len(30)
// Statement: c_function_char*
// start CHA_getConstCharPtrLen
const char * CHA_getConstCharPtrLen(void)
{
    // splicer begin function.getConstCharPtrLen
    const char *SHC_rv = getConstCharPtrLen();
    return SHC_rv;
    // splicer end function.getConstCharPtrLen
}
// end CHA_getConstCharPtrLen

/**
 * \brief return 'const char *' with fixed size (len=30)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrLen +len(30)
// Statement: f_function_char*_buf_copy
// start CHA_getConstCharPtrLen_bufferify
void CHA_getConstCharPtrLen_bufferify(char *SHC_rv, int SHT_rv_len)
{
    // splicer begin function.getConstCharPtrLen_bufferify
    const char *SHC_rv_cxx = getConstCharPtrLen();
    ShroudCharCopy(SHC_rv, SHT_rv_len, SHC_rv_cxx, -1);
    // splicer end function.getConstCharPtrLen_bufferify
}
// end CHA_getConstCharPtrLen_bufferify

/**
 * \brief return a 'const char *' as argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsArg
// Statement: c_function_char*
// start CHA_getConstCharPtrAsArg
const char * CHA_getConstCharPtrAsArg(void)
{
    // splicer begin function.getConstCharPtrAsArg
    const char *SHC_rv = getConstCharPtrAsArg();
    return SHC_rv;
    // splicer end function.getConstCharPtrAsArg
}
// end CHA_getConstCharPtrAsArg

/**
 * \brief return a 'const char *' as argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsArg
// Statement: f_function_char*_buf_arg
// start CHA_getConstCharPtrAsArg_bufferify
void CHA_getConstCharPtrAsArg_bufferify(char *output, int noutput)
{
    // splicer begin function.getConstCharPtrAsArg_bufferify
    const char *SHC_rv_cxx = getConstCharPtrAsArg();
    ShroudCharCopy(output, noutput, SHC_rv_cxx, -1);
    // splicer end function.getConstCharPtrAsArg_bufferify
}
// end CHA_getConstCharPtrAsArg_bufferify

/**
 * \brief return a 'const char *' as type(C_PTR)
 *
 */
// ----------------------------------------
// Function:  const char *getCharPtr4 +deref(raw)
// Statement: c_function_char*
const char * CHA_getCharPtr4(void)
{
    // splicer begin function.getCharPtr4
    const char *SHC_rv = getCharPtr4();
    return SHC_rv;
    // splicer end function.getCharPtr4
}

/**
 * \brief return a 'const char *' as character(:) pointer
 *
 */
#ifdef HAVE_CHARACTER_POINTER_FUNCTION
// ----------------------------------------
// Function:  const char *getCharPtr5 +deref(pointer)
// Statement: c_function_char*
const char * CHA_getCharPtr5(void)
{
    // splicer begin function.getCharPtr5
    const char *SHC_rv = getCharPtr5();
    return SHC_rv;
    // splicer end function.getCharPtr5
}
#endif  // ifdef HAVE_CHARACTER_POINTER_FUNCTION

/**
 * \brief return a 'const char *' as character(:) pointer
 *
 */
#ifdef HAVE_CHARACTER_POINTER_FUNCTION
// ----------------------------------------
// Function:  const char *getCharPtr5 +deref(pointer)
// Statement: f_function_char*_cdesc_pointer
void CHA_getCharPtr5_bufferify(CHA_SHROUD_array *SHT_rv_cdesc)
{
    // splicer begin function.getCharPtr5_bufferify
    const char *SHC_rv = getCharPtr5();
    SHT_rv_cdesc->base_addr = const_cast<char *>(SHC_rv);
    SHT_rv_cdesc->type = SH_TYPE_OTHER;
    SHT_rv_cdesc->elem_len = SHC_rv == nullptr ? 0 : std::strlen(SHC_rv);
    SHT_rv_cdesc->size = 1;
    SHT_rv_cdesc->rank = 0;
    // splicer end function.getCharPtr5_bufferify
}
#endif  // ifdef HAVE_CHARACTER_POINTER_FUNCTION

// ----------------------------------------
// Function:  void explicit1
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *name +intent(in)+len_trim(AAlen)
// Statement: c_in_char*
void CHA_explicit1(char *name)
{
    // splicer begin function.explicit1
    explicit1(name);
    // splicer end function.explicit1
}

// ----------------------------------------
// Function:  void explicit2
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *name +intent(out)+len(AAtrim)
// Statement: c_out_char*
void CHA_explicit2(char *name)
{
    // splicer begin function.explicit2
    explicit2(name);
    // splicer end function.explicit2
}

// ----------------------------------------
// Function:  void explicit2
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *name +intent(out)+len(AAtrim)
// Statement: f_out_char*_buf
void CHA_explicit2_bufferify(char *name, int SHT_name_len)
{
    // splicer begin function.explicit2_bufferify
    explicit2(name);
    ShroudCharBlankFill(name, SHT_name_len);
    // splicer end function.explicit2_bufferify
}

/**
 * \brief pass a single char argument as a scalar, extern "C"
 *
 */
// ----------------------------------------
// Function:  void CpassChar
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
void CHA_CpassChar(char status)
{
    // splicer begin function.CpassChar
    CpassChar(status);
    // splicer end function.CpassChar
}

/**
 * \brief return a char argument (non-pointer), extern "C"
 *
 */
// ----------------------------------------
// Function:  char CreturnChar
// Statement: c_function_char
void CHA_CreturnChar(char *SHC_rv)
{
    // splicer begin function.CreturnChar
    *SHC_rv = CreturnChar();
    // splicer end function.CreturnChar
}

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * extern "C"
 * If src is a blank string, pass a NULL pointer to C library function.
 */
// ----------------------------------------
// Function:  void CpassCharPtr
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: f_out_char*_buf
// ----------------------------------------
// Argument:  const char *src +blanknull
// Statement: f_in_char*_buf
void CHA_CpassCharPtr_bufferify(char *dest, int SHT_dest_len, char *src,
    int SHT_src_len)
{
    // splicer begin function.CpassCharPtr_bufferify
    char * SHT_src_str = ShroudCharAlloc(src, SHT_src_len, 1);
    CpassCharPtr(dest, SHT_src_str);
    ShroudCharBlankFill(dest, SHT_dest_len);
    ShroudCharFree(SHT_src_str);
    // splicer end function.CpassCharPtr_bufferify
}

/**
 * \brief Test F_blanknull option
 *
 */
// ----------------------------------------
// Function:  void CpassCharPtrBlank
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: c_out_char*
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
void CHA_CpassCharPtrBlank(char *dest, const char *src)
{
    // splicer begin function.CpassCharPtrBlank
    CpassCharPtrBlank(dest, src);
    // splicer end function.CpassCharPtrBlank
}

/**
 * \brief Test F_blanknull option
 *
 */
// ----------------------------------------
// Function:  void CpassCharPtrBlank
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: f_out_char*_buf
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_buf
void CHA_CpassCharPtrBlank_bufferify(char *dest, int SHT_dest_len,
    char *src, int SHT_src_len)
{
    // splicer begin function.CpassCharPtrBlank_bufferify
    char * SHT_src_str = ShroudCharAlloc(src, SHT_src_len, 1);
    CpassCharPtrBlank(dest, SHT_src_str);
    ShroudCharBlankFill(dest, SHT_dest_len);
    ShroudCharFree(SHT_src_str);
    // splicer end function.CpassCharPtrBlank_bufferify
}

/**
 * \brief NULL terminate input string in C, not in Fortran.
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrNotrim
// Statement: c_function_native
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
int CHA_CpassCharPtrNotrim(const char *src)
{
    // splicer begin function.CpassCharPtrNotrim
    int SHC_rv = CpassCharPtrNotrim(src);
    return SHC_rv;
    // splicer end function.CpassCharPtrNotrim
}

/**
 * \brief NULL terminate input string in C, not in Fortran.
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrNotrim
// Statement: f_function_native
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_buf
int CHA_CpassCharPtrNotrim_bufferify(char *src, int SHT_src_len)
{
    // splicer begin function.CpassCharPtrNotrim_bufferify
    char * SHT_src_str = ShroudCharAlloc(src, SHT_src_len, 0);
    int SHC_rv = CpassCharPtrNotrim(SHT_src_str);
    ShroudCharFree(SHT_src_str);
    return SHC_rv;
    // splicer end function.CpassCharPtrNotrim_bufferify
}

/**
 * \brief Do not NULL terminate input string
 *
 * The C library function should get the same address
 * for addr and src.
 * Used when the C function needs the true address of the argument.
 * Skips null-termination. Useful to create an interface for
 * a function which is already callable by Fortran.
 * For example, the length is passed explicitly.
 * This example will not create a Fortran wrapper since C can be
 * called directly.
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI
// Statement: c_function_native
// ----------------------------------------
// Argument:  void *addr
// Statement: c_in_void*
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: c_in_char*
int CHA_CpassCharPtrCAPI(void *addr, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI
    int SHC_rv = CpassCharPtrCAPI(addr, src);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI
}

/**
 * \brief Mix api(buf) and api(capi)
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI2
// Statement: c_function_native
// ----------------------------------------
// Argument:  const char *in
// Statement: c_in_char*
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: c_in_char*
int CHA_CpassCharPtrCAPI2(const char *in, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI2
    int SHC_rv = CpassCharPtrCAPI2(in, src);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI2
}

}  // extern "C"

// wrapchar.cpp
// This file is generated by Shroud nowrite-version. Do not edit.
// Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
// other Shroud Project Developers.
// See the top-level COPYRIGHT file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)
//

// cxx_header
#include "char.h"
#include "shroud/features.h"
// shroud
#include <cstdlib>
#include <cstring>
#include "wrapchar.h"

// splicer begin CXX_definitions
// splicer end CXX_definitions

extern "C" {


// helper char_len_trim
// Returns the length of character string src with length nsrc,
// ignoring any trailing blanks.
static int ShroudCharLenTrim(const char *src, int nsrc) {
    int i;

    for (i = nsrc - 1; i >= 0; i--) {
        if (src[i] != ' ') {
            break;
        }
    }

    return i + 1;
}


// helper char_alloc
// Copy src into new memory and null terminate.
// If ntrim is 0, return NULL pointer.
// If blanknull is 1, return NULL when string is blank.
static char *ShroudCharAlloc(const char *src, int nsrc, int blanknull)
{
    int ntrim = ShroudCharLenTrim(src, nsrc);
    if (ntrim == 0 && blanknull == 1) {
        return nullptr;
    }
    char *rv = (char *) std::malloc(nsrc + 1);
    if (ntrim > 0) {
        std::memcpy(rv, src, ntrim);
    }
    rv[ntrim] = '\0';
    return rv;
}

// start helper char_array_alloc
// helper char_array_alloc
// Copy src into new memory and null terminate.
// char **src +size(nsrc) +len(len)
// CHARACTER(len) src(nsrc)
static char **ShroudStrArrayAlloc(const char *src, int nsrc, int len)
{
    char **rv = static_cast<char **>
        (std::malloc(sizeof(char *) * nsrc));
    const char *src0 = src;
    for(int i=0; i < nsrc; ++i) {
        int ntrim = ShroudCharLenTrim(src0, len);
        char *tgt = static_cast<char *>(std::malloc(ntrim+1));
        std::memcpy(tgt, src0, ntrim);
        tgt[ntrim] = '\0';
        rv[i] = tgt;
        src0 += len;
    }
    return rv;
}
// end helper char_array_alloc

// helper char_array_free
// Release memory allocated by ShroudStrArrayAlloc
static void ShroudStrArrayFree(char **src, int nsrc)
{
    for(int i=0; i < nsrc; ++i) {
        std::free(src[i]);
    }
    std::free(src);
}

// helper char_blank_fill
// blank fill dest starting at trailing NULL.
static void ShroudCharBlankFill(char *dest, int ndest)
{
    int nm = std::strlen(dest);
    if(ndest > nm) std::memset(dest+nm,' ',ndest-nm);
}

// helper ShroudCharCopy
// Copy src into dest, blank fill to ndest characters
// Truncate if dest is too short.
// dest will not be NULL terminated.
static void ShroudCharCopy(char *dest, int ndest, const char *src, int nsrc)
{
    if (src == NULL) {
        std::memset(dest,' ',ndest); // convert NULL pointer to blank filled string
    } else {
        if (nsrc < 0) nsrc = std::strlen(src);
        int nm = nsrc < ndest ? nsrc : ndest;
        std::memcpy(dest,src,nm);
        if(ndest > nm) std::memset(dest+nm,' ',ndest-nm); // blank fill
    }
}

// helper char_free
// Release memory allocated by ShroudCharAlloc
static void ShroudCharFree(char *src)
{
    if (src != NULL) {
        std::free(src);
    }
}

// splicer begin C_definitions
// splicer end C_definitions

// ----------------------------------------
// Function:  void init_test
// Statement: c_subroutine
// start CHA_init_test
void CHA_init_test(void)
{
    // splicer begin function.init_test
    init_test();
    // splicer end function.init_test
}
// end CHA_init_test

/**
 * \brief pass a single char argument as a scalar.
 *
 */
// ----------------------------------------
// Function:  void passChar
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
// start CHA_passChar
void CHA_passChar(char status)
{
    // splicer begin function.passChar
    passChar(status);
    // splicer end function.passChar
}
// end CHA_passChar

/**
 * By default no Fortran wrapper is created.
 * Force one so it can be tested.
 */
// ----------------------------------------
// Function:  void passCharForce
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
// start CHA_passCharForce
void CHA_passCharForce(char status)
{
    // splicer begin function.passCharForce
    passCharForce(status);
    // splicer end function.passCharForce
}
// end CHA_passCharForce

/**
 * \brief return a char argument (non-pointer)
 *
 */
// ----------------------------------------
// Function:  char returnChar
// Statement: c_function_char
// start CHA_returnChar
void CHA_returnChar(char *SHC_rv)
{
    // splicer begin function.returnChar
    *SHC_rv = returnChar();
    // splicer end function.returnChar
}
// end CHA_returnChar

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * In Python, src must not be over 40 characters, defined by charlen.
 */
// ----------------------------------------
// Function:  void passCharPtr
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *dest +charlen(40)+intent(out)
// Statement: c_out_char*
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_passCharPtr
void CHA_passCharPtr(char *dest, const char *src)
{
    // splicer begin function.passCharPtr
    passCharPtr(dest, src);
    // splicer end function.passCharPtr
}
// end CHA_passCharPtr

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * In Python, src must not be over 40 characters, defined by charlen.
 */
// ----------------------------------------
// Function:  void passCharPtr
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +charlen(40)+intent(out)
// Statement: f_out_char*_buf
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*
// start CHA_passCharPtr_bufferify
void CHA_passCharPtr_bufferify(char *dest, int SHT_dest_len,
    const char *src)
{
    // splicer begin function.passCharPtr_bufferify
    passCharPtr(dest, src);
    ShroudCharBlankFill(dest, SHT_dest_len);
    // splicer end function.passCharPtr_bufferify
}
// end CHA_passCharPtr_bufferify

/**
 * \brief toupper
 *
 * Change a string in-place.
 * For Python, return a new string since strings are immutable.
 */
// ----------------------------------------
// Function:  void passCharPtrInOut
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *s +intent(inout)
// Statement: c_inout_char*
// start CHA_passCharPtrInOut
void CHA_passCharPtrInOut(char *s)
{
    // splicer begin function.passCharPtrInOut
    passCharPtrInOut(s);
    // splicer end function.passCharPtrInOut
}
// end CHA_passCharPtrInOut

/**
 * \brief toupper
 *
 * Change a string in-place.
 * For Python, return a new string since strings are immutable.
 */
// ----------------------------------------
// Function:  void passCharPtrInOut
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *s +intent(inout)
// Statement: f_inout_char*_buf
// start CHA_passCharPtrInOut_bufferify
void CHA_passCharPtrInOut_bufferify(char *s, int SHT_s_len)
{
    // splicer begin function.passCharPtrInOut_bufferify
    char * SHC_s_cxx = ShroudCharAlloc(s, SHT_s_len, 0);
    passCharPtrInOut(SHC_s_cxx);
    ShroudCharCopy(s, SHT_s_len, SHC_s_cxx, -1);
    ShroudCharFree(SHC_s_cxx);
    // splicer end function.passCharPtrInOut_bufferify
}
// end CHA_passCharPtrInOut_bufferify

/**
 * Return an ALLOCATABLE CHARACTER from char *.
 */
// ----------------------------------------
// Function:  const char *getCharPtr1
// Statement: c_function_char*
// start CHA_getCharPtr1
const char * CHA_getCharPtr1(void)
{
    // splicer begin function.getCharPtr1
    const char *SHC_rv = getCharPtr1();
    return SHC_rv;
    // splicer end function.getCharPtr1
}
// end CHA_getCharPtr1

/**
 * Return an ALLOCATABLE CHARACTER from char *.
 */
// ----------------------------------------
// Function:  const char *getCharPtr1
// Statement: f_function_char*_cdesc_allocatable
// start CHA_getCharPtr1_bufferify
void CHA_getCharPtr1_bufferify(CHA_SHROUD_array *SHT_rv_cdesc)
{
    // splicer begin function.getCharPtr1_bufferify
    const char *SHC_rv = getCharPtr1();
    SHT_rv_cdesc->base_addr = const_cast<char *>(SHC_rv);
    SHT_rv_cdesc->type = SH_TYPE_CHAR;
    SHT_rv_cdesc->elem_len = SHC_rv == nullptr ? 0 : std::strlen(SHC_rv);
    SHT_rv_cdesc->size = 1;
    SHT_rv_cdesc->rank = 0;
    // splicer end function.getCharPtr1_bufferify
}
// end CHA_getCharPtr1_bufferify

/**
 * \brief return 'const char *' with fixed size (len=30)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrLen +len(30)
// Statement: c_function_char*
// start CHA_getConstCharPtrLen
const char * CHA_getConstCharPtrLen(void)
{
    // splicer begin function.getConstCharPtrLen
    const char *SHC_rv = getConstCharPtrLen();
    return SHC_rv;
    // splicer end function.getConstCharPtrLen
}
// end CHA_getConstCharPtrLen

/**
 * \brief return 'const char *' with fixed size (len=30)
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrLen +len(30)
// Statement: f_function_char*_buf_copy
// start CHA_getConstCharPtrLen_bufferify
void CHA_getConstCharPtrLen_bufferify(char *SHC_rv, int SHT_rv_len)
{
    // splicer begin function.getConstCharPtrLen_bufferify
    const char *SHC_rv_cxx = getConstCharPtrLen();
    ShroudCharCopy(SHC_rv, SHT_rv_len, SHC_rv_cxx, -1);
    // splicer end function.getConstCharPtrLen_bufferify
}
// end CHA_getConstCharPtrLen_bufferify

/**
 * \brief return a 'const char *' as argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsArg
// Statement: c_function_char*
// start CHA_getConstCharPtrAsArg
const char * CHA_getConstCharPtrAsArg(void)
{
    // splicer begin function.getConstCharPtrAsArg
    const char *SHC_rv = getConstCharPtrAsArg();
    return SHC_rv;
    // splicer end function.getConstCharPtrAsArg
}
// end CHA_getConstCharPtrAsArg

/**
 * \brief return a 'const char *' as argument
 *
 */
// ----------------------------------------
// Function:  const char *getConstCharPtrAsArg
// Statement: f_function_char*_buf_arg
// start CHA_getConstCharPtrAsArg_bufferify
void CHA_getConstCharPtrAsArg_bufferify(char *output, int noutput)
{
    // splicer begin function.getConstCharPtrAsArg_bufferify
    const char *SHC_rv_cxx = getConstCharPtrAsArg();
    ShroudCharCopy(output, noutput, SHC_rv_cxx, -1);
    // splicer end function.getConstCharPtrAsArg_bufferify
}
// end CHA_getConstCharPtrAsArg_bufferify

/**
 * \brief return a 'const char *' as type(C_PTR)
 *
 */
// ----------------------------------------
// Function:  const char *getCharPtr4 +deref(raw)
// Statement: c_function_char*
// start CHA_getCharPtr4
const char * CHA_getCharPtr4(void)
{
    // splicer begin function.getCharPtr4
    const char *SHC_rv = getCharPtr4();
    return SHC_rv;
    // splicer end function.getCharPtr4
}
// end CHA_getCharPtr4

/**
 * \brief return a 'const char *' as character(:) pointer
 *
 */
#ifdef HAVE_CHARACTER_POINTER_FUNCTION
// ----------------------------------------
// Function:  const char *getCharPtr5 +deref(pointer)
// Statement: c_function_char*
// start CHA_getCharPtr5
const char * CHA_getCharPtr5(void)
{
    // splicer begin function.getCharPtr5
    const char *SHC_rv = getCharPtr5();
    return SHC_rv;
    // splicer end function.getCharPtr5
}
// end CHA_getCharPtr5
#endif  // ifdef HAVE_CHARACTER_POINTER_FUNCTION

/**
 * \brief return a 'const char *' as character(:) pointer
 *
 */
#ifdef HAVE_CHARACTER_POINTER_FUNCTION
// ----------------------------------------
// Function:  const char *getCharPtr5 +deref(pointer)
// Statement: f_function_char*_cdesc_pointer
// start CHA_getCharPtr5_bufferify
void CHA_getCharPtr5_bufferify(CHA_SHROUD_array *SHT_rv_cdesc)
{
    // splicer begin function.getCharPtr5_bufferify
    const char *SHC_rv = getCharPtr5();
    SHT_rv_cdesc->base_addr = const_cast<char *>(SHC_rv);
    SHT_rv_cdesc->type = SH_TYPE_CHAR;
    SHT_rv_cdesc->elem_len = SHC_rv == nullptr ? 0 : std::strlen(SHC_rv);
    SHT_rv_cdesc->size = 1;
    SHT_rv_cdesc->rank = 0;
    // splicer end function.getCharPtr5_bufferify
}
// end CHA_getCharPtr5_bufferify
#endif  // ifdef HAVE_CHARACTER_POINTER_FUNCTION

// ----------------------------------------
// Function:  void explicit1
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *name +intent(in)+len_trim(AAlen)
// Statement: c_in_char*
// start CHA_explicit1
void CHA_explicit1(char *name)
{
    // splicer begin function.explicit1
    explicit1(name);
    // splicer end function.explicit1
}
// end CHA_explicit1

// ----------------------------------------
// Function:  void explicit2
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *name +intent(out)+len(AAtrim)
// Statement: c_out_char*
// start CHA_explicit2
void CHA_explicit2(char *name)
{
    // splicer begin function.explicit2
    explicit2(name);
    // splicer end function.explicit2
}
// end CHA_explicit2

// ----------------------------------------
// Function:  void explicit2
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *name +intent(out)+len(AAtrim)
// Statement: f_out_char*_buf
// start CHA_explicit2_bufferify
void CHA_explicit2_bufferify(char *name, int SHT_name_len)
{
    // splicer begin function.explicit2_bufferify
    explicit2(name);
    ShroudCharBlankFill(name, SHT_name_len);
    // splicer end function.explicit2_bufferify
}
// end CHA_explicit2_bufferify

/**
 * \brief pass a single char argument as a scalar, extern "C"
 *
 */
// ----------------------------------------
// Function:  void CpassChar
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char status
// Statement: c_in_char
// start CHA_CpassChar
void CHA_CpassChar(char status)
{
    // splicer begin function.CpassChar
    CpassChar(status);
    // splicer end function.CpassChar
}
// end CHA_CpassChar

/**
 * \brief return a char argument (non-pointer), extern "C"
 *
 */
// ----------------------------------------
// Function:  char CreturnChar
// Statement: c_function_char
// start CHA_CreturnChar
void CHA_CreturnChar(char *SHC_rv)
{
    // splicer begin function.CreturnChar
    *SHC_rv = CreturnChar();
    // splicer end function.CreturnChar
}
// end CHA_CreturnChar

/**
 * \brief strcpy like behavior
 *
 * dest is marked intent(OUT) to override the intent(INOUT) default
 * This avoid a copy-in on dest.
 * extern "C"
 * If src is a blank string, pass a NULL pointer to C library function.
 */
// ----------------------------------------
// Function:  void CpassCharPtr
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: f_out_char*_buf
// ----------------------------------------
// Argument:  const char *src +blanknull
// Statement: f_in_char*_buf
// start CHA_CpassCharPtr_bufferify
void CHA_CpassCharPtr_bufferify(char *dest, int SHT_dest_len, char *src,
    int SHT_src_len)
{
    // splicer begin function.CpassCharPtr_bufferify
    char * SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 1);
    CpassCharPtr(dest, SHC_src_cxx);
    ShroudCharBlankFill(dest, SHT_dest_len);
    ShroudCharFree(SHC_src_cxx);
    // splicer end function.CpassCharPtr_bufferify
}
// end CHA_CpassCharPtr_bufferify

/**
 * \brief Test F_blanknull option
 *
 */
// ----------------------------------------
// Function:  void CpassCharPtrBlank
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: c_out_char*
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_CpassCharPtrBlank
void CHA_CpassCharPtrBlank(char *dest, const char *src)
{
    // splicer begin function.CpassCharPtrBlank
    CpassCharPtrBlank(dest, src);
    // splicer end function.CpassCharPtrBlank
}
// end CHA_CpassCharPtrBlank

/**
 * \brief Test F_blanknull option
 *
 */
// ----------------------------------------
// Function:  void CpassCharPtrBlank
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char *dest +intent(out)
// Statement: f_out_char*_buf
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_buf
// start CHA_CpassCharPtrBlank_bufferify
void CHA_CpassCharPtrBlank_bufferify(char *dest, int SHT_dest_len,
    char *src, int SHT_src_len)
{
    // splicer begin function.CpassCharPtrBlank_bufferify
    char * SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 1);
    CpassCharPtrBlank(dest, SHC_src_cxx);
    ShroudCharBlankFill(dest, SHT_dest_len);
    ShroudCharFree(SHC_src_cxx);
    // splicer end function.CpassCharPtrBlank_bufferify
}
// end CHA_CpassCharPtrBlank_bufferify

/**
 * \brief NULL terminate input string in C, not in Fortran.
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrNotrim
// Statement: c_function_native
// ----------------------------------------
// Argument:  const char *src
// Statement: c_in_char*
// start CHA_CpassCharPtrNotrim
int CHA_CpassCharPtrNotrim(const char *src)
{
    // splicer begin function.CpassCharPtrNotrim
    int SHC_rv = CpassCharPtrNotrim(src);
    return SHC_rv;
    // splicer end function.CpassCharPtrNotrim
}
// end CHA_CpassCharPtrNotrim

/**
 * \brief NULL terminate input string in C, not in Fortran.
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrNotrim
// Statement: f_function_native
// ----------------------------------------
// Argument:  const char *src
// Statement: f_in_char*_buf
// start CHA_CpassCharPtrNotrim_bufferify
int CHA_CpassCharPtrNotrim_bufferify(char *src, int SHT_src_len)
{
    // splicer begin function.CpassCharPtrNotrim_bufferify
    char * SHC_src_cxx = ShroudCharAlloc(src, SHT_src_len, 0);
    int SHC_rv = CpassCharPtrNotrim(SHC_src_cxx);
    ShroudCharFree(SHC_src_cxx);
    return SHC_rv;
    // splicer end function.CpassCharPtrNotrim_bufferify
}
// end CHA_CpassCharPtrNotrim_bufferify

/**
 * \brief Do not NULL terminate input string
 *
 * The C library function should get the same address
 * for addr and src.
 * Used when the C function needs the true address of the argument.
 * Skips null-termination. Useful to create an interface for
 * a function which is already callable by Fortran.
 * For example, the length is passed explicitly.
 * This example will not create a Fortran wrapper since C can be
 * called directly.
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI
// Statement: c_function_native
// ----------------------------------------
// Argument:  void *addr
// Statement: c_in_void*
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: c_in_char*
// start CHA_CpassCharPtrCAPI
int CHA_CpassCharPtrCAPI(void *addr, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI
    int SHC_rv = CpassCharPtrCAPI(addr, src);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI
}
// end CHA_CpassCharPtrCAPI

/**
 * \brief Mix api(buf) and api(capi)
 *
 */
// ----------------------------------------
// Function:  int CpassCharPtrCAPI2
// Statement: c_function_native
// ----------------------------------------
// Argument:  const char *in
// Statement: c_in_char*
// ----------------------------------------
// Argument:  const char *src +api(capi)
// Statement: c_in_char*
// start CHA_CpassCharPtrCAPI2
int CHA_CpassCharPtrCAPI2(const char *in, const char *src)
{
    // splicer begin function.CpassCharPtrCAPI2
    int SHC_rv = CpassCharPtrCAPI2(in, src);
    return SHC_rv;
    // splicer end function.CpassCharPtrCAPI2
}
// end CHA_CpassCharPtrCAPI2

/**
 * Return strlen of the first index as a check.
 */
// ----------------------------------------
// Function:  int acceptCharArrayIn
// Statement: c_function_native
// ----------------------------------------
// Argument:  char **names +intent(in)
// Statement: c_in_char**
// start CHA_acceptCharArrayIn
int CHA_acceptCharArrayIn(char **names)
{
    // splicer begin function.acceptCharArrayIn
    int SHC_rv = acceptCharArrayIn(names);
    return SHC_rv;
    // splicer end function.acceptCharArrayIn
}
// end CHA_acceptCharArrayIn

/**
 * Return strlen of the first index as a check.
 */
// ----------------------------------------
// Function:  int acceptCharArrayIn
// Statement: f_function_native
// ----------------------------------------
// Argument:  char **names +intent(in)
// Statement: f_in_char**_buf
// start CHA_acceptCharArrayIn_bufferify
int CHA_acceptCharArrayIn_bufferify(const char *names,
    size_t SHT_names_size, int SHT_names_len)
{
    // splicer begin function.acceptCharArrayIn_bufferify
    char **SHC_names_cxx = ShroudStrArrayAlloc(names, SHT_names_size,
        SHT_names_len);
    int SHC_rv = acceptCharArrayIn(SHC_names_cxx);
    ShroudStrArrayFree(SHC_names_cxx, SHT_names_size);
    return SHC_rv;
    // splicer end function.acceptCharArrayIn_bufferify
}
// end CHA_acceptCharArrayIn_bufferify

/**
 * Fetch a pointer to a char array owned by the library.
 */
// ----------------------------------------
// Function:  void fetchCharPtrLibrary
// Statement: c_subroutine
// ----------------------------------------
// Argument:  char **outstr +intent(out)
// Statement: c_out_char**
// start CHA_fetchCharPtrLibrary
void CHA_fetchCharPtrLibrary(char **outstr)
{
    // splicer begin function.fetchCharPtrLibrary
    fetchCharPtrLibrary(outstr);
    // splicer end function.fetchCharPtrLibrary
}
// end CHA_fetchCharPtrLibrary

/**
 * Fetch a pointer to a char array owned by the library.
 */
// ----------------------------------------
// Function:  void fetchCharPtrLibrary
// Statement: f_subroutine
// ----------------------------------------
// Argument:  char **outstr +intent(out)
// Statement: f_out_char**_cdesc_pointer
// start CHA_fetchCharPtrLibrary_bufferify
void CHA_fetchCharPtrLibrary_bufferify(
    CHA_SHROUD_array *SHT_outstr_cdesc)
{
    // splicer begin function.fetchCharPtrLibrary_bufferify
    char *outstr;
    fetchCharPtrLibrary(&outstr);
    SHT_outstr_cdesc->base_addr = const_cast<char *>(outstr);
    SHT_outstr_cdesc->type = SH_TYPE_CHAR;
    SHT_outstr_cdesc->elem_len = outstr == nullptr ? 0 : std::strlen(outstr);
    SHT_outstr_cdesc->size = 1;
    SHT_outstr_cdesc->rank = 0;
    // splicer end function.fetchCharPtrLibrary_bufferify
}
// end CHA_fetchCharPtrLibrary_bufferify

/**
 * Fetch a NULL pointer to a char array owned by the library.
 * Return a value to test Python returning a tuple.
 */
// ----------------------------------------
// Function:  int fetchCharPtrLibraryNULL
// Statement: c_function_native
// ----------------------------------------
// Argument:  char **outstr +intent(out)
// Statement: c_out_char**
// start CHA_fetchCharPtrLibraryNULL
int CHA_fetchCharPtrLibraryNULL(char **outstr)
{
    // splicer begin function.fetchCharPtrLibraryNULL
    int SHC_rv = fetchCharPtrLibraryNULL(outstr);
    return SHC_rv;
    // splicer end function.fetchCharPtrLibraryNULL
}
// end CHA_fetchCharPtrLibraryNULL

/**
 * Fetch a NULL pointer to a char array owned by the library.
 * Return a value to test Python returning a tuple.
 */
// ----------------------------------------
// Function:  int fetchCharPtrLibraryNULL
// Statement: f_function_native
// ----------------------------------------
// Argument:  char **outstr +intent(out)
// Statement: f_out_char**_cdesc_pointer
// start CHA_fetchCharPtrLibraryNULL_bufferify
int CHA_fetchCharPtrLibraryNULL_bufferify(
    CHA_SHROUD_array *SHT_outstr_cdesc)
{
    // splicer begin function.fetchCharPtrLibraryNULL_bufferify
    char *outstr;
    int SHC_rv = fetchCharPtrLibraryNULL(&outstr);
    SHT_outstr_cdesc->base_addr = const_cast<char *>(outstr);
    SHT_outstr_cdesc->type = SH_TYPE_CHAR;
    SHT_outstr_cdesc->elem_len = outstr == nullptr ? 0 : std::strlen(outstr);
    SHT_outstr_cdesc->size = 1;
    SHT_outstr_cdesc->rank = 0;
    return SHC_rv;
    // splicer end function.fetchCharPtrLibraryNULL_bufferify
}
// end CHA_fetchCharPtrLibraryNULL_bufferify

}  // extern "C"

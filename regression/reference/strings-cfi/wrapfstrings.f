! wrapfstrings.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2023, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
#include "shroud/features.h"
!>
!! \file wrapfstrings.f
!! \brief Shroud generated wrapper for strings library
!<
! splicer begin file_top
! splicer end file_top
module strings_mod
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! ----------------------------------------
    ! Function:  void init_test
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    interface
        subroutine init_test() &
                bind(C, name="STR_init_test")
            implicit none
        end subroutine init_test
    end interface

    ! ----------------------------------------
    ! Function:  void passChar
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    interface
        subroutine pass_char(status) &
                bind(C, name="STR_passChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine pass_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    interface
        subroutine c_pass_char_force(status) &
                bind(C, name="STR_passCharForce")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine c_pass_char_force
    end interface

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    interface
        subroutine c_return_char(SHT_rv) &
                bind(C, name="STR_returnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_return_char
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    ! start c_pass_char_ptr
    interface
        subroutine c_pass_char_ptr(dest, src) &
                bind(C, name="STR_passCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_pass_char_ptr
    end interface
    ! end c_pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    ! start pass_char_ptr
    interface
        subroutine pass_char_ptr(dest, src) &
                bind(C, name="STR_passCharPtr_CFI")
            implicit none
            character(len=*), intent(OUT) :: dest
            character(len=*), intent(IN) :: src
        end subroutine pass_char_ptr
    end interface
    ! end pass_char_ptr

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Attrs:     +intent(inout)
    ! Requested: c_inout_char_*
    ! Match:     c_default
    interface
        subroutine c_pass_char_ptr_in_out(s) &
                bind(C, name="STR_passCharPtrInOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: s(*)
        end subroutine c_pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_char_*_cfi
    interface
        subroutine pass_char_ptr_in_out(s) &
                bind(C, name="STR_passCharPtrInOut_CFI")
            implicit none
            character(len=*), intent(INOUT) :: s
        end subroutine pass_char_ptr_in_out
    end interface

    ! ----------------------------------------
    ! Function:  const char * getCharPtr1
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_char_*_allocatable
    ! Match:     c_function_char_*
    ! start c_get_char_ptr1
    interface
        function c_get_char_ptr1() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr1")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr1
    end interface
    ! end c_get_char_ptr1

    ! ----------------------------------------
    ! Function:  const char * getCharPtr1
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_char_*_cfi_allocatable
    ! start c_get_char_ptr1_CFI
    interface
        subroutine c_get_char_ptr1_CFI(SHT_rv) &
                bind(C, name="STR_getCharPtr1_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_char_ptr1_CFI
    end interface
    ! end c_get_char_ptr1_CFI

    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_char_*_copy
    ! Match:     c_function_char_*
    ! start c_get_char_ptr2
    interface
        function c_get_char_ptr2() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr2")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr2
    end interface
    ! end c_get_char_ptr2

    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +len(30)
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_char_*_cfi_copy
    ! Match:     c_function_char_*_cfi
    ! start c_get_char_ptr2_CFI
    interface
        subroutine c_get_char_ptr2_CFI(SHT_rv) &
                bind(C, name="STR_getCharPtr2_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_char_ptr2_CFI
    end interface
    ! end c_get_char_ptr2_CFI

    ! ----------------------------------------
    ! Function:  const char * getCharPtr3
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_*
    ! start c_get_char_ptr3
    interface
        function c_get_char_ptr3() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr3")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr3
    end interface
    ! end c_get_char_ptr3

    ! ----------------------------------------
    ! Function:  void getCharPtr3
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * output
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: c_function_char_*_cfi_result
    ! Match:     c_function_char_*_cfi
    ! start c_get_char_ptr3_CFI
    interface
        subroutine c_get_char_ptr3_CFI(output) &
                bind(C, name="STR_getCharPtr3_CFI")
            implicit none
            character(len=*), intent(OUT) :: output
        end subroutine c_get_char_ptr3_CFI
    end interface
    ! end c_get_char_ptr3_CFI

    ! ----------------------------------------
    ! Function:  const char * getCharPtr4 +deref(raw)
    ! Attrs:     +deref(raw)+intent(function)
    ! Requested: c_function_char_*_raw
    ! Match:     c_function_char_*
    interface
        function get_char_ptr4() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr4")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function get_char_ptr4
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char * getCharPtr5 +deref(pointer)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_char_*_pointer
    ! Match:     c_function_char_*
    interface
        function c_get_char_ptr5() &
                result(SHT_rv) &
                bind(C, name="STR_getCharPtr5")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_char_ptr5
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const char * getCharPtr5 +deref(pointer)
    ! Attrs:     +api(cfi)+deref(pointer)+intent(function)
    ! Exact:     c_function_char_*_cfi_pointer
    interface
        subroutine c_get_char_ptr5_CFI(SHT_rv) &
                bind(C, name="STR_getCharPtr5_CFI")
            implicit none
            character(len=:), intent(OUT), pointer :: SHT_rv
        end subroutine c_get_char_ptr5_CFI
    end interface
#endif

    ! ----------------------------------------
    ! Function:  const string getConstStringResult
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cfi_allocatable
    interface
        subroutine c_get_const_string_result_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringResult_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_result_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_scalar_cfi_copy
    ! Match:     c_function_string_scalar_cfi
    interface
        subroutine c_get_const_string_len_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_len_CFI
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringAsArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string * output
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_*_cfi_result
    ! Match:     c_function_string_*_cfi
    interface
        subroutine c_get_const_string_as_arg_CFI(output) &
                bind(C, name="STR_getConstStringAsArg_CFI")
            implicit none
            character(len=*), intent(OUT) :: output
        end subroutine c_get_const_string_as_arg_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string getConstStringAlloc
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cfi_allocatable
    interface
        subroutine c_get_const_string_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_&_allocatable
    ! Match:     c_function_string_&
    ! start c_get_const_string_ref_pure
    interface
        function c_get_const_string_ref_pure() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefPure")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_pure
    end interface
    ! end c_get_const_string_ref_pure

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cfi_allocatable
    ! start c_get_const_string_ref_pure_CFI
    interface
        subroutine c_get_const_string_ref_pure_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefPure_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ref_pure_CFI
    end interface
    ! end c_get_const_string_ref_pure_CFI

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_&_copy
    ! Match:     c_function_string_&
    interface
        function c_get_const_string_ref_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_len
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +len(30)
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_cfi_copy
    ! Match:     c_function_string_&_cfi
    interface
        subroutine c_get_const_string_ref_len_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ref_len_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefAsArg
    ! Attrs:     +intent(function)
    ! Exact:     c_function_string_&
    interface
        function c_get_const_string_ref_as_arg() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefAsArg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_as_arg
    end interface

    ! ----------------------------------------
    ! Function:  void getConstStringRefAsArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string & output
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_&_cfi_result
    ! Match:     c_function_string_&_cfi
    interface
        subroutine c_get_const_string_ref_as_arg_CFI(output) &
                bind(C, name="STR_getConstStringRefAsArg_CFI")
            implicit none
            character(len=*), intent(OUT) :: output
        end subroutine c_get_const_string_ref_as_arg_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_&_copy
    ! Match:     c_function_string_&
    interface
        function c_get_const_string_ref_len_empty() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLenEmpty")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_len_empty
    end interface

    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +len(30)
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_cfi_copy
    ! Match:     c_function_string_&_cfi
    interface
        subroutine c_get_const_string_ref_len_empty_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefLenEmpty_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ref_len_empty_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_&_allocatable
    ! Match:     c_function_string_&
    interface
        function c_get_const_string_ref_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ref_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cfi_allocatable
    interface
        subroutine c_get_const_string_ref_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ref_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: c_function_string_*_copy
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_len
    end interface

    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +len(30)
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_*_cfi_copy
    ! Match:     c_function_string_*_cfi
    interface
        subroutine c_get_const_string_ptr_len_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ptr_len_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +owner(library)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_*_allocatable
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +owner(library)
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cfi_allocatable
    interface
        subroutine c_get_const_string_ptr_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ptr_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_*_allocatable
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_owns_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_owns_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +owner(caller)
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cfi_allocatable
    interface
        subroutine c_get_const_string_ptr_owns_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ptr_owns_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +free_pattern(C_string_free)+owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: c_function_string_*_allocatable
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_owns_alloc_pattern() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_owns_alloc_pattern
    end interface

    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +free_pattern(C_string_free)+owner(caller)
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cfi_allocatable
    interface
        subroutine c_get_const_string_ptr_owns_alloc_pattern_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ptr_owns_alloc_pattern_CFI
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_string_*_pointer
    ! Match:     c_function_string_*
    interface
        function c_get_const_string_ptr_pointer() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_const_string_ptr_pointer
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Attrs:     +api(cfi)+deref(pointer)+intent(function)
    ! Exact:     c_function_string_*_cfi_pointer
    interface
        subroutine c_get_const_string_ptr_pointer_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer_CFI")
            implicit none
            character(len=:), intent(OUT), pointer :: SHT_rv
        end subroutine c_get_const_string_ptr_pointer_CFI
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string & arg1
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_&
    interface
        subroutine c_accept_string_const_reference(arg1) &
                bind(C, name="STR_acceptStringConstReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string & arg1
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_string_&_cfi
    interface
        subroutine accept_string_const_reference(arg1) &
                bind(C, name="STR_acceptStringConstReference_CFI")
            implicit none
            character(len=*), intent(IN) :: arg1
        end subroutine accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     c_out_string_&
    interface
        subroutine c_accept_string_reference_out(arg1) &
                bind(C, name="STR_acceptStringReferenceOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_string_&_cfi
    interface
        subroutine accept_string_reference_out(arg1) &
                bind(C, name="STR_acceptStringReferenceOut_CFI")
            implicit none
            character(len=*), intent(OUT) :: arg1
        end subroutine accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_&
    ! start c_accept_string_reference
    interface
        subroutine c_accept_string_reference(arg1) &
                bind(C, name="STR_acceptStringReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_reference
    end interface
    ! end c_accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_&_cfi
    ! start accept_string_reference
    interface
        subroutine accept_string_reference(arg1) &
                bind(C, name="STR_acceptStringReference_CFI")
            implicit none
            character(len=*), intent(INOUT) :: arg1
        end subroutine accept_string_reference
    end interface
    ! end accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string * arg1
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_*
    interface
        subroutine c_accept_string_pointer_const(arg1) &
                bind(C, name="STR_acceptStringPointerConst")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string * arg1
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_string_*_cfi
    interface
        subroutine accept_string_pointer_const(arg1) &
                bind(C, name="STR_acceptStringPointerConst_CFI")
            implicit none
            character(len=*), intent(IN) :: arg1
        end subroutine accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_*
    interface
        subroutine c_accept_string_pointer(arg1) &
                bind(C, name="STR_acceptStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_*_cfi
    interface
        subroutine accept_string_pointer(arg1) &
                bind(C, name="STR_acceptStringPointer_CFI")
            implicit none
            character(len=*), intent(INOUT) :: arg1
        end subroutine accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     c_out_string_*
    interface
        subroutine c_fetch_string_pointer(arg1) &
                bind(C, name="STR_fetchStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_string_*_cfi
    interface
        subroutine fetch_string_pointer(arg1) &
                bind(C, name="STR_fetchStringPointer_CFI")
            implicit none
            character(len=*), intent(OUT) :: arg1
        end subroutine fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_*
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_acceptStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_*_cfi
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_acceptStringPointerLen_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(INOUT) :: arg1
            integer(C_INT), intent(OUT) :: nlen
        end subroutine accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     c_out_string_*
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetchStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_string_*_cfi
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetchStringPointerLen_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(OUT) :: arg1
            integer(C_INT), intent(OUT) :: nlen
        end subroutine fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  std::string arg1 +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_string_scalar
    interface
        function c_accept_string_instance(arg1) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT) :: SHT_rv
        end function c_accept_string_instance
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  std::string arg1 +value
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_string_scalar_cfi
    interface
        function accept_string_instance(arg1) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(IN) :: arg1
            integer(C_INT) :: SHT_rv
        end function accept_string_instance
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +dimension(nstrs)+intent(out)
    ! Attrs:     +deref(copy)+intent(out)
    ! Exact:     c_out_string_**_copy
    ! ----------------------------------------
    ! Argument:  int * nstrs +hidden+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_array_string_arg(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringArg")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_arg
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +dimension(nstrs)+intent(out)
    ! Attrs:     +api(cfi)+deref(copy)+intent(out)
    ! Requested: c_out_string_**_cfi_copy
    ! Match:     c_out_string_**_copy
    interface
        subroutine fetch_array_string_arg(strs) &
                bind(C, name="STR_fetchArrayStringArg_CFI")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
        end subroutine fetch_array_string_arg
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_allocatable
    ! ----------------------------------------
    ! Argument:  int * nstrs +hidden+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_array_string_alloc(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAlloc")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(out)
    ! Requested: c_out_string_**_cfi_allocatable
    ! Match:     c_out_string_**_allocatable
    interface
        subroutine fetch_array_string_alloc(strs) &
                bind(C, name="STR_fetchArrayStringAlloc_CFI")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
        end subroutine fetch_array_string_alloc
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Exact:     c_out_string_**_allocatable
    ! ----------------------------------------
    ! Argument:  int * nstrs +hidden+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    interface
        subroutine c_fetch_array_string_alloc_len(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAllocLen")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(out)
    ! Requested: c_out_string_**_cfi_allocatable
    ! Match:     c_out_string_**_allocatable
    interface
        subroutine fetch_array_string_alloc_len(strs) &
                bind(C, name="STR_fetchArrayStringAllocLen_CFI")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: strs
        end subroutine fetch_array_string_alloc_len
    end interface

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(in)+len_trim(AAlen)
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        subroutine c_explicit1(name) &
                bind(C, name="STR_explicit1")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
        end subroutine c_explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit1
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(in)+len_trim(AAlen)
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    interface
        subroutine explicit1(name) &
                bind(C, name="STR_explicit1_CFI")
            implicit none
            character(len=*), intent(IN) :: name
        end subroutine explicit1
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    interface
        subroutine c_explicit2(name) &
                bind(C, name="STR_explicit2")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: name(*)
        end subroutine c_explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void explicit2
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    interface
        subroutine explicit2(name) &
                bind(C, name="STR_explicit2_CFI")
            implicit none
            character(len=*), intent(OUT) :: name
        end subroutine explicit2
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    interface
        subroutine cpass_char(status) &
                bind(C, name="CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    interface
        subroutine c_creturn_char(SHT_rv) &
                bind(C, name="STR_CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +blanknull
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        subroutine c_cpass_char_ptr(dest, src) &
                bind(C, name="CpassCharPtr")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src +blanknull
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    interface
        subroutine cpass_char_ptr(dest, src) &
                bind(C, name="STR_CpassCharPtr_CFI")
            implicit none
            character(len=*), intent(OUT) :: dest
            character(len=*), intent(IN) :: src
        end subroutine cpass_char_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        subroutine c_cpass_char_ptr_blank(dest, src) &
                bind(C, name="STR_CpassCharPtrBlank")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: dest(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
        end subroutine c_cpass_char_ptr_blank
    end interface

    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    interface
        subroutine cpass_char_ptr_blank(dest, src) &
                bind(C, name="STR_CpassCharPtrBlank_CFI")
            implicit none
            character(len=*), intent(OUT) :: dest
            character(len=*), intent(IN) :: src
        end subroutine cpass_char_ptr_blank
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  std::string & name
    ! Attrs:     +intent(inout)
    ! Exact:     c_inout_string_&
    interface
        subroutine c_post_declare(count, name) &
                bind(C, name="STR_PostDeclare")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
        end subroutine c_post_declare
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_native_*_cfi
    ! ----------------------------------------
    ! Argument:  std::string & name
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_&_cfi
    interface
        subroutine post_declare(count, name) &
                bind(C, name="STR_PostDeclare_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(:)
            character(len=*), intent(INOUT) :: name
        end subroutine post_declare
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    interface
        function c_cpass_char_ptr_notrim(src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrNotrim")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_notrim
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    interface
        function cpass_char_ptr_notrim(src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrNotrim_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(IN) :: src
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_notrim
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  void * addr +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_void_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    interface
        function cpass_char_ptr_capi(addr, src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrCAPI")
            use iso_c_binding, only : C_CHAR, C_INT, C_PTR
            implicit none
            type(C_PTR), value, intent(IN) :: addr
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_capi
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * in
    ! Attrs:     +intent(in)
    ! Requested: c_in_char_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    interface
        function c_cpass_char_ptr_capi2(in, src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrCAPI2")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: in(*)
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function c_cpass_char_ptr_capi2
    end interface

    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * in
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    interface
        function cpass_char_ptr_capi2(in, src) &
                result(SHT_rv) &
                bind(C, name="STR_CpassCharPtrCAPI2_CFI")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(len=*), intent(IN) :: in
            character(kind=C_CHAR), intent(IN) :: src(*)
            integer(C_INT) :: SHT_rv
        end function cpass_char_ptr_capi2
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void init_test
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    subroutine init_test()
        ! splicer begin function.init_test
        call c_init_test()
        ! splicer end function.init_test
    end subroutine init_test
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void passChar
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_scalar
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    !>
    !! \brief pass a single char argument as a scalar.
    !!
    !<
    subroutine pass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char
        call c_pass_char(status)
        ! splicer end function.pass_char
    end subroutine pass_char
#endif

    ! ----------------------------------------
    ! Function:  void passCharForce
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_scalar
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    !>
    !! By default no Fortran wrapper is created.
    !! Force one so it can be tested.
    !<
    subroutine pass_char_force(status)
        character, value, intent(IN) :: status
        ! splicer begin function.pass_char_force
        call c_pass_char_force(status)
        ! splicer end function.pass_char_force
    end subroutine pass_char_force

    ! ----------------------------------------
    ! Function:  char returnChar
    ! Attrs:     +intent(function)
    ! Exact:     f_function_char_scalar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    !>
    !! \brief return a char argument (non-pointer)
    !!
    !<
    function return_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.return_char
        call c_return_char(SHT_rv)
        ! splicer end function.return_char
    end function return_char

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void passCharPtr
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +charlen(40)+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: f_out_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: f_in_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! In Python, src must not be over 40 characters, defined by charlen.
    !<
    ! start pass_char_ptr
    subroutine pass_char_ptr(dest, src)
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.pass_char_ptr
        call c_pass_char_ptr_CFI(dest, src)
        ! splicer end function.pass_char_ptr
    end subroutine pass_char_ptr
    ! end pass_char_ptr
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void passCharPtrInOut
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * s +intent(inout)
    ! Attrs:     +intent(inout)
    ! Requested: f_inout_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_char_*_cfi
    !>
    !! \brief toupper
    !!
    !! Change a string in-place.
    !! For Python, return a new string since strings are immutable.
    !<
    subroutine pass_char_ptr_in_out(s)
        character(len=*), intent(INOUT) :: s
        ! splicer begin function.pass_char_ptr_in_out
        call c_pass_char_ptr_in_out_CFI(s)
        ! splicer end function.pass_char_ptr_in_out
    end subroutine pass_char_ptr_in_out
#endif

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const char * getCharPtr1
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_char_*_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_char_*_cfi_allocatable
    !>
    !! \brief return a 'const char *' as character(*)
    !!
    !<
    ! start get_char_ptr1
    function get_char_ptr1() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_char_ptr1
        call c_get_char_ptr1_CFI(SHT_rv)
        ! splicer end function.get_char_ptr1
    end function get_char_ptr1
    ! end get_char_ptr1

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const char * getCharPtr2 +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_char_*_cfi_copy
    ! Match:     f_function_char_*_cfi
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_char_*_cfi_copy
    ! Match:     c_function_char_*_cfi
    !>
    !! \brief return 'const char *' with fixed size (len=30)
    !!
    !<
    ! start get_char_ptr2
    function get_char_ptr2() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_char_ptr2
        call c_get_char_ptr2_CFI(SHT_rv)
        ! splicer end function.get_char_ptr2
    end function get_char_ptr2
    ! end get_char_ptr2

    ! Generated by arg_to_cfi - arg_to_cfi
    ! ----------------------------------------
    ! Function:  void getCharPtr3
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * output
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: f_function_char_*_cfi_result
    ! Match:     f_function_char_*_cfi
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: c_function_char_*_cfi_result
    ! Match:     c_function_char_*_cfi
    !>
    !! \brief return a 'const char *' as argument
    !!
    !<
    ! start get_char_ptr3
    subroutine get_char_ptr3(output)
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_char_ptr3
        call c_get_char_ptr3_CFI(output)
        ! splicer end function.get_char_ptr3
    end subroutine get_char_ptr3
    ! end get_char_ptr3

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  const char * getCharPtr4 +deref(raw)
    ! Attrs:     +deref(raw)+intent(function)
    ! Exact:     f_function_char_*_raw
    ! Attrs:     +deref(raw)+intent(function)
    ! Requested: c_function_char_*_raw
    ! Match:     c_function_char_*
    !>
    !! \brief return a 'const char *' as type(C_PTR)
    !!
    !<
    function get_char_ptr4() &
            result(SHT_rv)
        type(C_PTR) :: SHT_rv
        ! splicer begin function.get_char_ptr4
        SHT_rv = c_get_char_ptr4()
        ! splicer end function.get_char_ptr4
    end function get_char_ptr4
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const char * getCharPtr5 +deref(pointer)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Exact:     f_function_char_*_cfi_pointer
    ! Attrs:     +api(cfi)+deref(pointer)+intent(function)
    ! Exact:     c_function_char_*_cfi_pointer
    !>
    !! \brief return a 'const char *' as character(:) pointer
    !!
    !<
    function get_char_ptr5() &
            result(SHT_rv)
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_char_ptr5
        call c_get_char_ptr5_CFI(SHT_rv)
        ! splicer end function.get_char_ptr5
    end function get_char_ptr5
#endif

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const string getConstStringResult
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_scalar_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cfi_allocatable
    !>
    !! \brief return an ALLOCATABLE CHARACTER from std::string
    !!
    !<
    function get_const_string_result() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_result
        call c_get_const_string_result_CFI(SHT_rv)
        ! splicer end function.get_const_string_result
    end function get_const_string_result

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_scalar_cfi_copy
    ! Match:     f_function_string_scalar_cfi
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_scalar_cfi_copy
    ! Match:     c_function_string_scalar_cfi
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    function get_const_string_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_len
        call c_get_const_string_len_CFI(SHT_rv)
        ! splicer end function.get_const_string_len
    end function get_const_string_len

    ! Generated by arg_to_cfi - arg_to_cfi
    ! ----------------------------------------
    ! Function:  void getConstStringAsArg
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string * output
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: f_function_string_*_cfi_result
    ! Match:     f_function_string_*_cfi
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_*_cfi_result
    ! Match:     c_function_string_*_cfi
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    subroutine get_const_string_as_arg(output)
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_as_arg
        call c_get_const_string_as_arg_CFI(output)
        ! splicer end function.get_const_string_as_arg
    end subroutine get_const_string_as_arg

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const std::string getConstStringAlloc
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_scalar_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_scalar_cfi_allocatable
    function get_const_string_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_alloc
        call c_get_const_string_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_alloc
    end function get_const_string_alloc

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefPure
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_&_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cfi_allocatable
    !>
    !! \brief return a 'const string&' as ALLOCATABLE character
    !!
    !<
    ! start get_const_string_ref_pure
    function get_const_string_ref_pure() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_pure
        call c_get_const_string_ref_pure_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_pure
    end function get_const_string_ref_pure
    ! end get_const_string_ref_pure

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_&_cfi_copy
    ! Match:     f_function_string_&_cfi
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_cfi_copy
    ! Match:     c_function_string_&_cfi
    !>
    !! \brief return 'const string&' with fixed size (len=30)
    !!
    !! Since +len(30) is provided, the result of the function
    !! will be copied directly into memory provided by Fortran.
    !! The function will not be ALLOCATABLE.
    !<
    function get_const_string_ref_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len
        call c_get_const_string_ref_len_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_len
    end function get_const_string_ref_len

    ! Generated by arg_to_cfi - arg_to_cfi
    ! ----------------------------------------
    ! Function:  void getConstStringRefAsArg
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  string & output
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: f_function_string_&_cfi_result
    ! Match:     f_function_string_&_cfi
    ! Attrs:     +api(cfi)+deref(result)+intent(out)+is_result
    ! Requested: c_function_string_&_cfi_result
    ! Match:     c_function_string_&_cfi
    !>
    !! \brief return a 'const string&' as argument
    !!
    !! Pass an additional argument which will be used as the return value.
    !! The length of the output variable is declared by the caller.
    !<
    subroutine get_const_string_ref_as_arg(output)
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_ref_as_arg
        call c_get_const_string_ref_as_arg_CFI(output)
        ! splicer end function.get_const_string_ref_as_arg
    end subroutine get_const_string_ref_as_arg

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const string & getConstStringRefLenEmpty +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_&_cfi_copy
    ! Match:     f_function_string_&_cfi
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_&_cfi_copy
    ! Match:     c_function_string_&_cfi
    !>
    !! \brief Test returning empty string reference
    !!
    !<
    function get_const_string_ref_len_empty() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len_empty
        call c_get_const_string_ref_len_empty_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_len_empty
    end function get_const_string_ref_len_empty

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const std::string & getConstStringRefAlloc
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Exact:     f_function_string_&_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_&_cfi_allocatable
    function get_const_string_ref_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_alloc
        call c_get_const_string_ref_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_alloc
    end function get_const_string_ref_alloc

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const string * getConstStringPtrLen +len(30)
    ! Attrs:     +deref(copy)+intent(function)
    ! Requested: f_function_string_*_cfi_copy
    ! Match:     f_function_string_*_cfi
    ! Attrs:     +api(cfi)+deref(copy)+intent(function)
    ! Requested: c_function_string_*_cfi_copy
    ! Match:     c_function_string_*_cfi
    !>
    !! \brief return a 'const string *' as character(30)
    !!
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished with C_finalize_buf which is possible
    !! because +len(30) so the contents are copied before returning.
    !<
    function get_const_string_ptr_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ptr_len
        call c_get_const_string_ptr_len_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_len
    end function get_const_string_ptr_len

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrAlloc +owner(library)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: f_function_string_*_cfi_allocatable_library
    ! Match:     f_function_string_*_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cfi_allocatable
    function get_const_string_ptr_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_alloc
        call c_get_const_string_ptr_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_alloc
    end function get_const_string_ptr_alloc

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAlloc +owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: f_function_string_*_cfi_allocatable_caller
    ! Match:     f_function_string_*_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cfi_allocatable
    !>
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished +owner(caller) which sets idtor.
    !! The contents are copied by Fortran so they must outlast
    !! the return from the C wrapper.
    !<
    function get_const_string_ptr_owns_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc
        call c_get_const_string_ptr_owns_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_owns_alloc
    end function get_const_string_ptr_owns_alloc

    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrOwnsAllocPattern +free_pattern(C_string_free)+owner(caller)
    ! Attrs:     +deref(allocatable)+intent(function)
    ! Requested: f_function_string_*_cfi_allocatable_caller
    ! Match:     f_function_string_*_cfi_allocatable
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(function)
    ! Exact:     c_function_string_*_cfi_allocatable
    !>
    !! Similar to getConstStringPtrOwnsAlloc, but uses pattern to release memory.
    !<
    function get_const_string_ptr_owns_alloc_pattern() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc_pattern
        call c_get_const_string_ptr_owns_alloc_pattern_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_owns_alloc_pattern
    end function get_const_string_ptr_owns_alloc_pattern

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  const std::string * getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: f_function_string_*_cfi_pointer_library
    ! Match:     f_function_string_*_cfi_pointer
    ! Attrs:     +api(cfi)+deref(pointer)+intent(function)
    ! Exact:     c_function_string_*_cfi_pointer
    function get_const_string_ptr_pointer() &
            result(SHT_rv)
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_const_string_ptr_pointer
        call c_get_const_string_ptr_pointer_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_pointer
    end function get_const_string_ptr_pointer
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string & arg1
    ! Attrs:     +intent(in)
    ! Requested: f_in_string_&_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_string_&_cfi
    !>
    !! \brief Accept a const string reference
    !!
    !! Save contents of arg1.
    !! arg1 is assumed to be intent(IN) since it is const
    !! Will copy in.
    !<
    subroutine accept_string_const_reference(arg1)
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_const_reference
        call c_accept_string_const_reference_CFI(arg1)
        ! splicer end function.accept_string_const_reference
    end subroutine accept_string_const_reference
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: f_out_string_&_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_string_&_cfi
    !>
    !! \brief Accept a string reference
    !!
    !! Set out to a constant string.
    !! arg1 is intent(OUT)
    !! Must copy out.
    !<
    subroutine accept_string_reference_out(arg1)
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.accept_string_reference_out
        call c_accept_string_reference_out_CFI(arg1)
        ! splicer end function.accept_string_reference_out
    end subroutine accept_string_reference_out
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string & arg1
    ! Attrs:     +intent(inout)
    ! Requested: f_inout_string_&_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_&_cfi
    !>
    !! \brief Accept a string reference
    !!
    !! Append "dog" to the end of arg1.
    !! arg1 is assumed to be intent(INOUT)
    !! Must copy in and copy out.
    !<
    ! start accept_string_reference
    subroutine accept_string_reference(arg1)
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_reference
        call c_accept_string_reference_CFI(arg1)
        ! splicer end function.accept_string_reference
    end subroutine accept_string_reference
    ! end accept_string_reference
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string * arg1
    ! Attrs:     +intent(in)
    ! Requested: f_in_string_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_string_*_cfi
    !>
    !! \brief Accept a const string pointer - intent(in)
    !!
    !<
    subroutine accept_string_pointer_const(arg1)
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_pointer_const
        call c_accept_string_pointer_const_CFI(arg1)
        ! splicer end function.accept_string_pointer_const
    end subroutine accept_string_pointer_const
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Requested: f_inout_string_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_*_cfi
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !<
    subroutine accept_string_pointer(arg1)
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_pointer
        call c_accept_string_pointer_CFI(arg1)
        ! splicer end function.accept_string_pointer
    end subroutine accept_string_pointer
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: f_out_string_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_string_*_cfi
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !<
    subroutine fetch_string_pointer(arg1)
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.fetch_string_pointer
        call c_fetch_string_pointer_CFI(arg1)
        ! splicer end function.fetch_string_pointer
    end subroutine fetch_string_pointer
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1
    ! Attrs:     +intent(inout)
    ! Requested: f_inout_string_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_*_cfi
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_native_*
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine accept_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.accept_string_pointer_len
        call c_accept_string_pointer_len_CFI(arg1, nlen)
        ! splicer end function.accept_string_pointer_len
    end subroutine accept_string_pointer_len
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * arg1 +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: f_out_string_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_string_*_cfi
    ! ----------------------------------------
    ! Argument:  int * nlen +intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_native_*
    ! Attrs:     +intent(out)
    ! Requested: c_out_native_*
    ! Match:     c_default
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine fetch_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.fetch_string_pointer_len
        call c_fetch_string_pointer_len_CFI(arg1, nlen)
        ! splicer end function.fetch_string_pointer_len
    end subroutine fetch_string_pointer_len
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  std::string arg1 +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_string_scalar_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_string_scalar_cfi
    !>
    !! \brief Accept a string instance
    !!
    !<
    function accept_string_instance(arg1) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), value, intent(IN) :: arg1
        integer(C_INT) :: SHT_rv
        ! splicer begin function.accept_string_instance
        SHT_rv = c_accept_string_instance_CFI(arg1)
        ! splicer end function.accept_string_instance
    end function accept_string_instance
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +dimension(nstrs)+intent(out)
    ! Attrs:     +deref(copy)+intent(out)
    ! Requested: f_out_string_**_cfi_copy
    ! Match:     f_default
    ! Attrs:     +api(cfi)+deref(copy)+intent(out)
    ! Requested: c_out_string_**_cfi_copy
    ! Match:     c_out_string_**_copy
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !<
    subroutine fetch_array_string_arg(strs)
        character(len=*), intent(OUT) :: strs(nstrs)
        ! splicer begin function.fetch_array_string_arg
        call c_fetch_array_string_arg_CFI(strs)
        ! splicer end function.fetch_array_string_arg
    end subroutine fetch_array_string_arg
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Requested: f_out_string_**_cfi_allocatable
    ! Match:     f_default
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(out)
    ! Requested: c_out_string_**_cfi_allocatable
    ! Match:     c_out_string_**_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the maximum string length.
    !<
    subroutine fetch_array_string_alloc(strs)
        character(len=:), intent(OUT), allocatable :: strs(:)
        ! splicer begin function.fetch_array_string_alloc
        call c_fetch_array_string_alloc_CFI(strs)
        ! splicer end function.fetch_array_string_alloc
    end subroutine fetch_array_string_alloc
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string * * strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Attrs:     +deref(allocatable)+intent(out)
    ! Requested: f_out_string_**_cfi_allocatable
    ! Match:     f_default
    ! Attrs:     +api(cfi)+deref(allocatable)+intent(out)
    ! Requested: c_out_string_**_cfi_allocatable
    ! Match:     c_out_string_**_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the len attribute.
    !<
    subroutine fetch_array_string_alloc_len(strs)
        character(len=:), intent(OUT), allocatable :: strs(:)
        ! splicer begin function.fetch_array_string_alloc_len
        call c_fetch_array_string_alloc_len_CFI(strs)
        ! splicer end function.fetch_array_string_alloc_len
    end subroutine fetch_array_string_alloc_len
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void explicit1
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(in)+len_trim(AAlen)
    ! Attrs:     +intent(in)
    ! Requested: f_in_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    subroutine explicit1(name)
        character(len=*), intent(IN) :: name
        ! splicer begin function.explicit1
        call c_explicit1_CFI(name)
        ! splicer end function.explicit1
    end subroutine explicit1
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void explicit2
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * name +intent(out)+len(AAtrim)
    ! Attrs:     +intent(out)
    ! Requested: f_out_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    subroutine explicit2(name)
        character(len=*), intent(OUT) :: name
        ! splicer begin function.explicit2
        call c_explicit2_CFI(name)
        ! splicer end function.explicit2
    end subroutine explicit2
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char status +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_char_scalar
    ! Attrs:     +intent(in)
    ! Exact:     c_in_char_scalar
    !>
    !! \brief pass a single char argument as a scalar, extern "C"
    !!
    !<
    subroutine cpass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.cpass_char
        call c_cpass_char(status)
        ! splicer end function.cpass_char
    end subroutine cpass_char
#endif

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Attrs:     +intent(function)
    ! Exact:     f_function_char_scalar
    ! Attrs:     +intent(function)
    ! Exact:     c_function_char_scalar
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char(SHT_rv)
        ! splicer end function.creturn_char
    end function creturn_char

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void CpassCharPtr
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: f_out_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src +blanknull
    ! Attrs:     +intent(in)
    ! Requested: f_in_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    !>
    !! \brief strcpy like behavior
    !!
    !! dest is marked intent(OUT) to override the intent(INOUT) default
    !! This avoid a copy-in on dest.
    !! extern "C"
    !! If src is a blank string, pass a NULL pointer to C library function.
    !<
    subroutine cpass_char_ptr(dest, src)
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr
        call c_cpass_char_ptr_CFI(dest, src)
        ! splicer end function.cpass_char_ptr
    end subroutine cpass_char_ptr
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void CpassCharPtrBlank
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  char * dest +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: f_out_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(out)
    ! Exact:     c_out_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: f_in_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    !>
    !! \brief Test F_blanknull option
    !!
    !<
    subroutine cpass_char_ptr_blank(dest, src)
        character(len=*), intent(OUT) :: dest
        character(len=*), intent(IN) :: src
        ! splicer begin function.cpass_char_ptr_blank
        call c_cpass_char_ptr_blank_CFI(dest, src)
        ! splicer end function.cpass_char_ptr_blank
    end subroutine cpass_char_ptr_blank
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Attrs:     +intent(subroutine)
    ! Exact:     f_subroutine
    ! Attrs:     +intent(subroutine)
    ! Exact:     c_subroutine
    ! ----------------------------------------
    ! Argument:  int * count +intent(in)+rank(1)
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_native_*_cfi
    ! ----------------------------------------
    ! Argument:  std::string & name
    ! Attrs:     +intent(inout)
    ! Requested: f_inout_string_&_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(inout)
    ! Exact:     c_inout_string_&_cfi
    !>
    !! Test post_declare.
    !! The std::string in py_string_inout must be declared before the
    !! goto added by py_native_*_in_pointer_list to avoid
    !! "jump to label 'fail' crosses initialization of" error.
    !<
    subroutine post_declare(count, name)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(IN) :: count(:)
        character(len=*), intent(INOUT) :: name
        ! splicer begin function.post_declare
        call c_post_declare_CFI(count, name)
        ! splicer end function.post_declare
    end subroutine post_declare
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  int CpassCharPtrNotrim
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * src
    ! Attrs:     +intent(in)
    ! Requested: f_in_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    !>
    !! \brief NULL terminate input string in C, not in Fortran.
    !!
    !<
    function cpass_char_ptr_notrim(src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_notrim
        SHT_rv = c_cpass_char_ptr_notrim_CFI(src)
        ! splicer end function.cpass_char_ptr_notrim
    end function cpass_char_ptr_notrim
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  void * addr +value
    ! Attrs:     +intent(in)
    ! Exact:     f_in_void_*
    ! Attrs:     +intent(in)
    ! Requested: c_in_void_*
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: f_in_char_*_capi
    ! Match:     f_default
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    !>
    !! \brief Do not NULL terminate input string
    !!
    !! The C library function should get the same address
    !! for addr and src.
    !! Used when the C function needs the true address of the argument.
    !! Skips null-termination. Useful to create an interface for
    !! a function which is already callable by Fortran.
    !! For example, the length is passed explicitly.
    !! This example will not create a Fortran wrapper since C can be
    !! called directly.
    !<
    function cpass_char_ptr_capi(addr, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, C_PTR
        type(C_PTR), intent(IN) :: addr
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi
        SHT_rv = c_cpass_char_ptr_capi(addr, src)
        ! splicer end function.cpass_char_ptr_capi
    end function cpass_char_ptr_capi
#endif

#if 0
    ! Only the interface is needed
    ! Generated by arg_to_cfi
    ! ----------------------------------------
    ! Function:  int CpassCharPtrCAPI2
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const char * in
    ! Attrs:     +intent(in)
    ! Requested: f_in_char_*_cfi
    ! Match:     f_default
    ! Attrs:     +api(cfi)+intent(in)
    ! Exact:     c_in_char_*_cfi
    ! ----------------------------------------
    ! Argument:  const char * src +api(capi)
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: f_in_char_*_capi
    ! Match:     f_default
    ! Attrs:     +api(capi)+intent(in)
    ! Requested: c_in_char_*_capi
    ! Match:     c_default
    !>
    !! \brief Mix api(buf) and api(capi)
    !!
    !<
    function cpass_char_ptr_capi2(in, src) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: in
        character(len=*), intent(IN) :: src
        integer(C_INT) :: SHT_rv
        ! splicer begin function.cpass_char_ptr_capi2
        SHT_rv = c_cpass_char_ptr_capi2_CFI(in, src)
        ! splicer end function.cpass_char_ptr_capi2
    end function cpass_char_ptr_capi2
#endif

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module strings_mod

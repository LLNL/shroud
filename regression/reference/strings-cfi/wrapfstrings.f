! wrapfstrings.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
#include "shroud/features.h"
!>
!! \file wrapfstrings.f
!! \brief Shroud generated wrapper for strings library
!<
! splicer begin file_top
! splicer end file_top
module strings_mod
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper type_defines
    ! Shroud type defines from helper type_defines
    integer, parameter, private :: &
        SH_TYPE_SIGNED_CHAR= 1, &
        SH_TYPE_SHORT      = 2, &
        SH_TYPE_INT        = 3, &
        SH_TYPE_LONG       = 4, &
        SH_TYPE_LONG_LONG  = 5, &
        SH_TYPE_SIZE_T     = 6, &
        SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &
        SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &
        SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &
        SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &
        SH_TYPE_INT8_T    =  7, &
        SH_TYPE_INT16_T   =  8, &
        SH_TYPE_INT32_T   =  9, &
        SH_TYPE_INT64_T   = 10, &
        SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &
        SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &
        SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &
        SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &
        SH_TYPE_FLOAT       = 22, &
        SH_TYPE_DOUBLE      = 23, &
        SH_TYPE_LONG_DOUBLE = 24, &
        SH_TYPE_FLOAT_COMPLEX      = 25, &
        SH_TYPE_DOUBLE_COMPLEX     = 26, &
        SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &
        SH_TYPE_BOOL      = 28, &
        SH_TYPE_CHAR      = 29, &
        SH_TYPE_CPTR      = 30, &
        SH_TYPE_STRUCT    = 31, &
        SH_TYPE_OTHER     = 32

    ! start helper array_context
    ! helper array_context
    type, bind(C) :: STR_SHROUD_array
        ! address of data
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type STR_SHROUD_array
    ! end helper array_context

    ! start helper capsule_data_helper
    ! helper capsule_data_helper
    type, bind(C) :: STR_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type STR_SHROUD_capsule_data
    ! end helper capsule_data_helper

    ! helper capsule_helper
    type :: STR_SHROUD_capsule
        private
        type(STR_SHROUD_capsule_data) :: mem
    contains
        final :: SHROUD_capsule_final
        procedure :: delete => SHROUD_capsule_delete
    end type STR_SHROUD_capsule

    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    interface
        subroutine init_test() &
                bind(C, name="STR_init_test")
            implicit none
        end subroutine init_test
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Statement: f_function_string_cfi_copy
    interface
        subroutine c_get_const_string_len_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_len_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringAlloc
    ! Statement: c_function_string
    interface
        function c_get_const_string_alloc(SHT_rv_capsule) &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringAlloc")
            use iso_c_binding, only : C_PTR
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringAlloc
    ! Statement: f_function_string_cfi_allocatable
    interface
        subroutine c_get_const_string_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringPointer +deref(pointer)
    ! Statement: f_function_string_cfi_pointer
    interface
        subroutine c_get_const_string_pointer_CFI(SHT_rv_capsule, &
                SHT_rv) &
                bind(C, name="STR_getConstStringPointer_CFI")
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            character(len=:), intent(OUT), pointer :: SHT_rv
        end subroutine c_get_const_string_pointer_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringRaw +deref(raw)
    ! Statement: f_function_string_raw
    interface
        function c_get_const_string_raw_bufferify(SHT_rv_capsule) &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRaw_bufferify")
            use iso_c_binding, only : C_PTR
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_raw_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  const string getConstStringAsArg +deref(copy)+funcarg
    ! Statement: f_function_string_cfi_funcarg_copy
    interface
        subroutine c_get_const_string_as_arg_CFI(output) &
                bind(C, name="STR_getConstStringAsArg_CFI")
            implicit none
            character(len=*), intent(OUT) :: output
        end subroutine c_get_const_string_as_arg_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLen +len(30)
    ! Statement: c_function_string&
    interface
        function c_get_const_string_ref_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ref_len
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLen +len(30)
    ! Statement: f_function_string&_cfi_copy
    interface
        subroutine c_get_const_string_ref_len_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ref_len_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLenEmpty +len(30)
    ! Statement: c_function_string&
    interface
        function c_get_const_string_ref_len_empty() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefLenEmpty")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ref_len_empty
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLenEmpty +len(30)
    ! Statement: f_function_string&_cfi_copy
    interface
        subroutine c_get_const_string_ref_len_empty_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefLenEmpty_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ref_len_empty_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string &getConstStringRefAlloc
    ! Statement: c_function_string&
    ! start c_get_const_string_ref_alloc
    interface
        function c_get_const_string_ref_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ref_alloc
    end interface
    ! end c_get_const_string_ref_alloc

    ! ----------------------------------------
    ! Function:  const std::string &getConstStringRefAlloc
    ! Statement: f_function_string&_cfi_allocatable
    ! start c_get_const_string_ref_alloc_CFI
    interface
        subroutine c_get_const_string_ref_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringRefAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ref_alloc_CFI
    end interface
    ! end c_get_const_string_ref_alloc_CFI

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefAsArg +deref(copy)+funcarg
    ! Statement: c_function_string&
    interface
        function c_get_const_string_ref_as_arg() &
                result(output) &
                bind(C, name="STR_getConstStringRefAsArg")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: output
        end function c_get_const_string_ref_as_arg
    end interface

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefAsArg +deref(copy)+funcarg
    ! Statement: f_function_string&_cfi_funcarg_copy
    interface
        subroutine c_get_const_string_ref_as_arg_CFI(output) &
                bind(C, name="STR_getConstStringRefAsArg_CFI")
            implicit none
            character(len=*), intent(OUT) :: output
        end subroutine c_get_const_string_ref_as_arg_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const string *getConstStringPtrLen +len(30)
    ! Statement: c_function_string*
    interface
        function c_get_const_string_ptr_len() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrLen")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_len
    end interface

    ! ----------------------------------------
    ! Function:  const string *getConstStringPtrLen +len(30)
    ! Statement: f_function_string*_cfi_copy
    interface
        subroutine c_get_const_string_ptr_len_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrLen_CFI")
            implicit none
            character(len=*), intent(OUT) :: SHT_rv
        end subroutine c_get_const_string_ptr_len_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrAlloc +owner(library)
    ! Statement: c_function_string*_library
    interface
        function c_get_const_string_ptr_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrAlloc +owner(library)
    ! Statement: f_function_string*_cfi_allocatable_library
    interface
        subroutine c_get_const_string_ptr_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ptr_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAlloc +owner(caller)
    ! Statement: c_function_string*_caller
    interface
        function c_get_const_string_ptr_owns_alloc() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_owns_alloc
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAlloc +owner(caller)
    ! Statement: f_function_string*_cfi_allocatable_caller
    interface
        subroutine c_get_const_string_ptr_owns_alloc_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ptr_owns_alloc_CFI
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAllocPattern +destructor_name(C_string_free)+owner(caller)
    ! Statement: c_function_string*_caller
    interface
        function c_get_const_string_ptr_owns_alloc_pattern() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_owns_alloc_pattern
    end interface

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAllocPattern +destructor_name(C_string_free)+owner(caller)
    ! Statement: f_function_string*_cfi_allocatable_caller
    interface
        subroutine c_get_const_string_ptr_owns_alloc_pattern_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrOwnsAllocPattern_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: SHT_rv
        end subroutine c_get_const_string_ptr_owns_alloc_pattern_CFI
    end interface

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Statement: c_function_string*_library
    interface
        function c_get_const_string_ptr_pointer() &
                result(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) :: SHT_rv
        end function c_get_const_string_ptr_pointer
    end interface
#endif

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Statement: f_function_string*_cfi_pointer_library
    interface
        subroutine c_get_const_string_ptr_pointer_CFI(SHT_rv) &
                bind(C, name="STR_getConstStringPtrPointer_CFI")
            implicit none
            character(len=:), intent(OUT), pointer :: SHT_rv
        end subroutine c_get_const_string_ptr_pointer_CFI
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string &arg1
    ! Statement: c_in_string&
    interface
        subroutine c_accept_string_const_reference(arg1) &
                bind(C, name="STR_acceptStringConstReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string &arg1
    ! Statement: f_in_string&_cfi
    interface
        subroutine accept_string_const_reference(arg1) &
                bind(C, name="STR_acceptStringConstReference_CFI")
            implicit none
            character(len=*), intent(IN) :: arg1
        end subroutine accept_string_const_reference
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1 +intent(out)
    ! Statement: c_out_string&
    interface
        subroutine c_accept_string_reference_out(arg1) &
                bind(C, name="STR_acceptStringReferenceOut")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1 +intent(out)
    ! Statement: f_out_string&_cfi
    interface
        subroutine accept_string_reference_out(arg1) &
                bind(C, name="STR_acceptStringReferenceOut_CFI")
            implicit none
            character(len=*), intent(OUT) :: arg1
        end subroutine accept_string_reference_out
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1
    ! Statement: c_inout_string&
    ! start c_accept_string_reference
    interface
        subroutine c_accept_string_reference(arg1) &
                bind(C, name="STR_acceptStringReference")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_reference
    end interface
    ! end c_accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1
    ! Statement: f_inout_string&_cfi
    ! start accept_string_reference
    interface
        subroutine accept_string_reference(arg1) &
                bind(C, name="STR_acceptStringReference_CFI")
            implicit none
            character(len=*), intent(INOUT) :: arg1
        end subroutine accept_string_reference
    end interface
    ! end accept_string_reference

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string *arg1
    ! Statement: c_in_string*
    interface
        subroutine c_accept_string_pointer_const(arg1) &
                bind(C, name="STR_acceptStringPointerConst")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
        end subroutine c_accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string *arg1
    ! Statement: f_in_string*_cfi
    interface
        subroutine accept_string_pointer_const(arg1) &
                bind(C, name="STR_acceptStringPointerConst_CFI")
            implicit none
            character(len=*), intent(IN) :: arg1
        end subroutine accept_string_pointer_const
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: c_inout_string*
    interface
        subroutine c_accept_string_pointer(arg1) &
                bind(C, name="STR_acceptStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
        end subroutine c_accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_cfi
    interface
        subroutine accept_string_pointer(arg1) &
                bind(C, name="STR_acceptStringPointer_CFI")
            implicit none
            character(len=*), intent(INOUT) :: arg1
        end subroutine accept_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: c_out_string*
    interface
        subroutine c_fetch_string_pointer(arg1) &
                bind(C, name="STR_fetchStringPointer")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
        end subroutine c_fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_cfi
    interface
        subroutine fetch_string_pointer(arg1) &
                bind(C, name="STR_fetchStringPointer_CFI")
            implicit none
            character(len=*), intent(OUT) :: arg1
        end subroutine fetch_string_pointer
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: c_inout_string*
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_acceptStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(INOUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_cfi
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    interface
        subroutine accept_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_acceptStringPointerLen_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(INOUT) :: arg1
            integer(C_INT), intent(OUT) :: nlen
        end subroutine accept_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: c_out_string*
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetchStringPointerLen")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(OUT) :: arg1(*)
            integer(C_INT), intent(OUT) :: nlen
        end subroutine c_fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_cfi
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    interface
        subroutine fetch_string_pointer_len(arg1, nlen) &
                bind(C, name="STR_fetchStringPointerLen_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(OUT) :: arg1
            integer(C_INT), intent(OUT) :: nlen
        end subroutine fetch_string_pointer_len
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Statement: c_function_native
    ! ----------------------------------------
    ! Argument:  std::string arg1
    ! Statement: c_in_string
    interface
        function c_accept_string_instance(arg1) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: arg1(*)
            integer(C_INT) :: SHT_rv
        end function c_accept_string_instance
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  std::string arg1
    ! Statement: f_in_string_cfi
    interface
        function accept_string_instance(arg1) &
                result(SHT_rv) &
                bind(C, name="STR_acceptStringInstance_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            character(len=*), intent(IN) :: arg1
            integer(C_INT) :: SHT_rv
        end function accept_string_instance
    end interface

#if 0
    ! Not Implemented
    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +dimension(nstrs)+intent(out)
    ! Statement: c_out_string**
    ! ----------------------------------------
    ! Argument:  int *nstrs +hidden+intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_array_string_arg(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringArg")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT), value :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_arg
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cfi_copy
    interface
        subroutine fetch_array_string_arg(strs) &
                bind(C, name="STR_fetchArrayStringArg_CFI")
            implicit none
            character(*), intent(OUT) :: strs(:)
        end subroutine fetch_array_string_arg
    end interface

#if 0
    ! Not Implemented
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Statement: c_out_string**
    ! ----------------------------------------
    ! Argument:  int *nstrs +hidden+intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_array_string_alloc(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAlloc")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT), value :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cfi_allocatable
    interface
        subroutine fetch_array_string_alloc(strs) &
                bind(C, name="STR_fetchArrayStringAlloc_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: strs(:)
        end subroutine fetch_array_string_alloc
    end interface

#if 0
    ! Not Implemented
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Statement: c_out_string**
    ! ----------------------------------------
    ! Argument:  int *nstrs +hidden+intent(out)
    ! Statement: c_out_native*
    interface
        subroutine c_fetch_array_string_alloc_len(strs, nstrs) &
                bind(C, name="STR_fetchArrayStringAllocLen")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT), value :: strs
            integer(C_INT), intent(OUT) :: nstrs
        end subroutine c_fetch_array_string_alloc_len
    end interface
#endif

    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Statement: f_out_string**_cfi_allocatable
    interface
        subroutine fetch_array_string_alloc_len(strs) &
                bind(C, name="STR_fetchArrayStringAllocLen_CFI")
            implicit none
            character(len=:), intent(OUT), allocatable :: strs(:)
        end subroutine fetch_array_string_alloc_len
    end interface

    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    interface
        subroutine cpass_char(status) &
                bind(C, name="CpassChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), value, intent(IN) :: status
        end subroutine cpass_char
    end interface

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    interface
        subroutine c_creturn_char(SHT_rv) &
                bind(C, name="STR_CreturnChar")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(OUT) :: SHT_rv
        end subroutine c_creturn_char
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Statement: c_subroutine
    ! ----------------------------------------
    ! Argument:  int *count +intent(in)+rank(1)
    ! Statement: c_in_native*
    ! ----------------------------------------
    ! Argument:  std::string &name
    ! Statement: c_inout_string&
    interface
        subroutine c_post_declare(count, name) &
                bind(C, name="STR_PostDeclare")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(*)
            character(kind=C_CHAR), intent(INOUT) :: name(*)
        end subroutine c_post_declare
    end interface

    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int *count +intent(in)+rank(1)
    ! Statement: f_in_native*_cfi
    ! ----------------------------------------
    ! Argument:  std::string &name
    ! Statement: f_inout_string&_cfi
    interface
        subroutine post_declare(count, name) &
                bind(C, name="STR_PostDeclare_CFI")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), intent(IN) :: count(:)
            character(len=*), intent(INOUT) :: name
        end subroutine post_declare
    end interface

    interface
        ! helper capsule_dtor
        ! Delete memory in a capsule.
        subroutine STR_SHROUD_capsule_dtor(ptr) &
            bind(C, name="STR_SHROUD_memory_destructor")
            import STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(INOUT) :: ptr
        end subroutine STR_SHROUD_capsule_dtor
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void init_test
    ! Statement: f_subroutine
    subroutine init_test()
        ! splicer begin function.init_test
        call c_init_test()
        ! splicer end function.init_test
    end subroutine init_test
#endif

    ! ----------------------------------------
    ! Function:  const string getConstStringLen +len(30)
    ! Statement: f_function_string_cfi_copy
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    function get_const_string_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_len
        call c_get_const_string_len_CFI(SHT_rv)
        ! splicer end function.get_const_string_len
    end function get_const_string_len

    ! ----------------------------------------
    ! Function:  const string getConstStringAlloc
    ! Statement: f_function_string_cfi_allocatable
    !>
    !! Return an ALLOCATABLE CHARACTER from std::string.
    !! The language=C wrapper will return a const char *
    !<
    function get_const_string_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_alloc
        call c_get_const_string_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_alloc
    end function get_const_string_alloc

    ! ----------------------------------------
    ! Function:  const string getConstStringPointer +deref(pointer)
    ! Statement: f_function_string_cfi_pointer
    !>
    !! Return an POINTER CHARACTER from std::string.
    !! The language=C wrapper will return a const char *
    !<
    function get_const_string_pointer(Crv) &
            result(SHT_rv)
        type(STR_SHROUD_capsule), intent(OUT) :: Crv
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_const_string_pointer
        call c_get_const_string_pointer_CFI(Crv%mem, SHT_rv)
        ! splicer end function.get_const_string_pointer
    end function get_const_string_pointer

    ! ----------------------------------------
    ! Function:  const string getConstStringRaw +deref(raw)
    ! Statement: f_function_string_raw
    !>
    !! Return an type(C_PTR) from std::string.
    !! The language=C wrapper will return a const char *
    !<
    function get_const_string_raw(Crv) &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR
        type(C_PTR) :: SHT_rv
        type(STR_SHROUD_capsule), intent(OUT) :: Crv
        ! splicer begin function.get_const_string_raw
        SHT_rv = c_get_const_string_raw_bufferify(Crv%mem)
        ! splicer end function.get_const_string_raw
    end function get_const_string_raw

    ! ----------------------------------------
    ! Function:  const string getConstStringAsArg +deref(copy)+funcarg
    ! Statement: f_function_string_cfi_funcarg_copy
    !>
    !! \brief return a 'const string' as argument
    !!
    !<
    subroutine get_const_string_as_arg(output)
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_as_arg
        call c_get_const_string_as_arg_CFI(output)
        ! splicer end function.get_const_string_as_arg
    end subroutine get_const_string_as_arg

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLen +len(30)
    ! Statement: f_function_string&_cfi_copy
    !>
    !! \brief return 'const string&' with fixed size (len=30)
    !!
    !! Since +len(30) is provided, the result of the function
    !! will be copied directly into memory provided by Fortran.
    !! The function will not be ALLOCATABLE.
    !<
    function get_const_string_ref_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len
        call c_get_const_string_ref_len_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_len
    end function get_const_string_ref_len

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefLenEmpty +len(30)
    ! Statement: f_function_string&_cfi_copy
    !>
    !! \brief Test returning empty string reference
    !!
    !<
    function get_const_string_ref_len_empty() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ref_len_empty
        call c_get_const_string_ref_len_empty_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_len_empty
    end function get_const_string_ref_len_empty

    ! ----------------------------------------
    ! Function:  const std::string &getConstStringRefAlloc
    ! Statement: f_function_string&_cfi_allocatable
    !>
    !! \brief return a 'const string&' as ALLOCATABLE character
    !!
    !<
    ! start get_const_string_ref_alloc
    function get_const_string_ref_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ref_alloc
        call c_get_const_string_ref_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_ref_alloc
    end function get_const_string_ref_alloc
    ! end get_const_string_ref_alloc

    ! ----------------------------------------
    ! Function:  const string &getConstStringRefAsArg +deref(copy)+funcarg
    ! Statement: f_function_string&_cfi_funcarg_copy
    !>
    !! \brief return a 'const string&' as argument
    !!
    !! Pass an additional argument which will be used as the return value.
    !! The length of the output variable is declared by the caller.
    !<
    subroutine get_const_string_ref_as_arg(output)
        character(len=*), intent(OUT) :: output
        ! splicer begin function.get_const_string_ref_as_arg
        call c_get_const_string_ref_as_arg_CFI(output)
        ! splicer end function.get_const_string_ref_as_arg
    end subroutine get_const_string_ref_as_arg

    ! ----------------------------------------
    ! Function:  const string *getConstStringPtrLen +len(30)
    ! Statement: f_function_string*_cfi_copy
    !>
    !! \brief return a 'const string *' as character(30)
    !!
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished with C_finalize_buf which is possible
    !! because +len(30) so the contents are copied before returning.
    !<
    function get_const_string_ptr_len() &
            result(SHT_rv)
        character(len=30) :: SHT_rv
        ! splicer begin function.get_const_string_ptr_len
        call c_get_const_string_ptr_len_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_len
    end function get_const_string_ptr_len

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrAlloc +owner(library)
    ! Statement: f_function_string*_cfi_allocatable_library
    function get_const_string_ptr_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_alloc
        call c_get_const_string_ptr_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_alloc
    end function get_const_string_ptr_alloc

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAlloc +owner(caller)
    ! Statement: f_function_string*_cfi_allocatable_caller
    !>
    !! It is the caller's responsibility to release the string
    !! created by the C++ library.
    !! This is accomplished +owner(caller) which sets idtor.
    !! The contents are copied by Fortran so they must outlast
    !! the return from the C wrapper.
    !<
    function get_const_string_ptr_owns_alloc() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc
        call c_get_const_string_ptr_owns_alloc_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_owns_alloc
    end function get_const_string_ptr_owns_alloc

    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrOwnsAllocPattern +destructor_name(C_string_free)+owner(caller)
    ! Statement: f_function_string*_cfi_allocatable_caller
    !>
    !! Similar to getConstStringPtrOwnsAlloc, but uses pattern to release memory.
    !<
    function get_const_string_ptr_owns_alloc_pattern() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_const_string_ptr_owns_alloc_pattern
        call c_get_const_string_ptr_owns_alloc_pattern_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_owns_alloc_pattern
    end function get_const_string_ptr_owns_alloc_pattern

#ifdef HAVE_CHARACTER_POINTER_FUNCTION
    ! ----------------------------------------
    ! Function:  const std::string *getConstStringPtrPointer +deref(pointer)+owner(library)
    ! Statement: f_function_string*_cfi_pointer_library
    function get_const_string_ptr_pointer() &
            result(SHT_rv)
        character(len=:), pointer :: SHT_rv
        ! splicer begin function.get_const_string_ptr_pointer
        call c_get_const_string_ptr_pointer_CFI(SHT_rv)
        ! splicer end function.get_const_string_ptr_pointer
    end function get_const_string_ptr_pointer
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void acceptStringConstReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string &arg1
    ! Statement: f_in_string&_cfi
    !>
    !! \brief Accept a const string reference
    !!
    !! Save contents of arg1.
    !! arg1 is assumed to be intent(IN) since it is const
    !! Will copy in.
    !<
    subroutine accept_string_const_reference(arg1)
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_const_reference
        call c_accept_string_const_reference_CFI(arg1)
        ! splicer end function.accept_string_const_reference
    end subroutine accept_string_const_reference
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void acceptStringReferenceOut
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1 +intent(out)
    ! Statement: f_out_string&_cfi
    !>
    !! \brief Accept a string reference
    !!
    !! Set out to a constant string.
    !! arg1 is intent(OUT)
    !! Must copy out.
    !<
    subroutine accept_string_reference_out(arg1)
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.accept_string_reference_out
        call c_accept_string_reference_out_CFI(arg1)
        ! splicer end function.accept_string_reference_out
    end subroutine accept_string_reference_out
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void acceptStringReference
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string &arg1
    ! Statement: f_inout_string&_cfi
    !>
    !! \brief Accept a string reference
    !!
    !! Append "dog" to the end of arg1.
    !! arg1 is assumed to be intent(INOUT)
    !! Must copy in and copy out.
    !<
    ! start accept_string_reference
    subroutine accept_string_reference(arg1)
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_reference
        call c_accept_string_reference_CFI(arg1)
        ! splicer end function.accept_string_reference
    end subroutine accept_string_reference
    ! end accept_string_reference
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void acceptStringPointerConst
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  const std::string *arg1
    ! Statement: f_in_string*_cfi
    !>
    !! \brief Accept a const string pointer - intent(in)
    !!
    !<
    subroutine accept_string_pointer_const(arg1)
        character(len=*), intent(IN) :: arg1
        ! splicer begin function.accept_string_pointer_const
        call c_accept_string_pointer_const_CFI(arg1)
        ! splicer end function.accept_string_pointer_const
    end subroutine accept_string_pointer_const
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void acceptStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_cfi
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !<
    subroutine accept_string_pointer(arg1)
        character(len=*), intent(INOUT) :: arg1
        ! splicer begin function.accept_string_pointer
        call c_accept_string_pointer_CFI(arg1)
        ! splicer end function.accept_string_pointer
    end subroutine accept_string_pointer
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void fetchStringPointer
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_cfi
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !<
    subroutine fetch_string_pointer(arg1)
        character(len=*), intent(OUT) :: arg1
        ! splicer begin function.fetch_string_pointer
        call c_fetch_string_pointer_CFI(arg1)
        ! splicer end function.fetch_string_pointer
    end subroutine fetch_string_pointer
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void acceptStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1
    ! Statement: f_inout_string*_cfi
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    !>
    !! \brief Accept a string pointer - intent(inout)
    !!
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine accept_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(INOUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.accept_string_pointer_len
        call c_accept_string_pointer_len_CFI(arg1, nlen)
        ! splicer end function.accept_string_pointer_len
    end subroutine accept_string_pointer_len
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void fetchStringPointerLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string *arg1 +intent(out)
    ! Statement: f_out_string*_cfi
    ! ----------------------------------------
    ! Argument:  int *nlen +intent(out)
    ! Statement: f_out_native*
    !>
    !! \brief Accept a string pointer - intent(out)
    !!
    !! Return global_str.
    !! Test return tuple with two arguments.
    !! Must rename argument to nlen to avoid conflict with intrinsic len.
    !<
    subroutine fetch_string_pointer_len(arg1, nlen)
        use iso_c_binding, only : C_INT
        character(len=*), intent(OUT) :: arg1
        integer(C_INT), intent(OUT) :: nlen
        ! splicer begin function.fetch_string_pointer_len
        call c_fetch_string_pointer_len_CFI(arg1, nlen)
        ! splicer end function.fetch_string_pointer_len
    end subroutine fetch_string_pointer_len
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  int acceptStringInstance
    ! Statement: f_function_native
    ! ----------------------------------------
    ! Argument:  std::string arg1
    ! Statement: f_in_string_cfi
    !>
    !! \brief Accept a string instance
    !!
    !<
    function accept_string_instance(arg1) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: arg1
        integer(C_INT) :: SHT_rv
        ! splicer begin function.accept_string_instance
        SHT_rv = c_accept_string_instance_CFI(arg1)
        ! splicer end function.accept_string_instance
    end function accept_string_instance
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void fetchArrayStringArg
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cfi_copy
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !<
    subroutine fetch_array_string_arg(strs)
        character(len=*), intent(OUT) :: strs(nstrs)
        ! splicer begin function.fetch_array_string_arg
        call c_fetch_array_string_arg_CFI(strs)
        ! splicer end function.fetch_array_string_arg
    end subroutine fetch_array_string_arg
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAlloc
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)
    ! Statement: f_out_string**_cfi_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the maximum string length.
    !<
    subroutine fetch_array_string_alloc(strs)
        character(len=:), intent(OUT), allocatable :: strs(:)
        ! splicer begin function.fetch_array_string_alloc
        call c_fetch_array_string_alloc_CFI(strs)
        ! splicer end function.fetch_array_string_alloc
    end subroutine fetch_array_string_alloc
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void fetchArrayStringAllocLen
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  std::string **strs +deref(allocatable)+dimension(nstrs)+intent(out)+len(20)
    ! Statement: f_out_string**_cfi_allocatable
    !>
    !! Copy output into argument strs which must be large enough
    !! to hold values.  Excess values will be truncated.
    !! The nstrs argument is the length of the array.
    !! It is associated with strs via the dimension(nstrs) attribute.
    !! +hidden indicates that it is not part of the Fortran API.
    !! The defered length is set to the len attribute.
    !<
    subroutine fetch_array_string_alloc_len(strs)
        character(len=:), intent(OUT), allocatable :: strs(:)
        ! splicer begin function.fetch_array_string_alloc_len
        call c_fetch_array_string_alloc_len_CFI(strs)
        ! splicer end function.fetch_array_string_alloc_len
    end subroutine fetch_array_string_alloc_len
#endif

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void CpassChar
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  char status
    ! Statement: f_in_char
    !>
    !! \brief pass a single char argument as a scalar, extern "C"
    !!
    !<
    subroutine cpass_char(status)
        character, value, intent(IN) :: status
        ! splicer begin function.cpass_char
        call c_cpass_char(status)
        ! splicer end function.cpass_char
    end subroutine cpass_char
#endif

    ! ----------------------------------------
    ! Function:  char CreturnChar
    ! Statement: f_function_char
    !>
    !! \brief return a char argument (non-pointer), extern "C"
    !!
    !<
    function creturn_char() &
            result(SHT_rv)
        character :: SHT_rv
        ! splicer begin function.creturn_char
        call c_creturn_char(SHT_rv)
        ! splicer end function.creturn_char
    end function creturn_char

#if 0
    ! Only the interface is needed
    ! ----------------------------------------
    ! Function:  void PostDeclare
    ! Statement: f_subroutine
    ! ----------------------------------------
    ! Argument:  int *count +intent(in)+rank(1)
    ! Statement: f_in_native*_cfi
    ! ----------------------------------------
    ! Argument:  std::string &name
    ! Statement: f_inout_string&_cfi
    !>
    !! Test post_declare.
    !! The std::string in py_string_inout must be declared before the
    !! goto added by py_native_*_in_pointer_list to avoid
    !! "jump to label 'fail' crosses initialization of" error.
    !<
    subroutine post_declare(count, name)
        use iso_c_binding, only : C_INT
        integer(C_INT), intent(IN) :: count(:)
        character(len=*), intent(INOUT) :: name
        ! splicer begin function.post_declare
        call c_post_declare_CFI(count, name)
        ! splicer end function.post_declare
    end subroutine post_declare
#endif

    ! splicer begin additional_functions
    ! splicer end additional_functions

    ! helper capsule_helper
    ! finalize a static STR_SHROUD_capsule_data
    subroutine SHROUD_capsule_final(cap)
        type(STR_SHROUD_capsule), intent(INOUT) :: cap
        call STR_SHROUD_capsule_dtor(cap%mem)
    end subroutine SHROUD_capsule_final

    subroutine SHROUD_capsule_delete(cap)
        class(STR_SHROUD_capsule) :: cap
        call STR_SHROUD_capsule_dtor(cap%mem)
    end subroutine SHROUD_capsule_delete

end module strings_mod

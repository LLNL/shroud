# test names options
# These tests are not compiled.
# Various format combinations are tested.

copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2019, Lawrence Livermore National Security, LLC.'
-
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
-
- 'All rights reserved.'
-
- 'This file is part of Shroud.'
-
- 'For details about use and distribution, please read LICENSE.'
-
- '#######################################################################'

library: testnames

options:
  debug: True

  # always create wrappers to demonstrate name generation
  F_force_wrapper: True
#  F_module_per_class: False
  wrap_python: True

format:
  C_argument: ARG_
  C_header_filename_suffix: hh
  C_impl_filename_suffix: cc
  F_filename_suffix: F

  C_header_filename: top.h
  C_impl_filename: top.cpp
  F_module_name: top_module
  F_impl_filename: top.f
  LUA_module_name: lua_module_name

  PY_type_obj: myobj
  PY_type_dtor: mydtor

declarations:
- decl: |
      enum Color {
        RED,
        BLUE,
        WHITE
      };
  options:
     bar: 4
  format:
     baz: 4  


- decl: namespace ns0
  format:
    # C_header_filename is not created.
    C_header_filename: foons0.h
    C_impl_filename: foons0.cpp
    F_module_name: name_module
    F_impl_filename: foo.f
  declarations:
  - decl: class Names
    options:
      none: foo
      C_name_template: XXX_{C_prefix}{class_prefix}{underscore_name}{function_suffix}
      F_C_name_template: XXX_{C_prefix}{class_prefix}{underscore_name}{function_suffix}
    format:
      C_header_filename: foo.h
      C_impl_filename: foo.cpp
      F_derived_name: FNames
  
    declarations:
    - decl: void method1()
      format:
        F_name_function: type_method1
    - decl: void method2()
      format:
        C_this: self2
        CXX_this: SH_this2
        F_this:  obj2

# test file suffix
- decl: class Names2
  declarations: []

- block: True
  options:
    C_name_template: YYY_{C_prefix}{underscore_name}{function_suffix}
    F_C_name_template: YYY_{C_prefix}{underscore_name}{function_suffix}
    F_name_impl_template: "{library}_{class_prefix}{underscore_name}{function_suffix}"
  declarations:
  - decl: void function1()
  - decl: void function2()
    format:
      C_name: c_name_special
      F_C_name: f_c_name_special
      F_name_impl: f_name_special

  # test generic/overloaded functions
  - decl: void function3a(int i)
    format:
      F_name_generic: generic3
      F_name_impl: F_name_function3a_int
  - decl: void function3a(long i)
    format:
      F_name_generic: generic3
      F_name_impl: F_name_function3a_long

  # test F_result
  # test C_result  with arg rv
  - decl: int function4(const std::string &rv)

  - decl: void function5() +name(fiveplus)

- decl: namespace ns1
  options:
    # test options in namespace
    F_name_impl_template: "{library_lower}_{class_prefix}{underscore_name}{function_suffix}"
  declarations:
  - decl: void init_ns1()

########################################
# Copied from templates.yaml
# Test class.format.template_suffix
- decl: namespace internal
  declarations:
# Class which is used to instantiate the C++ template.
# It is not part of the Fortran API.
  - decl: class ImplWorker1
    format:
      template_suffix: _instantiation3
    options:
      wrap_fortran: false
      wrap_python: false



# Function with multiple template arguments.
# Copied from templates.yaml, test replacing generated names
- decl: template<T,U> void FunctionTU(T arg1, U arg2)
  doxygen:
     brief: Function template with two template parameters.
  cxx_template:
  - instantiation: <int, long>
    format:
      C_name: c_name_instantiation1
      F_C_name: f_c_name_instantiation1
      F_name_impl: f_name_instantiation1
      PY_name_impl: PY_name_instantiation1
  - instantiation: <float, double>
    format:
      template_suffix: _instantiation2

# Class with single template argument.
# Copied from templates.yaml.
- decl: namespace std
  declarations:
  - decl: template<typename T> class vector
    # std::vector class
    cxx_header: <vector>
    cxx_template:
    - instantiation: <int>
      format:
        # Explicit class name.
        # XXX - Necessary to specify lower and upper.
        cxx_class: Vvv1
#        class_lower: vvv1     # automatically set from cxx_class
#        class_upper: VVV1     # automatically set from cxx_class
#        class_scope: 'VvV1::' # automatically set from cxx_class
        F_derived_name: FFvvv1
    - instantiation: <double>
      # Based on template typename.   vector_double
    - instantiation: <long>
      # Explicit template_suffix.     vector_instantiation5
      format:
        template_suffix: _instantiation5
    - instantiation: <internal::ImplWorker1>
      # Use template_suffix from internal::ImplWorker.  vector_instantiation3

# Class with multiple template arguments.
- decl: template<typename T1, typename T2> class twoTs
  cxx_template:
  - instantiation: <int, long>
    # template_suffix will be sequence number
  - instantiation: <float, double>
    format:
      template_suffix: _instantiation4

########################################
# Copied from templates.yaml
- decl: template<typename T> int UseImplWorker()
  doxygen:
     brief: Function which uses a templated T in the implemetation.
  cxx_template:
  - instantiation: <internal::ImplWorker1>

########################################
# Test explicit splicers
# class Name2 has no methods by default it would not be written.
splicer_code:
   c:
     CXX_definitions:
       - // Add some text from splicer
       - // And another line
     class:
       Names2:
         C_definitions:
           - int write_file;
TEMP: True

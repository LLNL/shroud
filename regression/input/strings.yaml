copyright:
- Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
- other Shroud Project Developers.
- See the top-level COPYRIGHT file for details.
-
- "SPDX-License-Identifier: (BSD-3-Clause)"
-
#
# Test the many variations of strings
#

library: strings
cxx_header: strings.hpp shroud/features.h
fortran_header: shroud/features.h

options:
  debug: True
  wrap_python: True
  literalinclude2: True

declarations:

- decl: void init_test(void)

########################################
# return std::string
# These must allocate a std::string in the wrapper to
# hold the return value.
# Do not wrap the variants of this test for C.
# They would all be the same.

- decl: const string getConstStringLen() +len=30
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string' as argument
  options:
    wrap_c: False

- decl: const string getConstStringAlloc()
  doxygen:
    description: |
      Return an ALLOCATABLE CHARACTER from std::string.
      The language=C wrapper will return a const char *

#####
# Return function result in an argument.

- decl: const string getConstStringAsArg() +deref(copy)+funcarg
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string' as argument
  options:
    wrap_c: False

########################################
# return std::string reference

- decl: const string& getConstStringRefLen() +len=30
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return 'const string&' with fixed size (len=30)
    description: |
       Since +len(30) is provided, the result of the function
       will be copied directly into memory provided by Fortran.
       The function will not be ALLOCATABLE.
#  attrs:
#    result:
#      len: 30

- decl: const string& getConstStringRefLenEmpty() +len=30
  C_error_pattern: C_invalid_name
  doxygen:
    brief: Test returning empty string reference

- decl: const std::string& getConstStringRefAlloc()
#  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string&' as ALLOCATABLE character
  options:
    literalinclude: True

#####
# Return function result in an argument.

- decl: const string& getConstStringRefAsArg() +deref(copy)+funcarg
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string&' as argument
    description: |
      Pass an additional argument which will be used as the return value.
      The length of the output variable is declared by the caller.

########################################
# return std::string pointer

- decl: const string * getConstStringPtrLen() +len=30
# XXX? +owner=caller
#  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string *' as character(30)
    description: |
      It is the caller's responsibility to release the string
      created by the C++ library.
      This is accomplished with C_finalize_buf which is possible
      because +len(30) so the contents are copied before returning.
  fstatements:
    f:
      c_final:
      - delete {cxx_var};

- decl: const std::string * getConstStringPtrAlloc() +owner(library)

- decl: const std::string * getConstStringPtrOwnsAlloc() +owner(caller)
  doxygen:
    description: |
      It is the caller's responsibility to release the string
      created by the C++ library.
      This is accomplished +owner(caller) which sets idtor.
      The contents are copied by Fortran so they must outlast
      the return from the C wrapper.

- decl: const std::string * getConstStringPtrOwnsAllocPattern() +owner(caller)
  doxygen:
    description: |
      Similar to getConstStringPtrOwnsAlloc, but uses pattern to release memory.
  fattrs:
    free_pattern: C_string_free

- decl: const std::string * getConstStringPtrPointer()
            +deref(pointer)+owner(library)
  options:
    wrap_python: False
  cpp_if: ifdef HAVE_CHARACTER_POINTER_FUNCTION

#- decl: const std::string * getConstStringPtrOwnsPointer()
#            +deref(pointer)+owner(library)
#  doxygen:
#    description: |
#      Add an extra capsule argument to control allocation of memory.
#  options:
#    wrap_python: False


########################################
# std::string argument

- decl: void acceptStringConstReference(const std::string & arg1)
  doxygen:
    brief: Accept a const string reference
    description: |
       Save contents of arg1.
       arg1 is assumed to be intent(IN) since it is const
       Will copy in.

- decl: void acceptStringReferenceOut(std::string & arg1+intent(out))
  doxygen:
    brief: Accept a string reference
    description: |
       Set out to a constant string.
       arg1 is intent(OUT)
       Must copy out.

- decl: void acceptStringReference(std::string & arg1)
  doxygen:
    brief: Accept a string reference
    description: |
       Append "dog" to the end of arg1.
       arg1 is assumed to be intent(INOUT)
       Must copy in and copy out.
  options:
    literalinclude: True

- decl: void acceptStringPointerConst(const std::string * arg1)
  doxygen:
    brief: Accept a const string pointer - intent(in)

- decl: void acceptStringPointer(std::string * arg1)
  doxygen:
    brief: Accept a string pointer - intent(inout)

- decl: void fetchStringPointer(std::string * arg1 +intent(out))
  doxygen:
    brief: Accept a string pointer - intent(out)
    description: |
      Return global_str.

- decl: void acceptStringPointerLen(std::string * arg1,
                                    int *nlen+intent(out))
  doxygen:
    brief: Accept a string pointer - intent(inout)
    description: |
      Test return tuple with two arguments.
      Must rename argument to nlen to avoid conflict with intrinsic len.

- decl: void fetchStringPointerLen(std::string * arg1 +intent(out),
                                   int *nlen+intent(out))
  doxygen:
    brief: Accept a string pointer - intent(out)
    description: |
      Return global_str.
      Test return tuple with two arguments.
      Must rename argument to nlen to avoid conflict with intrinsic len.

- decl: int acceptStringInstance(std::string arg1)
  doxygen:
    brief: Accept a string instance

- decl: void returnStrings(std::string & arg1 +intent(out),
                           std::string & arg2 +intent(out))
  doxygen:
    brief: Test Python returning multiple std::string arguments.
  options:
    wrap_c: false
    wrap_fortran: false

##### Variations of fetching a std::string pointer
- decl: void fetchArrayStringArg(
            std::string **strs +intent(out)+dimension(nstrs),
            int *nstrs+intent(out)+hidden);
  doxygen:
     description: |
        Copy output into argument strs which must be large enough
        to hold values.  Excess values will be truncated.
        The nstrs argument is the length of the array.
        It is associated with strs via the dimension(nstrs) attribute.
        +hidden indicates that it is not part of the Fortran API.
  options:
    wrap_python: false

- decl: void fetchArrayStringAlloc(
            std::string **strs +intent(out)+dimension(nstrs)+deref(allocatable),
            int *nstrs+intent(out)+hidden);
  doxygen:
     description: |
        Copy output into argument strs which must be large enough
        to hold values.  Excess values will be truncated.
        The nstrs argument is the length of the array.
        It is associated with strs via the dimension(nstrs) attribute.
        +hidden indicates that it is not part of the Fortran API.
        The defered length is set to the maximum string length.
  options:
    wrap_python: false

- decl: void fetchArrayStringAllocLen(
            std::string **strs +intent(out)+len(20)+dimension(nstrs)+deref(allocatable),
            int *nstrs+intent(out)+hidden);
  doxygen:
     description: |
        Copy output into argument strs which must be large enough
        to hold values.  Excess values will be truncated.
        The nstrs argument is the length of the array.
        It is associated with strs via the dimension(nstrs) attribute.
        +hidden indicates that it is not part of the Fortran API.
        The defered length is set to the len attribute.
  options:
    wrap_python: false

################################################################################
# extern "C"  C++ functions

- decl: void CpassChar(char status)
  doxygen:
    brief: pass a single char argument as a scalar, extern "C"
  options:
    C_extern_C: true

- decl: char CreturnChar()
  doxygen:
    brief: return a char argument (non-pointer), extern "C"
  options:
    C_extern_C: true

########################################

- decl: void PostDeclare(int *count +rank(1)+intent(in), std::string &name)
  options:
    PY_array_arg: list
  doxygen:
    description: |
      Test post_declare.
      The std::string in py_string_inout must be declared before the
      goto added by py_native_*_in_pointer_list to avoid
      "jump to label 'fail' crosses initialization of" error.

########################################
patterns:
    C_invalid_name: |
        if ({cxx_var}.empty()) {{
            return NULL;
        }}
    # return a blank field string if an error occurs
    C_invalid_name_buf: |
        // Some error code for buf

     # This pattern is added to C_memory_dtor_function
     # XXX - \t is not dealt with properly
    C_string_free: |
        // Used with +free_pattern(C_string_free)
        std::string *cxx_ptr = reinterpret_cast<std::string *>(ptr);
        delete cxx_ptr;

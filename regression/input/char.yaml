copyright:
- Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
- other Shroud Project Developers.
- See the top-level COPYRIGHT file for details.
-
- "SPDX-License-Identifier: (BSD-3-Clause)"
-
#
# Test the many variations of char
#

library: char
cxx_header: char.h shroud/features.h
fortran_header: shroud/features.h

options:
  debug: True
  wrap_python: True
  literalinclude2: True

declarations:

- decl: void init_test(void)

########################################
- decl: void passChar(char status)
  doxygen:
    brief: pass a single char argument as a scalar.

- decl: void passCharForce(char status)
  options:
    F_force_wrapper: True
    wrap_python: False
  doxygen:
    description: |
      By default no Fortran wrapper is created.
      Force one so it can be tested.

- decl: char returnChar()
  doxygen:
    brief: return a char argument (non-pointer)

########################################
# char * argument

- decl: void passCharPtr(char * dest+intent(out)+charlen(40), const char *src)
  # XXX - maybe charlen(strlen(src)+1)
  doxygen:
    brief: strcpy like behavior
    description: |
      dest is marked intent(OUT) to override the intent(INOUT) default
      This avoid a copy-in on dest.
      In Python, src must not be over 40 characters, defined by charlen.
  options:
    # This copies into 'dest' which must be allocated first
    # and does not work with Python
    wrap_lua: False
    literalinclude: True

- decl: void passCharPtrInOut(char * s+intent(inout))
  doxygen:
    brief: toupper
    description: |
      Change a string in-place.
      For Python, return a new string since strings are immutable.

########################################
# char * function

- decl: const char * getCharPtr1()
  doxygen:
    description: |
      Return an ALLOCATABLE CHARACTER from char *.
  options:
    literalinclude: True

- decl: const char *getConstCharPtrLen() +len(30)
  doxygen:
    brief: return 'const char *' with fixed size (len=30)
  options:
    literalinclude: True

- decl: const char *getConstCharPtrAsArg()
  doxygen:
    brief: return a 'const char *' as argument
  options:
    literalinclude: True
  format:
    F_string_result_as_arg: output

- decl: const char * getCharPtr4() +deref(raw)
  doxygen:
    brief: return a 'const char *' as type(C_PTR)
  options:
    wrap_python: False

- decl: const char * getCharPtr5() +deref(pointer)
  doxygen:
    brief: return a 'const char *' as character(:) pointer
  options:
    wrap_python: False
  cpp_if: ifdef HAVE_CHARACTER_POINTER_FUNCTION
#    literalinclude: True

#####
- decl: char returnMany(int *arg1 +intent(out))
  doxygen:
    description: |
       Test Py_BuildValue with multiple values.
  options:
    wrap_python: false
    wrap_c: false
    wrap_fortran: false

########################################
# explicit annotations
# Currently explicit len/len_trim conflict with auto generated one and do not compile
# local declarations shadow parameter

- decl: void explicit1(char * name+len_trim(AAlen)+intent(in))
  format:
    C_bufferify_suffix: _BUFFER
# len_trim is added for free because intent(in)

- decl: void explicit2(char * name+len(AAtrim)+intent(out))
# len is added for free because intent(out)
  options:
    # This copies into 'name' which must be allocated first
    # and does not work with Python
    wrap_python: False
    wrap_lua: False

#- decl: void explicit3(char * name+len(AAlen)+len_trim(AAtrim))
# set names for len/len_trim annotations

################################################################################

- decl: void CpassChar(char status)
  doxygen:
    brief: pass a single char argument as a scalar, extern "C"

- decl: char CreturnChar()
  doxygen:
    brief: return a char argument (non-pointer), extern "C"

########################################
# char * argument

- decl: void CpassCharPtr(char * dest+intent(out), const char *src+blanknull)
  options:
    C_extern_C: true
    # This copies into 'dest' which must be allocated first
    # and does not work with Python
    wrap_python: False
    wrap_lua: False
  doxygen:
    brief: strcpy like behavior
    description: |
      dest is marked intent(OUT) to override the intent(INOUT) default
      This avoid a copy-in on dest.
      extern "C"
      If src is a blank string, pass a NULL pointer to C library function.

- decl: void CpassCharPtrBlank(char * dest+intent(out), const char *src)
  doxygen:
    brief: Test F_blanknull option
  options:
    wrap_python: False
    wrap_lua: False
    F_blanknull: True

- decl: int CpassCharPtrNotrim(const char *src)
  doxygen:
    brief: NULL terminate input string in C, not in Fortran.
  options:
    F_trim_char_in: False
    wrap_python: False

- decl: int CpassCharPtrCAPI(void *addr, const char *src +api(capi))
  doxygen:
    brief: Do not NULL terminate input string
    description: |
      The C library function should get the same address
      for addr and src.
      Used when the C function needs the true address of the argument.
      Skips null-termination. Useful to create an interface for
      a function which is already callable by Fortran.
      For example, the length is passed explicitly.
      This example will not create a Fortran wrapper since C can be
      called directly.
  options:
    wrap_python: False

- decl: int CpassCharPtrCAPI2(const char *in, const char *src +api(capi))
  doxygen:
    brief: Mix api(buf) and api(capi)
  options:
    wrap_python: False

########################################
# Deal with 'char **' arguments
# Python: treat as list of string, even with numpy.

- decl: int acceptCharArrayIn(char **names +intent(in))
  doxygen:
    description: |
      Return strlen of the first index as a check.

########################################
patterns:
    C_invalid_name: |
        if ({cxx_var}.empty()) {{
            return NULL;
        }}
    # return a blank field string if an error occurs
    C_invalid_name_buf: |
        // Some error code for buf

     # This pattern is added to C_memory_dtor_function
     # XXX - \t is not dealt with properly
    C_string_free: |
        // Used with +free_pattern(C_string_free)
        std::string *cxx_ptr = reinterpret_cast<std::string *>(ptr);
        delete cxx_ptr;

[
    {
        "name":"##### header mixin #########################################",
        "notes": [
            "Use header for C or C++.",
            "Use {stdlib} before funtion call to include namespace."
        ]
    },
    {
        "name": "c_mixin_header_stddef",
        "lang_c": {
            "impl_header": [
                "<stddef.h>"
            ]
        },
        "lang_cxx": {
            "impl_header": [
                "<cstddef>"
            ]
        }
    },
    {
        "name": "c_mixin_header_stdlib",
        "notes": [
            "malloc, free.",
            "C++ will use new and delete."
        ],
        "lang_c": {
            "impl_header": [
                "<stdlib.h>"
            ]
        },
        "##lang_cxx": {
            "impl_header": [
                "<cstdlib>"
            ]
        }
    },
    {
        "name": "c_mixin_header_cstring",
        "notes": [
            "strlen, memcpy"
        ],
        "lang_c": {
            "impl_header": [
                "<string.h>"
            ]
        },
        "lang_cxx": {
            "impl_header": [
                "<cstring>"
            ]
        }
    },
    {
        "name":"##### fortran argument mixin ###############################"
    },
    {
        "name": "f_mixin_dummy_arg",
        "notes": [
            "Pass the library argument to the Fortran wrapper."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ]
    },
    {
        "name": "f_mixin_declare-local-variable",
        "comments": [
            "Declare a Fortran variable."
        ],
        "notes": [
            "Used with function results."
        ],
        "f_dummy_decl": [
            "{f_type}{f_value_attr}{f_intent_attr}{f_deref_attr}{f_target_attr}{f_optional_attr} :: {f_var}{f_dimension}"
        ],
        "f_module": {
            "{f_module_name}": [
                "{f_kind}"
            ]
        }
    },
    {
        "sphinx-start-after": "f_mixin_declare-fortran-arg",
        "name": "f_mixin_declare-fortran-arg",
        "notes": [
            "Fortran wrapper argument."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "{f_type}{f_value_attr}{f_intent_attr}{f_deref_attr}{f_target_attr}{f_optional_attr} :: {f_var}{f_dimension}"
        ],
        "f_module": {
            "{f_module_name}": [
                "{f_kind}"
            ]
        },
        "sphinx-end-before": "f_mixin_declare-fortran-arg"
    },
    {
        "name": "f_mixin_declare-character-arg",
        "notes": [
            "Fortran wrapper argument.",
            "Used with allocatable.",
            "No need for f_module."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "character(len=:){f_intent_attr}{f_deref_attr}{f_target_attr} :: {f_var}{f_assumed_shape}"
        ]
    },
    {
        "name": "f_mixin_declare-arg-as-cptr",
        "notes": [
            "Used when there is no direct mapping to Fortran.",
            "C argument maps to void **."
        ],
        "f_dummy_decl": [
            "type(C_PTR){f_intent_attr} :: {f_var}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "f_mixin_function-as-cptr",
        "comments": [
            "Declare function result as a type(C_PTR)."
        ],
        "f_dummy_decl": [
            "type(C_PTR) :: {f_var}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "f_mixin_arg-call-fvar",
        "comments": [
            "Pass Fortran variable to C wrapper."
        ],
        "f_arg_call": [
            "{f_var}"
        ]
    },
    {
        "name":"##### interface argument mixin #############################"
    },
    {
        "name": "c_mixin_dummy_arg",
        "notes": [
            "Pass the Fortran wrapper argument to the interface."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ]
    },
    {
        "sphinx-start-after": "f_mixin_declare-interface-arg",
        "name": "f_mixin_declare-interface-arg",
        "notes": [
            "Declarations for Fortran interface."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "{i_type}{f_value_attr}{i_intent_attr} :: {i_var}{i_dimension}"
        ],
        "i_module": {
            "{i_module_name}": [
                "{i_kind}"
            ]
        },
        "sphinx-end-before": "f_mixin_declare-interface-arg"
    },
    {
        "name": "f_mixin_interface-as-cptr",
        "notes": [
            "Pass the address of the argument directly to C.",
            "Used when there is no direct mapping to Fortran."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "type(C_PTR){i_intent_attr} :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "f_mixin_interface-as-cptr-array",
        "notes": [
            "Pass an array of address of the argument directly to C.",
            "Used when there is no direct mapping to Fortran.",
            "ex. char **"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "type(C_PTR){i_intent_attr} :: {i_var}(*)"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "f_mixin_interface-as-cptr-value",
        "notes": [
            "Pass the address of the argument directly to C.",
            "Used when there is no direct mapping to Fortran."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "type(C_PTR){i_intent_attr}, value :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "#f_mixin_interface-as-cptr-dimension",
        "notes": [
            "Pass the address of the argument directly to C.",
            "Used when there is no direct mapping to Fortran."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "type(C_PTR){i_intent_attr} :: {i_var}{i_dimension}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name":"##### c argument mixin #####################################"
    },
    {
        "sphinx-start-after": "c_mixin_declare-arg",
        "name": "c_mixin_declare-arg",
        "c_prototype": [
            "{gen.cdecl.c_var}"
        ],
        "sphinx-end-before": "c_mixin_declare-arg"
    },
    {
        "name": "c_mixin_declare-arg-void**",
        "notes": [
            "Used to return a void * in an argument.",
            "For example, with deref(raw).",
            "Works with c_mixin_assign-to-void**."
        ],
        "c_prototype": [
            "void **{c_var}"
        ]
    },
    {
        "name": "c_mixin_local-cvar-ptr",
        "comments": [
            "Declare a local pointer variable in the C wrapper."
        ],
        "c_pre_call": [
            "{c_const}{c_type} *{c_var};"
        ]
    },
    {
        "name": "c_mixin_local-cxx-ptr",
        "comments": [
            "Declare a local_cxx pointer variable in the C wrapper."
        ],
        "c_pre_call": [
            "{c_const}{c_type} *{c_local_cxx};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_cast-argument",
        "comments": [
            "Cast C argument to local C++ variable."
        ],
        "c_pre_call": [
            "{c_const}{cxx_type} *{c_local_cxx} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_arg-call-cvar",
        "comments": [
            "Pass cxx variable to library."
        ],
        "c_arg_call": [
            "{cxx_var}"
        ]
    },
    {
        "name": "c_mixin_arg-call-cvar-address",
        "comments": [
            "Pass address of cxx variable to library."
        ],
        "c_arg_call": [
            "&{cxx_var}"
        ]
    },
    {
        "name": "c_mixin_arg-call-cvar-deref",
        "comments": [
            "Pass dereference of cxx variable to library."
        ],
        "c_arg_call": [
            "*{cxx_var}"
        ]
    },
    {
        "name": "c_mixin_arg-call-cxx",
        "comments": [
            "Pass cxx local variable to library."
        ],
        "c_arg_call": [
            "{c_local_cxx}"
        ]
    },
    {
        "name": "c_mixin_arg-call-cxx-address",
        "comments": [
            "Pass address of local cxx variable to library."
        ],
        "c_arg_call": [
            "&{c_local_cxx}"
        ]
    },
    {
        "name": "c_mixin_arg-call-cxx-deref",
        "comments": [
            "Pass dereference of local cxx variable to library."
        ],
        "c_arg_call": [
            "*{c_local_cxx}"
        ]
    },
    
    {
        "name":"##### subprogram mixin #####################################"
    },
    {
        "name": "f_mixin_function",
        "comments": [
            "Call a function in Fortran wrapper."
        ],
        "f_call": [
            "{f_result_var} = {f_call_function}({F_arg_c_call})"
        ]
    },
    {
        "name": "f_mixin_as-intent-out",
        "notes": [
            "Change intent of function result."
        ],
        "fmtdict": {
            "f_intent": "OUT",
            "f_intent_attr": ", intent(OUT)"
        }
    },
    {
        "name": "c_mixin_as-intent-out",
        "notes": [
            "Change intent of Fortran wrapper result.",
            "Only used with C interfaces."
        ],
        "fmtdict": {
            "i_intent": "OUT",
            "i_intent_attr": ", intent(OUT)"
        }
    },
    {
        "name": "f_mixin_function-to-subroutine",
        "comments": [
            "Return function result as an argument."
        ],
        "notes": [
            "This group does not add the declaration for the argument",
            "to allow it to be used with character and other types."
        ],
        "mixin": [
            "f_mixin_as-intent-out"
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_result_var": "as-subroutine",
        "c_return_type": "void"
    },
    {
        "name": "f_mixin_call-cwrapper-as-subroutine",
        "comments": [
            "Call the C wrapper as a subroutine."
        ],
        "notes": [
            "Used when wrapping library functions.",
            "Add an argument to return some meta data.",
            "Other groups must be used to pass argument to the C wrapper."
        ],
        "mixin": [
            "c_mixin_as-intent-out"
        ],
        "f_call": [
            "call {f_call_function}({F_arg_c_call})"
        ],
        "c_return_type": "void"
    },
    {
        "name": "c_mixin_declare-fortran-result",
        "notes": [
            "Fortran function result.",
            "XXX - Not intended for CHAR, only native"
        ],
        "i_result_decl": [
            "{i_type} :: {i_var}"
        ],
        "i_module": {
            "{i_module_name}": [
                "{i_kind}"
            ]
        }
    },
    {
        "name": "f_mixin_function_ptr",
        "comments": [
            "Return a C pointer directly as type(C_PTR)."
        ],
        "f_dummy_decl": [
            "type(C_PTR) :: {f_var}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "i_result_decl": [
            "type(C_PTR) :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "f_mixin_function-interface-as-cptr",
        "notes": [
            "Return a type(C_PTR) from a interface."
        ],
        "i_result_decl": [
            "type(C_PTR) :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        }
    },
    {
        "name": "f_mixin_function_c-ptr",
        "comments": [
            "Return a C pointer as a Fortran pointer."
        ],
        "mixin": [
            "f_mixin_function-interface-as-cptr"
        ],
        "f_dummy_decl": [
            "{f_type}, pointer :: {f_var}"
        ],
        "f_local_decl": [
            "type(C_PTR) :: {f_local_ptr}"
        ],
        "f_call": [
            "{f_local_ptr} = {f_call_function}({F_arg_c_call})"
        ],
        "f_post_call": [
            "call c_f_pointer({f_local_ptr}, {f_result_var})"
        ],
        "f_module": {
            "{f_module_name}": [
                "{f_kind}"
            ],
            "iso_c_binding": [
                "C_PTR",
                "c_f_pointer"
            ]
        },
        "f_local": [
            "ptr"
        ],
        "c_need_wrapper": true
    },
    {
        "name": "c_mixin_function-assign-to-cvar",
        "comments": [
            "Call function and assign to a c variable."
        ],
        "c_call": [
            "{gen.cxxresult.c_var} =\t {C_call_function};"
        ]
    },
    {
        "name": "c_mixin_function-assign-to-local",
        "comments": [
            "Call function and assign to a local C++ variable."
        ],
        "c_call": [
            "{gen.cxxresult.c_local_cxx} =\t {C_call_function};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_assign-to-void**",
        "comments": [
            "Assign a pointer to the c_variable after dereferencing."
        ],
        "c_call": [
            "*{c_var} =\t {gen.nonconst_addr.c_local_cxx};"
        ]
    },
    {
        "name": "c_mixin_function-assign-to-new",
        "comments": [
            "Allocate a C wrapper result on the heap."
        ],
        "c_pre_call": [
            "{cxx_type} *{c_local_cxx} = new {cxx_type};"
        ],
        "c_call": [
            "*{c_local_cxx} = {C_call_function};"
        ],
        "c_local": [
            "cxx"
        ],
        "fmtdict": {
            "cxx_addr": "",
            "cxx_member": "->"
        },
        "owner": "caller"
    },
    {
        "name": "c_mixin_function-return-cvar",
        "notes": [
            "Return a pointer to a heap variable.",
            "Used when a function returns a value."
        ],
        "c_return_type": "{c_const}{c_type} *",
        "c_return": [
            "return {c_var};"
        ]
    },
    {
        "name":"##### subprogram ###########################################"
    },
    {
        "alias": [
            "f_subroutine",
            "c_subroutine"
        ],
        "comments": [
            "Call subroutine/void C function."
        ],
        "usage": [
            "void func()"
        ],
        "f_call": [
            "call {f_call_function}({F_arg_c_call})"
        ],
        "c_call": [
            "{C_call_function};"
        ]
    },
    {
        "name":"#### memory mixin ##########################################"
    },
    {
        "name": "f_mixin_allocate",
        "comments": [
            "Allocate Fortran variable."
        ],
        "f_post_call": [
            "allocate({f_var}{gen.f_allocate_shape})"
        ]
    },
    {
        "name": "f_mixin_deallocate",
        "notes": [
            "Use before an allocate with intent(inout)."
        ],
        "f_post_call": [
            "if (allocated({f_var})) deallocate({f_var})"
        ]
    },
    {
        "name": "c_mixin_delete-cxx-variable",
        "comments": [
            "Delete the cxx variable."
        ],
        "notes": [
            "Used when the caller owns the memory and it has been copied.",
            "For example, c_mixin_char-copy-to-arg."
        ],
        "c_post_call": [
            "delete {cxx_var};"
        ]
    },
    {
        "name": "c_mixin_destructor_new-string",
        "destructor_name": "new_string",
        "destructor": [
            "std::string *cxx_ptr = \treinterpret_cast<std::string *>(ptr);",
            "delete cxx_ptr;"
        ]
    },
    {
        "name": "c_mixin_destructor_new-vector",
        "destructor_name": "std_vector_{cxx_T}",
        "destructor": [
            "std::vector<{cxx_T}> *cxx_ptr = \treinterpret_cast<std::vector<{cxx_T}> *>(ptr);",
            "delete cxx_ptr;"
        ]
    },
    {
        "name": "c_mixin_destructor_new-shadow-shared",
        "notes": [
            "ptr points to a std::shared_ptr which points to the shadow instance.",
            "The count is reduced and the shared_ptr instance is deleted."
        ],
        "destructor_header": [
            "<memory>"
        ],
        "destructor_name": "shadow-{cxx_type}",
        "destructor": [
            "{cxx_type} *shared =\t reinterpret_cast<{cxx_type} *>(ptr);",
            "shared->reset();",
            "delete shared;"
        ]
    },
    {
        "name":"#### capsule mixin #########################################"
    },
    {
        "name": "c_mixin_capsule_pass",
        "comments": [
            "Pass capsule as argument to C wrapper."
        ],
        "notes": [
            "The C wrapper will use the capsule to save the address",
            "of a variable."
        ],
        "i_dummy_arg": [
            "{i_var_capsule}"
        ],
        "i_dummy_decl": [
            "type({f_capsule_data_type}), intent(OUT) :: {i_var_capsule}"
        ],
        "i_import": [
            "{f_capsule_data_type}"
        ],
        "c_prototype": [
            "{c_capsule_data_type} *{c_var_capsule}"
        ],
        "c_temps": [
            "capsule"
        ],
        "helper": [
            "capsule_data"
        ]
    },
    {
        "name": "f_mixin_capsule_pass",
        "comments": [
            "Create a local Fortran capsule." 
        ],
        "notes": [
            "This can be used by the Fortran wrapper to release C++ memory",
            "after copying the values into Fortran memory."
        ],
        "mixin": [
            "c_mixin_capsule_pass"
        ],
        "f_local_decl": [
            "type({f_capsule_data_type}) :: {f_var_capsule}"
        ],
        "f_arg_call": [
            "{f_var_capsule}"
        ],
        "f_temps": [
            "capsule"
        ],
        "f_need_wrapper": true,
        "helper": [
            "array_context"
        ]
    },
    {
        "name": "f_mixin_add_capsule_arg_to_fwrapper",
        "comments": [
            "Add a capsule argument to the Fortran wrapper.",
            "Pass the capsule as argument to C wrapper."
        ],
        "notes": [
            "This adds a capsule to the Fortran API to control C++ memory.",
            "The C++ memory maybe referenced by a Fortran pointer to allow",
            "the user to access it.",
            "The user is responsible to release the memory in the capsule."
        ],
        "mixin": [
            "c_mixin_capsule_pass"
        ],
        "f_dummy_arg": [
            "{f_var_capsule}"
        ],
        "f_dummy_decl": [
            "type({F_capsule_type}), intent(OUT) :: {f_var_capsule}"
        ],
        "f_arg_call": [
            "{f_var_capsule}%mem"
        ],
        "f_temps": [
            "capsule"
        ],
        "f_need_wrapper": true,
        "fmtdict": {
            "f_var_capsule": "Crv"
        },
        "helper": [
            "array_context",
            "capsule_helper"
        ]
    },
    {
        "name": "f_mixin_capsule_dtor",
        "comments": [
            "Release memory from capsule."
        ],
        "f_post_call": [
            "call {f_helper_capsule_dtor}({f_var_capsule})"
        ],
        "helper": [
            "capsule_dtor"
        ]
    },
    {
        "name": "c_mixin_function-return-capptr",
        "notes": [
            "Return the capsule argument.",
            "Note that the capsule is not const, but the pointer inside should be."
        ],
        "c_return_type": "{c_type} *",
        "c_return": [
            "return {c_var};"
        ]
    },
    {
        "name": "c_mixin_capsule_fill_cvar",
        "comments": [
            "Assign capsule values to argument in C wrapper."
        ],
        "notes": [
            "The argument may be a capulse or a class struct."
        ],
        "c_post_call": [
            "{c_var}->addr  = {cxx_nonconst_ptr};",
            "{c_var}->idtor = {idtor};",
            "{c_var}->cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;"
        ]
    },
    {
        "name": "c_mixin_capsule_fill_arg",
        "comments": [
            "Assign capsule values to capsule argument in C wrapper."
        ],
        "c_post_call": [
            "{c_var_capsule}->addr  = {cxx_nonconst_ptr};",
            "{c_var_capsule}->idtor = {idtor};"
        ]
    },
    {
        "name": "c_mixin_capsule_fill_local",
        "comments": [
            "Assign local variable's capsule values to capsule argument in C wrapper."
        ],
        "c_post_call": [
            "{c_var_capsule}->addr  = {c_local_cxx};",
            "{c_var_capsule}->idtor = {idtor};"
        ]
    },
    {
        "name": "f_mixin_capsule_function_shadow",
        "comments": [
            "Pass function result as a capsule argument from Fortran to C."
        ],
        "f_dummy_decl": [
            "{f_type} :: {f_var}"
        ],
        "f_arg_call": [
            "{f_var}%{F_derived_member}"
        ],
        "f_need_wrapper": true
    },
    {
        "name": "c_mixin_function_shadow_capptr",
        "comments": [
            "Pass function result as a capsule field of shadow class",
            "from Fortran to C."
        ],
        "i_result_decl": [
            "type(C_PTR) :: {i_var_ptr}"
        ],
        "i_result_var": "{i_var_ptr}",
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "c_temps": [
            "ptr"
        ]
    },
    {
        "name": "f_mixin_capsule_use",
        "mixin": [
            "f_mixin_capsule_pass",
            "c_mixin_capsule_fill_arg",
            "f_mixin_capsule_dtor"
        ]
    },
    {
        "name":"#### cdesc mixin ###########################################"
    },
    {
        "name": "f_mixin_cdesc_pass_to_cwrapper",
        "comments": [
            "Pass cdesc as argument to C wrapper."
        ],
        "notes": [
            "Declare the cdesc variable locally in the Fortran wrapper",
            "then pass to the C wrapper."
        ],
        "f_local_decl": [
            "type({F_array_type}) :: {f_var_cdesc}"
        ],
        "f_arg_call": [
            "{f_var_cdesc}"
        ],
        "f_temps": [
            "cdesc"
        ],
        "f_need_wrapper": true,
        "i_dummy_arg": [
            "{i_var_cdesc}"
        ],
        "i_dummy_decl": [
            "type({F_array_type}), intent(OUT) :: {i_var_cdesc}"
        ],
        "i_import": [
            "{F_array_type}"
        ],
        "c_prototype": [
            "{C_array_type} *{c_var_cdesc}"
        ],
        "c_temps": [
            "cdesc"
        ],
        "helper": [
            "array_context"
        ]
    },
    {
        "name": "f_mixin_cdesc_inout_array",
        "comments": [
            "Declare local Fortran array_type argument."
        ],
        "notes": [
            "Paired with c_mixin_inout_vector_cdesc."
        ],
        "f_local_decl": [
            "type({F_array_type}) :: {f_var_cdesc}"
        ],
        "f_arg_call": [
            "{f_var}",
            "size({f_var}, kind=C_SIZE_T)",
            "{f_var_cdesc}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_SIZE_T"
            ]
        },
        "f_temps": [
            "cdesc"
        ],
        "helper": [
            "array_context"
        ]
    },
    {
        "name": "f_mixin_cdesc_native_fill",
        "comments": [
            "Fill cdesc from native in the Fortran wrapper."
        ],
        "notes": [
            "The Fortran variable needs the TARGET attribute to use C_LOC."
        ],
        "f_pre_call": [
            "{f_var_cdesc}%base_addr = C_LOC({f_var})",
            "{f_var_cdesc}%type = {typemap.sh_type}",
            "! {f_var_cdesc}%elem_len = C_SIZEOF()",
            "{f_var_cdesc}%size = {f_size}",
            "{f_var_cdesc}%rank = {rank}{gen.f_cdesc_shape}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_LOC"
            ]
        },
        "fmtdict": {
            "f_target_attr": ", target"
        },
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "f_mixin_cdesc_char_fill",
        "comments": [
            "Fill cdesc from char in the Fortran wrapper."
        ],
        "notes": [
            "The Fortran variable needs the TARGET attribute to use C_LOC."
        ],
        "f_pre_call": [
            "{f_var_cdesc}%base_addr = C_LOC({f_var})",
            "{f_var_cdesc}%type = SH_TYPE_CHAR",
            "{f_var_cdesc}%elem_len = len({f_var})",
            "{f_var_cdesc}%size = size({f_var})",
            "{f_var_cdesc}%rank = rank({f_var}){gen.f_cdesc_shape}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_LOC"
            ]
        },
        "fmtdict": {
            "f_target_attr": ", target"
        },
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "c_mixin_cdesc_native_fill",
        "comments": [
            "Fill cdesc from native in the C wrapper."
        ],
        "c_post_call": [
            "{c_var_cdesc}->base_addr = {cxx_nonconst_ptr};",
            "{c_var_cdesc}->type = {typemap.sh_type};",
            "{c_var_cdesc}->elem_len = sizeof({cxx_type});",
            "{c_var_cdesc}->rank = {rank};{gen.c_array_shape}",
            "{c_var_cdesc}->size = {gen.c_array_size};"
        ]
    },
    {
        "name": "c_mixin_cdesc_fill_char",
        "comments": [
            "Fill cdesc from char * in the C wrapper."
        ],
        "mixin": [
            "c_mixin_header_cstring"
        ],
        "c_post_call": [
            "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{cxx_var});",
            "{c_var_cdesc}->type = {typemap.sh_type};",
            "{c_var_cdesc}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});",
            "{c_var_cdesc}->size = 1;",
            "{c_var_cdesc}->rank = 0;"
        ],
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "c_mixin_cdesc_fill_string_local",
        "comments": [
            "Fill cdesc from local std::string variable in the C wrapper."
        ],
        "usage": [
            "Also used with std::string* via cxx_member."
        ],
        "mixin": [
            "c_mixin_header_cstring"
        ],
        "c_post_call": [
            "{c_var_cdesc}->base_addr =\t const_cast<char *>(\t{c_local_cxx}{cxx_member}data());",
            "{c_var_cdesc}->type = {typemap.sh_type};",
            "{c_var_cdesc}->elem_len = {c_local_cxx}{cxx_member}size();",
            "{c_var_cdesc}->size = 1;",
            "{c_var_cdesc}->rank = 0;"
        ],
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "c_mixin_cdesc_function_string",
        "comments": [
            "Fill cdesc from std::string using helper string_to_cdesc",
            "in the C wrapper."
        ],
        "c_post_call": [
            "{c_helper_string_to_cdesc}(\t{c_var_cdesc},\t {cxx_addr}{cxx_var});"
        ],
        "helper": [
            "string_to_cdesc"
        ]
    },
    {
        "name": "f_mixin_cdesc_allocate_1d",
        "comments": [
            "Allocate 1-D Fortran variable."
        ],
        "f_post_call": [
            "allocate({f_var}({f_var_cdesc}%size))"
        ]
    },
    {
        "name": "f_mixin_cdesc_copy_array",
        "comments": [
            "Copy into Fortran argument."
        ],
        "f_post_call": [
            "call {f_helper_copy_array}(\t{f_var_cdesc},\t C_LOC({f_var}),\t size({f_var}, kind=C_SIZE_T))"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_LOC",
                "C_SIZE_T"
            ]
        },
        "fmtdict": {
            "f_target_attr": ", target"
        },
        "helper": [
            "copy_array"
        ]
    },
    {
        "name": "f_mixin_cdesc_native_pointer",
        "comments": [
            "Set Fortran pointer to native array."
        ],
        "f_dummy_decl": [
            "{f_type}{f_intent_attr}{f_deref_attr} :: {f_var}{f_assumed_shape}"
        ],
        "f_post_call": [
            "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {f_result_var}{gen.c_f_pointer_shape})"
        ],
        "f_module": {
            "{f_module_name}": [
                "{f_kind}"
            ],
            "iso_c_binding": [
                "c_f_pointer"
            ]
        }
    },
    {
        "name": "f_mixin_cdesc_native_raw",
        "comments": [
            "Set Fortran pointer to pointers to arrays."
        ],
        "notes": [
            "'double **' function returns 'type(C_PTR), pointer :: array(:)'"
        ],
        "f_dummy_decl": [
            "type(C_PTR), pointer :: {f_var}{f_assumed_shape}"
        ],
        "f_post_call": [
            "call c_f_pointer(\t{f_var_cdesc}%base_addr,\t {f_result_var}{gen.c_f_pointer_shape})"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_PTR",
                "c_f_pointer"
            ]
        }
    },
    {
        "name": "f_mixin_cdesc_out_native_pointer",
        "comments": [
            "Set Fortran pointer to native array."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "{f_type}{f_intent_attr}{f_deref_attr} :: {f_var}{f_assumed_shape}"
        ],
        "f_post_call": [
            "call c_f_pointer({f_var_cdesc}%base_addr, {f_var}{gen.c_f_pointer_shape})"
        ],
        "f_module": {
            "{f_module_name}": [
                "{f_kind}"
            ],
            "iso_c_binding": [
                "c_f_pointer"
            ]
        }
    },
    {
        "name": "f_mixin_cdesc_char_allocate",
        "comments": [
            "Allocate Fortran CHARACTER scalar, then fill from cdesc",
            "using helper copy_string."
        ],
        "f_dummy_decl": [
            "character(len=:){f_intent_attr}{f_deref_attr} :: {f_var}"
        ],
        "f_post_call": [
            "allocate(character(len={f_var_cdesc}%elem_len):: {f_var})",
            "call {f_helper_copy_string}(\t{f_var_cdesc},\t {f_var},\t {f_var_cdesc}%elem_len)"
        ],
        "helper": [
            "copy_string"
        ]
    },
    {
        "name": "f_mixin_cdesc_char_pointer",
        "comments": [
            "Assign Fortran pointer from cdesc using helper pointer_string."
        ],
        "f_dummy_decl": [
            "character(len=:){f_intent_attr}{f_deref_attr} :: {f_var}"
        ],
        "f_post_call": [
            "call {f_helper_pointer_string}(\t{f_var_cdesc},\t {f_var})"
        ],
        "helper": [
            "pointer_string"
        ]
    },
    {
        "name": "c_mixin_cdesc_getter",
        "comments": [
            "Save pointer struct members in a cdesc",
            "along with shape information."
        ],
        "c_call": [
            "{c_var_cdesc}->base_addr = {CXX_this}->{field_name};",
            "{c_var_cdesc}->type = {typemap.sh_type};",
            "{c_var_cdesc}->elem_len = sizeof({cxx_type});",
            "{c_var_cdesc}->rank = {rank};{gen.c_array_shape}",
            "{c_var_cdesc}->size = {gen.c_array_size};"
        ],
        "c_need_wrapper": true,
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "c_mixin_cdesc_getter_char*",
        "comments": [
            "Save char *struct members in a cdesc",
            "along with shape information."
        ],
        "c_call": [
            "{c_var_cdesc}->base_addr = {c_local_cxx};",
            "{c_var_cdesc}->type = {typemap.sh_type};",
            "{c_var_cdesc}->elem_len = {c_local_len};",
            "{c_var_cdesc}->rank = {rank};{gen.c_array_shape}",
            "{c_var_cdesc}->size = {gen.c_array_size};"
        ],
        "c_need_wrapper": true,
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "c_mixin_cdesc_unpack-base-addr",
        "notes": [
            "Unpack the base_addr from the cdesc variable."
        ],
        "#c_pre_call": [
            "{c_type} *{c_var} = {cast_static}{c_type} *{cast1}{c_var_cdesc}->base_addr{cast2};"
        ],
        "lang_c": {
            "c_pre_call": [
                "{cxx_type} *{c_var} = {c_var_cdesc}->base_addr;"
            ]
        },
        "lang_cxx": {
            "c_pre_call": [
                "{cxx_type} *{c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_cdesc}->base_addr));"
            ]
        }
    },
    {
        "name":"#### template mixin ########################################",
        "notes": [
            "These were written with std::vector in mind",
            "but may work with std::span as well",
            "since they deal with the template argument in an abstract manner."
        ]
    },
    {
        "name": "f_mixin_template_native_arg1",
        "notes": [
            "Declare an dummy argument for the first template argument."
        ],
        "f_dummy_decl": [
            "{targs[0].f_type}{f_intent_attr}{f_deref_attr}{f_target_attr} :: {f_var}{f_assumed_shape}"
        ],
        "f_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}"
            ]
        }
    },
    {
        "name": "f_mixin_in_vector_buf",
        "comments": [
            "Pass argument and size by value to C."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "{targs[0].f_type}{f_intent_attr} :: {f_var}{f_assumed_shape}"
        ],
        "f_arg_call": [
            "{f_var}",
            "size({f_var}, kind=C_SIZE_T)"
        ],
        "f_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}",
                "C_SIZE_T"
            ]
        },
        "f_need_wrapper": true,
        "i_dummy_arg": [
            "{i_var}",
            "{i_var_size}"
        ],
        "i_dummy_decl": [
            "{targs[0].f_type}, intent(IN) :: {i_var}(*)",
            "integer(C_SIZE_T), intent(IN), value :: {i_var_size}"
        ],
        "i_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}",
                "C_SIZE_T"
            ]
        },
        "c_prototype": [
            "{targs[0].cxx_type} *{c_var}",
            "size_t {c_var_size}"
        ],
        "c_temps": [
            "size"
        ]
    },
    {
        "name": "f_mixin_out_vector_buf",
        "comments": [
            "Pass argument and size by reference to C."
        ],
        "f_arg_call": [
            "{f_var}",
            "size({f_var}, kind=C_SIZE_T)"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_SIZE_T"
            ]
        },
        "f_need_wrapper": true,
        "i_dummy_arg": [
            "{i_var}",
            "{i_var_size}"
        ],
        "i_dummy_decl": [
            "{targs[0].f_type}{i_intent_attr} :: {i_var}(*)",
            "integer(C_SIZE_T){i_intent_attr} :: {i_var_size}"
        ],
        "i_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}",
                "C_SIZE_T"
            ]
        },
        "c_prototype": [
            "{targs[0].cxx_type} *{c_var}",
            "size_t *{c_var_size}"
        ],
        "c_temps": [
            "size"
        ]
    },
    {
        "name": "c_mixin_out_vector_buf_malloc",
        "comments": [
            "Pass raw pointer and size by reference to C."
        ],
        "i_dummy_arg": [
            "{i_var}",
            "{i_var_size}"
        ],
        "i_dummy_decl": [
            "type(C_PTR){i_intent_attr} :: {i_var}",
            "integer(C_SIZE_T){i_intent_attr} :: {i_var_size}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR",
                "C_SIZE_T"
            ]
        },
        "c_prototype": [
            "{targs[0].cxx_type} **{c_var}",
            "size_t *{c_var_size}"
        ],
        "c_temps": [
            "size"
        ]
    },
    {
        "name": "c_mixin_function_vector_malloc",
        "comments": [
            "Return pointer to array type.",
            "Add an argument to return the length of the array."
        ],
        "i_dummy_arg": [
            "{i_var_size}"
        ],
        "i_dummy_decl": [
            "integer(C_SIZE_T), intent(OUT) :: {i_var_size}"
        ],
        "i_result_decl": [
            "type(C_PTR) :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR",
                "C_SIZE_T"
            ]
        },
        "c_return_type": "{targs[0].cxx_type} *",
        "c_prototype": [
            "size_t *{c_var_size}"
        ],
        "c_temps": [
            "size"
        ]
    },
    {
        "name": "f_mixin_in_2d_vector_buf",
        "comments": [
            "Pass argument, len and size to C."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "{targs[0].f_type}{f_intent_attr} :: {f_var}(:,:)"
        ],
        "f_arg_call": [
            "{f_var}",
            "size({f_var}, 1, kind=C_SIZE_T)",
            "size({f_var}, 2, kind=C_SIZE_T)"
        ],
        "f_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}",
                "C_SIZE_T"
            ]
        },
        "f_need_wrapper": true,
        "i_dummy_arg": [
            "{i_var}",
            "{i_var_len}",
            "{i_var_size}"
        ],
        "i_dummy_decl": [
            "{targs[0].f_type}, intent(IN) :: {i_var}(*)",
            "integer(C_SIZE_T), intent(IN), value :: {i_var_len}",
            "integer(C_SIZE_T), intent(IN), value :: {i_var_size}"
        ],
        "i_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}",
                "C_SIZE_T"
            ]
        },
        "c_prototype": [
            "{targs[0].cxx_type} *{c_var}",
            "size_t {c_var_len}",
            "size_t {c_var_size}"
        ],
        "c_temps": [
            "len",
            "size"
        ]
    },
    {
        "name": "c_mixin_cdesc_inout_vector",
        "comments": [
            "Accept array_type in C wrapper."
        ],
        "notes": [
            "Paired with f_mixin_inout_vector_cdesc."
        ],
        "i_dummy_arg": [
            "{i_var}",
            "{i_var_size}",
            "{i_var_cdesc}"
        ],
        "i_dummy_decl": [
            "{targs[0].f_type}, intent(IN) :: {i_var}(*)",
            "integer(C_SIZE_T), intent(IN), value :: {i_var_size}",
            "type({F_array_type}), intent(OUT) :: {i_var_cdesc}"
        ],
        "i_import": [
            "{F_array_type}"
        ],
        "i_module": {
            "iso_c_binding": [
                "{targs[0].f_kind}",
                "C_SIZE_T"
            ]
        },
        "c_prototype": [
            "{targs[0].cxx_type} *{c_var}",
            "size_t {c_var_size}",
            "{C_array_type} *{c_var_cdesc}"
        ],
        "c_temps": [
            "size",
            "cdesc"
        ],
        "helper": [
            "array_context"
        ]
    },
    {
        "name":"#### native mixin ##########################################"
    },
    {
        "name": "c_mixin_out_native**",
        "comments": [
            "Declare a local C pointer."
        ],
        "notes": [
            "double **count +intent(out)+dimension(ncount)"
        ],
        "c_pre_call": [
            "{c_const}{cxx_type} *{cxx_var};"
        ]
    },
    {
        "name":"#### native ################################################"
    },
    {
        "alias": [
            "f_function_native",
            "c_function_native"
        ],
        "usage": [
            "int func()"
        ],
        "mixin": [
            "f_mixin_function",
            "f_mixin_declare-local-variable",
            "c_mixin_declare-fortran-result",
            "c_mixin_function-assign-to-cvar"
        ]
    },
    {
        "name": "f_function_native*_scalar",
        "notes": [
            "Return a scalar to avoid doing the deref in Fortran."
        ],
        "usage": [
            "int *func() +deref(scalar)"
        ],
        "mixin": [
            "f_mixin_function",
            "f_mixin_declare-local-variable",
            "c_mixin_declare-fortran-result",
            "c_mixin_function-assign-to-cvar"
        ],
        "c_return_type": "{c_type}",
        "c_return": [
            "return *{cxx_var};"
        ],
        "c_need_wrapper": true
    },
    {
        "alias": [
            "f_in_native*",
            "c_in_native*",
            "f_out_native*",
            "c_out_native*",
            "f_inout_native*",
            "c_inout_native*",
            "f_in_void",
            "c_in_void",
            "f_none_native*"
        ],
        "usage": [
            "const int *arg",
            "int *arg +intent(in)+rank(1)"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ]
    },
    {
        "alias": [
            "f_in_native",
            "c_in_native",
            "f_none_native"
        ],
        "notes": [
            "An intent of 'none' is used with function pointers."
        ],
        "usage": [
            "int arg"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ]
    },
    {
        "alias": [
            "f_in_native&",
            "c_in_native&",
            "f_out_native&",
            "c_out_native&",
            "f_inout_native&",
            "c_inout_native&"
        ],
        "usage": [
            "const int &value +intent(in)"            
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar-deref",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ]
    },
    {
        "alias": [
            "f_in_native**",
            "c_in_native**"
        ],
        "notes": [
            "Any array of pointers.  Assumed to be non-contiguous memory.",
            "All Fortran can do is treat as a type(C_PTR)."
        ],
        "usage": [
            "int **arg +intent(in)"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_interface-as-cptr-value",
            "f_mixin_dummy_arg",
            "f_mixin_declare-arg-as-cptr"
        ]
    },
    {
        "alias": [
            "f_out_native**_raw_library",
            "c_out_native**_raw",
            "c_out_native**",
            "f_out_native***_raw_library",
            "c_out_native***"
        ],
        "notes": [
            "Too much indirection for Fortran.",
            "Make argument a type(C_PTR)."
        ],
        "usage": [
            "int ** +intent(out)+deref(raw)",
            "int ***arg +intent(out)"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_interface-as-cptr",
            "f_mixin_dummy_arg",
            "f_mixin_declare-arg-as-cptr"
        ]
    },
    {
        "alias": [
            "f_out_void*&",
            "c_out_void*&",
            "c_out_native*&"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar-deref",
            "f_mixin_interface-as-cptr",
            "f_mixin_declare-fortran-arg"
        ],
        "usage": [
            "void *&arg +intent(out)"
        ]

    },
    {
        "alias": [
            "f_out_native*&_cdesc",
            "f_out_native*&_cdesc_pointer_library"
        ],
        "mixin": [
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_out_native**",
            "c_mixin_arg-call-cvar",
            "c_mixin_cdesc_native_fill",
            "f_mixin_cdesc_out_native_pointer"
        ],
        "usage": [
            "double *&arg +dimension(isize)+intent(out)"
        ]
    },
    {
        "name": "f_out_native**_cdesc_allocatable",
        "notes": [
            "Argument returns a pointer to an array which is copied into a",
            "Fortran allocatable."
        ],
        "usage": [
            "int **arg +deref(allocatable)+dimension(10)+intent(out)"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_cdesc_native_fill",
            "c_mixin_out_native**",
            "c_mixin_arg-call-cvar-address",
            "f_mixin_allocate",
            "f_mixin_cdesc_copy_array",
            "f_mixin_capsule_use"
        ]
    },
    {
        "name": "f_out_native**_cdesc_pointer_library",
        "notes": [
            "Argument returns a pointer to an array which is associated with a",
            "Fortran pointer."
        ],
        "usage": [
            "int **arg +intent(out)+deref(pointer)"
        ],
        "mixin": [
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_out_native**",
            "c_mixin_arg-call-cvar-address",
            "c_mixin_cdesc_native_fill",
            "f_mixin_cdesc_out_native_pointer"
        ]
    },
    {
        "alias": [
            "f_in_native*_cdesc",
            "f_out_native*_cdesc",
            "f_inout_native*_cdesc",
            "c_in_native*_cdesc",
            "c_out_native*_cdesc",
            "c_inout_native*_cdesc",
            "c_in_void*_cdesc",
            "c_out_void*_cdesc",
            "c_inout_void*_cdesc",
            "f_in_void*_cdesc",
            "f_out_void*_cdesc",
            "f_inout_void*_cdesc"
        ],
        "notes": [
            "Passing a cdesc to C wrapper which may have splicer code to process it.",
            "Perhaps using a fortran_generic to deal with a void * pointer.",
            "See cdesc.yaml test GetScalar1."
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_native_fill",
            "c_mixin_cdesc_unpack-base-addr",
            "c_mixin_arg-call-cvar"
        ]
    },
    {
        "alias": [
            "f_out_native*_hidden",
            "f_inout_native*_hidden",
            "c_out_native*_hidden",
            "c_inout_native*_hidden"
        ],
        "notes": [
            "Declare a local variable and pass to C."
        ],
        "mixin": [
            "c_mixin_arg-call-cvar-address"
        ],
        "c_pre_call": [
            "{cxx_type} {cxx_var};"
        ]
    },
    {
        "alias": [
            "f_out_native&_hidden",
            "f_inout_native&_hidden",
            "c_out_native&_hidden",
            "c_inout_native&_hidden"
        ],
        "notes": [
            "Declare a local variable and pass to C."
        ],
        "mixin": [
            "c_mixin_arg-call-cvar"
        ],
        "c_pre_call": [
            "{cxx_type} {cxx_var};"
        ]
    },
    {
        "name": "c_function_native*_scalar",
        "notes": [
            "XXX - not tested"
        ],
        "mixin": [
            "c_mixin_declare-fortran-result"
        ]
    },
    {
        "name": "f_function_native*_cdesc_allocatable",
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_native_fill",
            "f_mixin_allocate",
            "f_mixin_cdesc_copy_array",
            "f_mixin_capsule_use"
        ]
    },
    {
        "alias": [
            "f_function_native&",
            "f_function_native*_pointer",
            "f_function_native*_pointer_caller",
            "f_function_native*_pointer_library",
            "f_function_native&_pointer_library"
        ],
        "notes": [
            "Pointer to scalar.",
            "type(C_PTR) is returned instead of a cdesc argument."
        ],
        "usage": [
            "int &func()"
        ],
        "mixin": [
            "f_mixin_function_c-ptr",
            "c_mixin_function-assign-to-cvar"
        ]
    },
    {
        "alias": [
            "f_function_native*_cdesc_pointer_library",
            "f_function_struct*_cdesc_pointer_library"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_native_fill",
            "f_mixin_cdesc_native_pointer"
        ]
    },
    {
        "name": "f_function_native*_cdesc_pointer_caller",
        "notes": [
            "A capsule argument is added which contains information used to",
            "delete the memory."
        ],
        "usage": [
            "int *func() +deref(pointer)+dimension(len)+owner(caller)"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_add_capsule_arg_to_fwrapper",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_native_fill",
            "c_mixin_capsule_fill_arg",
            "f_mixin_cdesc_native_pointer"
        ]
    },
    {
        "alias": [
            "f_function_native*_raw_library",
            "c_function_native*",
            "c_function_native&",
            "c_function_native*_caller",
            "c_function_native*_library",
            "c_function_native**",
            "c_function_native**_library",
            "f_function_native**",
            "f_function_native**_library"
        ],
        "usage": [
            "int **func()"
        ],
        "mixin": [
            "f_mixin_function_ptr",
            "c_mixin_function-assign-to-cvar"
        ]
    },
    {
        "name":"#### unknown ##############################################"
    },
    {
        "alias": [
            "f_in_unknown",
            "c_in_unknown"
        ],
        "notes": [
            "Used with MPI types."
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-fortran-arg",
            "f_mixin_declare-interface-arg"
        ]
    },
    {
        "name":"#### bool ##################################################"
    },
    {
        "name": "f_mixin_logical-local-var",
        "f_local_decl": [
            "logical(C_BOOL) :: {f_var_cxx}"
        ],
        "f_arg_call": [
            "{f_var_cxx}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_BOOL"
            ]
        },
        "f_temps": [
            "cxx"
        ]
    },
    {
        "name": "f_mixin_logical-in",
        "f_pre_call": [
            "{f_var_cxx} = {f_var}  ! coerce to C_BOOL"
        ]
    },
    {
        "name": "f_mixin_logical-out",
        "f_post_call": [
            "{f_var} = {f_var_cxx}  ! coerce to logical"
        ]
    },
    {
        "alias": [
            "f_in_bool",
            "c_in_bool",
            "f_none_bool"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-fortran-arg",
            "f_mixin_declare-interface-arg",
            "f_mixin_logical-local-var",
            "f_mixin_logical-in"
        ]
    },
    {
        "alias": [
            "f_out_bool*",
            "c_out_bool_*",
            "f_none_bool*"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-fortran-arg",
            "f_mixin_declare-interface-arg",
            "f_mixin_logical-local-var",
            "f_mixin_logical-out"
        ]
    },
    {
        "alias": [
            "f_inout_bool*",
            "c_inout_bool_*"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-fortran-arg",
            "f_mixin_declare-interface-arg",
            "f_mixin_logical-local-var",
            "f_mixin_logical-in",
            "f_mixin_logical-out"
        ]
    },
    {
        "alias": [
            "f_function_bool",
            "c_function_bool"
        ],
        "mixin": [
            "f_mixin_function",
            "f_mixin_declare-local-variable",
            "c_mixin_declare-fortran-result",
            "c_mixin_function-assign-to-cvar"
        ],
        "f_need_wrapper": true
    },
    {
        "name":"#### void ##################################################"
    },
    {
        "alias": [
            "f_in_void*",
            "c_in_void*",
            "f_none_void*"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_interface-as-cptr",
            "f_mixin_declare-fortran-arg"
        ],
        "f_dummy_decl": [
            "{f_type}{f_intent_attr} :: {f_var}"
        ],
        "i_dummy_decl": [
            "{i_type}{f_value_attr}{i_intent_attr} :: {i_var}{i_dimension}"
        ]
    },
    {
        "alias": [
            "f_function_void*",
            "f_function_void*_library",
            "c_function_void*",
            "c_function_void*_library"
        ],
        "notes": [
            "XXX - f entries are the same as the i entries, share?"
        ],
        "mixin": [
            "f_mixin_declare-local-variable",
            "c_mixin_function-assign-to-cvar"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "i_result_decl": [
            "type(C_PTR) :: {i_var}"
        ]
    },
    {
        "alias": [
            "f_in_void**",
            "f_out_void**",
            "f_inout_void**",
            "c_in_void**",
            "c_out_void**",
            "c_inout_void**",
            "f_in_void**_cfi"
        ],
        "notes": [
            "Treat as an assumed length array in Fortran interface."
        ],
        "mixin": [
            "c_mixin_arg-call-cvar"
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "type(C_PTR){f_value_attr}{f_intent_attr} :: {f_var}{f_assumed_shape}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "i_dummy_decl": [
            "type(C_PTR){f_value_attr}{i_intent_attr} :: {i_var}{i_dimension}"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "c_prototype": [
            "void **{c_var}"
        ]
    },
    {
        "name":"##### enum #################################################"
    },
    {
        "alias": [
            "f_in_enum",
            "c_in_enum"
        ],
        "notes": [
            "Use gen.cidecl to get the C interface type.",
            "enums use option.F_enum_type to control the C type."
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_arg-call-cvar"
        ],
        "i_dummy_decl": [
            "{i_type}, value{i_intent_attr} :: {i_var}"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_module": {
            "{i_module_name}": [
                "{i_kind}"
            ]
        },
        "c_prototype": [
            "{gen.cidecl.c_var}"
        ],
        "c_pre_call": [
            "{gen.cxxdecl.cxx_var} =\t {gen.c_to_cxx};"
        ],
        "fmtdict": {
            "cxx_var": "{CXX_local}{c_var}"
        }
    },
    {
        "alias": [
            "f_out_enum*",
            "c_out_enum*"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_declare-interface-arg",
            "c_mixin_arg-call-cxx-address"
        ],
        "c_prototype": [
            "{gen.cidecl.c_var}"
        ],
        "c_pre_call": [
            "{cxx_type} {cxx_var};"
        ],
        "c_post_call": [
            "*{c_var} = {cast_static}{c_type}{cast1}{cxx_var}{cast2};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "alias": [
            "f_inout_enum*",
            "c_inout_enum*"
        ],
        "base": "f_out_enum*",
        "c_pre_call": [
            "{cxx_type} {cxx_var} = {cast_static}{cxx_type}{cast1}*{c_var}{cast2};"
        ]
    },
    {
        "alias": [
            "f_function_enum"
        ],
        "notes": [
            "Return as the Fortran bind(C) type."
        ],
        "mixin": [
            "f_mixin_function",
            "f_mixin_declare-local-variable",
            "c_mixin_declare-fortran-result",
            "c_mixin_function-assign-to-local"
        ],
        "c_post_call": [
            "{ci_type} {c_var} =\t {cast_static}{ci_type}{cast1}{c_local_cxx}{cast2};"
        ]
    },
    {
        "alias": [
            "c_function_enum"
        ],
        "mixin": [
            "c_mixin_declare-fortran-result",
            "c_mixin_function-assign-to-local"
        ],
        "c_post_call": [
            "{c_type} {c_var} =\t {cast_static}{c_type}{cast1}{c_local_cxx}{cast2};"
        ]
    },
    {
        "name":"##### char mixin ###########################################"
    },
    {
        "name": "c_mixin_character-assumed-length",
        "notes": [
            "Treats CHARACTER as a array of C_CHAR."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "character(kind=C_CHAR){i_intent_attr} :: {i_var}(*)"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_CHAR"
            ]
        }
    },
    {
        "name": "f_mixin_character-deferred-length",
        "f_dummy_decl": [
            "character(len=:){f_intent_attr}{f_deref_attr} :: {f_var}"
        ]
    },
    {
        "name": "c_mixin_character-deferred-length",
        "notes": [
            "Used with CFI"
        ],
        "i_dummy_decl": [
            "character(len=:){i_intent_attr}{f_deref_attr} :: {i_var}{f_assumed_shape}"
        ]
    },
    {
        "name": "f_mixin_declare-arg-char",
        "comments": [
            "Fortran wrapper character argument."
        ],
        "notes": [
            "A single character.",
            "XXX - value should not be necessary but fails without it."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "character, value{f_intent_attr} :: {f_var}"
        ]
    },
    {
        "name": "c_mixin_declare-arg-char",
        "comments": [
            "C wrapper character argument."
        ],
        "notes": [
            "A single character."
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "character(kind=C_CHAR), value{i_intent_attr} :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_CHAR"
            ]
        },
        "c_prototype": [
            "char {c_var}"
        ]
    },
    {
        "name": "f_mixin_function-as-character-arg",
        "notes" : [
            "Convert the function result to a character argument."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "character(len=*), intent(OUT){f_deref_attr} :: {f_var}"
        ],
        "f_result_var": "as-subroutine"
    },
    {
        "name": "f_mixin_function-as-character-arg-var-len",
        "fmtdict": {
            "f_var_len": "n{f_var}",
            "i_var_len": "n{i_var}",
            "c_var_len": "n{c_var}"
        }
    },
    {
        "name": "c_mixin_char-malloc",
        "comments": [
            "Allocate a local char array in C wrapper."
        ],
        "notes": [
            "With space for terminating NULL."
        ],
        "mixin": [
            "c_mixin_header_stdlib"
        ],
        "lang_c": {
            "c_pre_call": [
                "char *{c_local_cxx} = malloc({c_var_len}+1);"
            ]
        },
        "lang_cxx": {
            "c_pre_call": [
                "char *{c_local_cxx} = new char[{c_var_len}+1];"
            ]
        },
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_char-free",
        "comments": [
            "Free a local char array in C wrapper."
        ],
        "mixin": [
            "c_mixin_header_stdlib"
        ],
        "lang_c": {
            "c_post_call": [
                "free({c_local_cxx});"
            ]
        },
        "lang_cxx": {
            "c_post_call": [
                "delete[] {c_local_cxx};"
            ]
        }
    },
    {
        "name": "c_mixin_char-alloc",
        "comments": [
            "Allocate a local char variable in C wrapper."
        ],
        "c_pre_call": [
            "char *{c_local_cxx} = {c_helper_char_alloc}(\t{c_var},\t {c_var_len},\t {c_blanknull});"
        ],
        "c_post_call": [
            "{c_helper_char_free}({c_local_cxx});"
        ],
        "c_local": [
            "cxx"
        ],
        "helper": [
            "char_alloc",
            "char_free"
        ]
    },
    {
        "name": "c_mixin_char-blank-fill",
        "comments": [
            "Blank fill C argument."
        ],
        "c_post_call": [
            "{c_helper_char_blank_fill}({c_var}, {c_var_len});"
        ],
        "helper": [
            "char_blank_fill"
        ]
    },
    {
        "name": "c_mixin_char-copyout",
        "comments": [
            "Copy cxx variable to c argument for output."
        ],
        "notes": [
            "Used to copy and blank fill an output Fortran string."
        ],
        "c_post_call": [
            "{c_helper_char_copy}({c_var}, {c_var_len},\t {c_local_cxx},\t -1);"
        ],
        "helper": [
            "char_copy"
        ]
    },
    {
        "name": "c_mixin_char-copyout-len",
        "comments": [
            "Copy cxx variable to c argument for output."
        ],
        "notes": [
            "Used to copy and blank fill an output Fortran string.",
            "The input length is explicit since it may not be NULL terminated."
        ],
        "c_post_call": [
            "{c_helper_char_copy}({c_var}, {c_var_len},\t {c_local_cxx},\t {c_local_len});"
        ],
        "helper": [
            "char_copy"
        ]
    },
    {
        "name": "c_mixin_char-array-alloc",
        "comments": [
            "Converts a contiguous Fortran array of characters into",
            "an array of of char * pointers to NULL terminated strings."
        ],
        "c_pre_call": [
            "char **{c_local_cxx} = {c_helper_char_array_alloc}({c_var},\t {c_var_size},\t {c_var_len});"
        ],
        "c_post_call": [
            "{c_helper_char_array_free}({c_local_cxx}, {c_var_size});"
        ],
        "c_local": [
            "cxx"
        ],
        "helper": [
            "char_array_alloc",
            "char_array_free"
        ]
    },
    {
        "name": "f_mixin_cdesc_allocate_1d_character",
        "comments": [
            "Allocate Fortran character array from cdesc."
        ],
        "f_post_call": [
            "allocate(character(len={f_var_cdesc}%elem_len) ::\t {f_var}({f_var_cdesc}%size))",
            "{f_var_cdesc}%base_addr = C_LOC({f_var})"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_LOC"
            ]
        },
        "fmtdict": {
            "f_target_attr": ", target"
        }
    },
    {
        "name": "f_mixin_in_string_array_buf",
        "comments": [
            "Pass argument, size and len to C."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "character(len=*){f_intent_attr} :: {f_var}(:)"
        ],
        "f_arg_call": [
            "{f_var}",
            "size({f_var}, kind=C_SIZE_T)",
            "len({f_var}, kind=C_INT)"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_SIZE_T",
                "C_INT"
            ]
        },
        "f_need_wrapper": true,
        "i_dummy_arg": [
            "{i_var}",
            "{i_var_size}",
            "{i_var_len}"
        ],
        "i_dummy_decl": [
            "character(kind=C_CHAR), intent(IN) :: {i_var}(*)",
            "integer(C_SIZE_T), intent(IN), value :: {i_var_size}",
            "integer(C_INT), intent(IN), value :: {i_var_len}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_CHAR",
                "C_SIZE_T",
                "C_INT"
            ]
        },
        "c_prototype": [
            "const char *{c_var}",
            "size_t {c_var_size}",
            "int {c_var_len}"
        ],
        "c_temps": [
            "size",
            "len"
        ]
    },
    {
        "name": "f_mixin_pass_character_buf",
        "comments": [
            "Pass CHARACTER and LEN to C wrapper."
        ],
        "notes": [
            "Do not define f_dummy_arg or f_dummy_decl here",
            "to allow it to be used with functions and arguments."
        ],
        "f_local_decl": [
            "integer(C_INT) {f_var_len}"
        ],
        "f_pre_call": [
            "{f_var_len} = len({f_var}, kind=C_INT)"
        ],
        "f_arg_call": [
            "{f_var}",
            "{f_var_len}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_INT"
            ]
        },
        "f_temps": [
            "len"
        ],
        "f_need_wrapper": true
    },
    {
        "name": "c_mixin_in_character_buf",
        "notes": [
            "Used with function which pass in character argument.",
            "Used with function which return a char *.",
            "C wrapper will fill argument."
        ],
        "mixin": [
            "c_mixin_character-assumed-length"
        ],
        "i_dummy_arg": [
            "{i_var_len}"
        ],
        "i_dummy_decl": [
            "integer(C_INT), value, intent(IN) :: {i_var_len}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_INT"
            ]
        },
        "c_prototype": [
            "char *{c_var}",
            "int {c_var_len}"
        ],
        "c_temps": [
            "len"
        ]
    },
    {
        "name": "f_mixin_function_char",
        "comments": [
            "Return a single char from a function."
        ],
        "f_dummy_decl": [
            "character{f_intent_attr} :: {f_var}"
        ],
        "f_arg_call": [
            "{f_var}"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "character(kind=C_CHAR){i_intent_attr} :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_CHAR"
            ]
        },
        "c_prototype": [
            "char *{c_var}"
        ],
        "c_call": [
            "*{c_var} = {C_call_function};"
        ],
        "c_need_wrapper": true
    },
    {
        "name":"##### char #################################################"
    },
    {
        "alias": [
            "f_in_char",
            "c_in_char",
            "f_none_char"
        ],
        "mixin": [
            "f_mixin_declare-arg-char",
            "c_mixin_declare-arg-char",
            "c_mixin_arg-call-cvar"
        ]
    },
    {
        "alias": [
            "f_function_char",
            "c_function_char"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function_char"
        ]
    },
    {
        "alias": [
            "f_function_char*",
            "c_function_char*",
            "f_function_char*_allocatable",
            "f_function_char*_copy",
            "f_function_char*_pointer",
            "f_function_char*_raw_library"
        ],
        "notes": [
            "Return a type(C_PTR) from Fortran."
        ],
        "mixin": [
            "f_mixin_function",
            "f_mixin_function-as-cptr",
            "f_mixin_function-interface-as-cptr",
            "c_mixin_function-assign-to-cvar"
        ]
    },
    {
        "alias": [
            "f_in_char*",
            "c_in_char*",
            "f_out_char*",
            "c_out_char*",
            "f_inout_char*",
            "c_inout_char*",
            "f_in_char*_capi",
            "f_out_char*_capi",
            "f_inout_char*_capi",
            "f_none_char*"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar"
        ]
    },
    {
        "alias": [
            "f_in_char*_buf",
            "c_in_char*_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_char-alloc",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "alias": [
            "f_out_char*_buf",
            "c_out_char_*_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_arg-call-cvar",
            "c_mixin_char-blank-fill"
        ]
    },
    {
        "alias": [
            "f_inout_char*_buf",
            "c_inout_char*_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_arg-call-cxx",
            "c_mixin_char-copyout",
            "c_mixin_char-alloc"
        ]
    },
    {
        "alias": [
            "f_function_char*_buf_copy",
            "c_function_char*_buf_copy"
        ],
        "notes": [
            "char *getname() +len(30)",
            "Copy result into caller's buffer.",
            "XXX - maybe fmtdict to rename c_local_cxx as output"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_arg-call-cvar",
            "c_mixin_function-assign-to-local",
            "c_mixin_char-copyout"
        ]
    },
    {
        "alias": [
            "f_function_char*_buf_funcarg_copy"
        ],
        "notes": [
            "Change function result into an argument.",
            "Use F_string_result_as_arg as the argument name.",
            "was base:f_function_char*_buf_copy"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function-as-character-arg",
            "f_mixin_function-as-character-arg-var-len",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_arg-call-cvar",
            "c_mixin_function-assign-to-local",
            "c_mixin_char-copyout"
        ]
    },
    {
        "alias": [
            "f_in_char**",
            "c_in_char**"
        ],
        "notes": [
            "Treat as an assumed length array in Fortran interface.",
            "From Fortran, the caller is responsible for creating an array",
            "of pointers to NULL terminated strings."
        ],
        "mixin": [
            "f_mixin_interface-as-cptr-array",
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar"
        ]
    },
    {
        "alias": [
            "f_in_char**_buf",
            "c_in_char**_buf"
        ],
        "mixin": [
            "f_mixin_in_string_array_buf",
            "c_mixin_char-array-alloc",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "name": "c_out_char**",
        "usage": [
            "char **arg +intent(out)"
        ],
        "mixin": [
            "f_mixin_interface-as-cptr",
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar"
        ]
    },
    {
        "name": "f_out_char**_buf_copy",
        "usage": [
            "char **arg +intent(out)+deref(copy)"
        ],
        "notes": [
            "Copy char array into Fortran argument.",
            "Also used with CFI."
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-cxx-ptr",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_char-copyout"
        ]
    },
    {
        "sphinx-start-after": "f_out_char**_cdesc_pointer_library",
        "name": "f_out_char**_cdesc_pointer_library",
        "usage": [
            "char **arg +intent(out)+deref(pointer)"
        ],
        "notes": [
            "Return a Fortran pointer to C memory."
        ],
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_cdesc_char_pointer",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_cdesc_fill_char",
            "c_mixin_local-cvar-ptr",
            "c_mixin_arg-call-cvar-address"
        ],
        "sphinx-end-before": "f_out_char**_cdesc_pointer_library"
    },
    {
        "alias": [
            "f_function_char_cdesc_allocatable",
            "f_function_char*_cdesc_allocatable"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_char_allocate",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_fill_char"
        ]
    },
    {
        "alias": [
            "f_function_char_cdesc_pointer",
            "f_function_char*_cdesc_pointer_library"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_fill_char",
            "f_mixin_cdesc_char_pointer"
        ]
    },
    {
        "alias": [
            "f_function_char_cdesc_funcarg_allocatable",
            "f_function_char*_cdesc_funcarg_allocatable"
        ],
        "usage": [
            "char *func(void) +deref(allocatable)+funcarg"
        ],
        "mixin": [
            "f_mixin_function-to-subroutine",
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_char_allocate",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_fill_char"
        ]
    },
    {
        "alias": [
            "f_function_char_cdesc_funcarg_pointer",
            "f_function_char*_cdesc_funcarg_pointer_library"
        ],
        "usage": [
            "char *func(void) +deref(pointer)+funcarg"
        ],
        "mixin": [
            "f_mixin_function-to-subroutine",
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cdesc_fill_char",
            "f_mixin_cdesc_char_pointer"
        ]
    },
    {
        "alias": [
            "#f_function_char_funcarg_raw",
            "f_function_char*_funcarg_raw_library"
        ],
        "usage": [
            "char *func(void) +deref(raw)+funcarg"
        ],
        "mixin": [
            "f_mixin_function-to-subroutine",
            "f_mixin_declare-arg-as-cptr",
            "f_mixin_interface-as-cptr",
            "f_mixin_arg-call-fvar",
            "c_mixin_as-intent-out",
            "c_mixin_declare-arg-void**",
            "c_mixin_function-assign-to-local",
            "c_mixin_assign-to-void**"
        ]
    },
    {
        "name":"##### string mixin #########################################"
    },
    {
        "name": "c_mixin_local-string",
        "comments": [
            "Create local std::string."
        ],
        "c_pre_call": [
            "{c_const}std::string {c_local_cxx};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_local-string-init",
        "comments": [
            "Create local std::string from the argument."
        ],
        "c_pre_call": [
            "{c_const}std::string {c_local_cxx}({c_var});"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_local-string-init-trim",
        "comments": [
            "Create local std::string from the argument with trim."
        ],
        "c_pre_call": [
            "int {c_local_trim} = {c_helper_char_len_trim}({c_var}, {c_var_len});",
            "{c_const}std::string {c_local_cxx}({c_var}, {c_local_trim});"
        ],
        "c_local": [
            "cxx",
            "trim"
        ],
        "helper": [
            "char_len_trim"
        ]
    },
    {
        "name": "c_mixin_local-string*",
        "comments": [
            "Create local std::string pointer."
        ],
        "c_pre_call": [
            "std::string *{cxx_var};"
        ]
    },
    {
        "name": "c_mixin_declare-string-cstr-cvar",
        "comments": [
            "Assign std::string.data to cvar."
        ],
        "usage": [
            "Declares a function result.",
            "Always uses const."
        ],
        "c_post_call": [
            "const char *{c_var} = {c_local_cxx}{cxx_member}c_str();"
        ]
    },
    {
        "name": "c_mixin_declare-string-data-cvar",
        "comments": [
            "Assign std::string.data to cvar.",
            "Always uses const."
        ],
        "usage": [
            "Declares a function result."
        ],
        "c_post_call": [
            "const char *{c_var} = {c_local_cxx}{cxx_member}data();"
        ]
    },
    {
        "name": "c_mixin_string-strcpy-out",
        "comments": [
            "Strcpy std::string into argument."
        ],
        "c_post_call": [
            "std::strcpy({c_var}, {c_local_cxx}.c_str());"
        ],
        "impl_header": [
            "<cstring>"
        ]
    },
    {
        "name": "c_mixin_string-copy-out",
        "comments": [
            "Copy std::string into argument."
        ],
        "c_post_call": [
            "{c_helper_char_copy}({c_var}, {c_var_len},\t {c_local_cxx}.data(),\t {c_local_cxx}.size());"
        ],
        "helper": [
            "char_copy"
        ]
    },
    {
        "name": "c_mixin_string-char-copy-to-arg",
        "comments": [
            "Copy cxx variable into c variable."
        ],
        "c_post_call": [
            "if ({cxx_var}{cxx_member}empty()) {{+",
            "{c_helper_char_copy}({c_var}, {c_var_len},\t {nullptr},\t 0);",
            "-}} else {{+",
            "{c_helper_char_copy}({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());",
            "-}}"
        ],
        "helper": [
            "char_copy"
        ]
    },
    {
        "name": "f_mixin_str_array",
        "comments": [
            "Collect information about a string argument."
        ],
        "notes": [
            "XXX - maybe use character(*) directly in f_dummy_decl"
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "{f_type}{f_intent_attr}{f_target_attr} :: {f_var}{f_assumed_shape}"
        ]
    },
    {
        "name": "c_mixin_c-str",
        "notes": [
            "Always return a const ptr since c_str is const.",
            "The Fortran interface returns a type(C_PTR)."
        ],
        "i_result_decl": [
            "type(C_PTR) :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "c_return_type": "const char *",
        "c_post_call": [
            "const char *{c_var} = NULL;",
            "if (!{c_local_cxx}->empty()) {c_var} = {c_local_cxx}->c_str();"
        ]
    },
    {
        "name": "f_mixin_helper_array_string_allocatable",
        "comments": [
            "Assign to std::string pointer from C++ function.",
            "Copy into Fortran allocated memory."
        ],
        "notes": [
            "Pass a cdesc down to describe the memory and a capsule to hold the",
            "C++ array. Allocate in fortran, fill from C.",
            "[see also f_out_vector_&_cdesc_allocatable_targ_string_scalar]"
        ],
        "mixin": [
            "c_mixin_local-string*"
        ],
        "f_post_call": [
            "call {f_helper_array_string_allocatable}({f_var_cdesc}, {f_var_capsule})"
        ],
        "c_post_call": [
            "{c_var_cdesc}->rank = {rank};{gen.c_array_shape}",
            "{c_var_cdesc}->size = {gen.c_array_size};",
            "if ({attr_len} > 0) {{+",
            "{c_var_cdesc}->elem_len = {attr_len};",
            "-}} else {{+",
            "{c_var_cdesc}->elem_len = {c_helper_array_string_out_len}({cxx_var}, {c_var_cdesc}->size);",
            "-}}"
        ],
        "helper": [
            "array_string_allocatable",
            "array_string_out_len"
        ]
    },
    {
        "name": "c_mixin_string_max_len",
        "comments": [
            "Compute maximum length of array of std::string."
        ],
        "notes": [
            "attr_len is defined from attribute +len(x)"
        ],
        "c_post_call": [
            "size_t {c_var_len} = {attr_len};",
            "if ({c_var_len} <= 0) {{+",
            "{c_var_len} = {c_helper_array_string_out_len}({cxx_var}, {gen.c_dimension_size});",
            "-}}"
        ],
        "c_temps": [
            "len"
        ],
        "helper": [
            "array_string_out_len"
        ]
    },
    {
        "name":"##### string ###############################################"
    },
    {
        "alias": [
            "f_function_string*_cdesc_pointer",
            "f_function_string&_cdesc_pointer",
            "f_function_string*_cdesc_pointer_caller",
            "f_function_string*_cdesc_pointer_library",
            "f_function_string&_cdesc_pointer_caller",
            "f_function_string&_cdesc_pointer_library"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-local",
            "c_mixin_cdesc_function_string",
            "f_mixin_cdesc_char_pointer"
        ]
    },
    {
        "alias": [
            "f_in_string*",
            "c_in_string*"
        ],
        "mixin": [
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_local-string-init",
            "c_mixin_arg-call-cxx-address"
        ]
    },
    {
        "alias": [
            "f_in_string&",
            "c_in_string&"
        ],
        "notes": [
            "Similar to f_in_string*, but c_arg_call is pass by value."
        ],
        "mixin": [
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_local-string-init",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "alias": [
            "c_out_string*"
        ],
        "mixin": [
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_local-string",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_string-strcpy-out"
        ]
    },
    {
        "alias": [
            "c_out_string&"
        ],
        "notes": [
            "Similar to f_out_string*."
        ],
        "mixin": [
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_local-string",
            "c_mixin_arg-call-cxx",
            "c_mixin_string-strcpy-out"
        ]
    },
    {
        "alias": [
            "f_inout_string*",
            "c_inout_string*"
        ],
        "notes": [
            "XXX - the fortran wrapper is incorrect since it is passing buf",
            "  but only accepting one argument. Confused with f_inout_string*_buf"
        ],
        "mixin": [
            "f_mixin_pass_character_buf",
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_local-string-init",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_string-strcpy-out"
        ]
    },
    {
        "alias": [
            "f_inout_string&",
            "c_inout_string&"
        ],
        "mixin": [
            "f_mixin_pass_character_buf",
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_local-string-init",
            "c_mixin_arg-call-cxx",
            "c_mixin_string-strcpy-out"
        ]
    },
    {
        "alias": [
            "f_in_string*_buf",
            "c_in_string*_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx-address"
        ]
    },
    {
        "alias": [
            "f_in_string&_buf",
            "c_in_string&_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "alias": [
            "f_out_string*_buf",
            "c_out_string*_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_out_string&_buf",
            "c_out_string&_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string",
            "c_mixin_arg-call-cxx",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_inout_string*_buf",
            "c_inout_string*_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_inout_string&_buf",
            "c_inout_string&_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "c_function_string*",
            "c_function_string&",
            "c_function_string*_caller",
            "c_function_string*_library",
            "c_function_string*_copy",
            "c_function_string&_copy",
            "c_function_string&_library"
        ],
        "notes": [
            "Fortran calling a C function without",
            "any api argument - is this useful?"
        ],
        "mixin": [
            "c_mixin_function-assign-to-local"
        ],
        "i_result_decl": [
            "type(C_PTR) :: {i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "c_post_call": [
            "{c_const}char *{c_var} = {c_local_cxx}{cxx_member}c_str();"
        ],
        "c_return": [
            "return {c_var};"
        ]
    },
    {
        "name": "c_function_string",
        "notes": [
            "Cannot return a char array by value.",
            "Return a const pointer to std::string data."
        ],
        "mixin": [
            "c_mixin_capsule_pass",
            "c_mixin_function-assign-to-new",
            "c_mixin_c-str",
            "c_mixin_capsule_fill_arg"
        ]
    },
    {
        "name": "#f_in_string_scalar",
        "f_need_wrapper": true,
        "mixin": [
            "f_mixin_pass_character_buf"
        ],
        "f_dummy_decl": [
            "character(len=*), intent(IN) :: {f_var}"
        ]
    },
    {
        "alias": [
            "c_in_string"
        ],
        "notes": [
            "Pass a NULL terminated string to C wrapper.",
            "Pass directly as argument which will construct the std::string.",
            "This would work for Fortran if it explicited added C_NULL_CHAR."
        ],
        "mixin": [
            "c_mixin_character-assumed-length",
            "c_mixin_arg-call-cvar"
        ],
        "c_prototype": [
            "char *{c_var}"
        ]
    },
    {
        "alias": [
            "f_in_string_buf",
            "c_in_string_buf"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "alias": [
            "f_function_string*_cdesc_allocatable",
            "f_function_string&_cdesc_allocatable",
            "f_function_string*_cdesc_allocatable_caller",
            "f_function_string*_cdesc_allocatable_library",
            "f_function_string&_cdesc_allocatable_caller",
            "f_function_string&_cdesc_allocatable_library"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_capsule_pass",
            "c_mixin_function-assign-to-local",
            "c_mixin_cdesc_function_string",
            "c_mixin_capsule_fill_arg",
            "f_mixin_cdesc_char_allocate",
            "f_mixin_capsule_dtor"
        ]
    },
    {
        "alias": [
            "f_function_string_buf",
            "f_function_string*_buf",
            "f_function_string&_buf",
            "f_function_string_buf_copy",
            "f_function_string*_buf_copy",
            "f_function_string&_buf_copy",
            "c_function_string_buf_copy",
            "c_function_string*_buf_copy",
            "c_function_string&_buf_copy"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_arg-call-cvar",
            "c_mixin_function-assign-to-local",
            "c_mixin_string-char-copy-to-arg"
        ]
    },
    {
        "alias": [
            "f_function_string_buf_caller",
            "f_function_string*_buf_caller",
            "f_function_string&_buf_caller",
            "f_function_string_buf_copy_caller",
            "f_function_string*_buf_copy_caller",
            "f_function_string&_buf_copy_caller",
            "#c_function_string_buf_copy",
            "#c_function_string*_buf_copy",
            "#c_function_string&_buf_copy"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_string-char-copy-to-arg",
            "c_mixin_arg-call-cvar",
            "c_mixin_delete-cxx-variable"
        ]
    },
    {
        "alias": [
            "f_function_string_buf_funcarg_copy",
            "f_function_string&_buf_funcarg_copy"
        ],
        "notes": [
            "Change function result into an argument.",
            "Use F_string_result_as_arg as the argument name.",
            "was base:f_function_string_buf"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function-as-character-arg",
            "f_mixin_function-as-character-arg-var-len",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_arg-call-cvar",
            "c_mixin_function-assign-to-local",
            "c_mixin_string-char-copy-to-arg"
        ]
    },
    {
        "alias": [
            "f_function_string_cdesc_allocatable",
            "f_function_string_cdesc_allocatable_caller",
            "f_function_string_cdesc_allocatable_library"
        ],
        "usage": [
            "std::string func() +deref(allocatable)"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-new",
            "c_mixin_destructor_new-string",
            "c_mixin_cdesc_function_string",
            "f_mixin_cdesc_char_allocate",
            "f_mixin_capsule_use"
        ]
    },
    {
        "alias": [
            "f_function_string_cdesc_pointer_caller"
        ],
        "notes": [
            "Return-by-value will allocate a new std::string"
        ],
        "usage": [
            "std::string func() +deref(pointer)"
        ],
        "mixin": [
            "f_mixin_add_capsule_arg_to_fwrapper",
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_function-assign-to-new",
            "c_mixin_capsule_fill_arg",
            "c_mixin_cdesc_fill_string_local",
            "f_mixin_cdesc_char_pointer"
        ]
    },
    {
        "name": "f_function_string_raw_caller",
        "notes": [
            "Return-by-value will allocate a new std::string"
        ],
        "usage": [
            "std::string func() +deref(raw)"
        ],
        "mixin": [
            "f_mixin_function_ptr",
            "f_mixin_add_capsule_arg_to_fwrapper",
            "c_mixin_function-return-cvar",
            "c_mixin_function-assign-to-new",
            "c_mixin_declare-string-data-cvar",
            "c_mixin_capsule_fill_arg"
        ]
    },
    {
        "alias": [
            "f_out_string**_cdesc_copy",
            "c_out_string**_cdesc_copy"
        ],
        "notes": [
            "Pass a cdesc down to describe the memory and a capsule to hold the",
            "C++ array. Copy into Fortran argument.",
            "[see also f_out_vector_&_cdesc_allocatable_targ_string_scalar]"
        ],
        "mixin": [
            "f_mixin_str_array",
            "#f_mixin_declare-fortran-arg",
            "f_mixin_cdesc_char_fill",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_local-string*",
            "c_mixin_arg-call-cvar-address"
        ],
        "c_post_call": [
            "{c_helper_cdesc_array_string_out}(\t{c_var_cdesc},\t {cxx_var}, {gen.c_dimension_size});"
        ],
        "helper": [
            "cdesc_array_string_out"
        ]
    },
    {
        "alias": [
            "f_out_string**_copy",
            "c_out_string**"
        ],
        "notes": [
            "std::string **arg+intent(out)+dimension(size)",
            "Returning a pointer to a string*. However, this needs additional",
            "mapping for the C interface.  Fortran calls the +api(cdesc) variant."
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_interface-as-cptr-value"
        ],
        "notimplemented": true
    },
    {
        "name": "f_out_string**_cdesc_allocatable",
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_capsule_pass",
            "f_mixin_cdesc_allocate_1d_character",
            "f_mixin_helper_array_string_allocatable",
            "c_mixin_arg-call-cvar-address",
            "c_mixin_capsule_fill_arg",
            "f_mixin_capsule_dtor"
        ]
    },
    {
        "name":"##### vector native ########################################"
    },
    {
        "name": "c_function_vector<native>",
        "notimplemented": true,
        "notes": [
            "Cannot return a std::vector<native> by value."
        ]
    },
    {
        "alias": [
            "c_in_vector<native>&",
            "c_out_vector<native>&",
            "c_inout_vector<scalar>&",
            "c_in_vector<native*>&",
            "c_in_vector<string>&",
            "c_out_vector<string>&"
        ],
        "notimplemented": true,
        "notes": [
            "Need to know the length of the vector from C."
        ]
    },
    {
        "alias": [
            "f_in_vector<native>_buf",
            "f_in_vector<native>*_buf",
            "f_in_vector<native>&_buf",
            "c_in_vector<native>_buf",
            "c_in_vector<native>*_buf",
            "c_in_vector<native>&_buf"
        ],
        "notes": [
            "XXX - need to test scalar and pointer versions"
        ],
        "mixin": [
            "f_mixin_in_vector_buf",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}> {c_local_cxx}({c_var}, {c_var} + {c_var_size});"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "alias": [
            "c_out_vector<native>_buf_copy",
            "c_out_vector<native>*_buf_copy",
            "c_out_vector<native>&_buf_copy"
        ],
        "notes": [
            "XXX - need to test scalar and pointer versions"
        ],
        "mixin": [
            "f_mixin_out_vector_buf",
            "c_mixin_header_cstring",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}> {c_local_cxx};"
        ],
        "c_post_call": [
            "size_t {c_local_size} =\t *{c_var_size} < {c_local_cxx}.size() ?\t *{c_var_size} :\t {c_local_cxx}.size();",
            "std::memcpy({c_var},\t {c_local_cxx}.data(),\t {c_local_size}*sizeof({c_local_cxx}[0]));",
            "*{c_var_size} = {c_local_size};"
        ],
        "c_local": [
            "cxx",
            "size"
        ]
    },
    {
        "alias": [
            "c_inout_vector<native>_buf_copy",
            "c_inout_vector<native>*_buf_copy",
            "c_inout_vector<native>&_buf_copy"
        ],
        "mixin": [
            "f_mixin_out_vector_buf",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}> {c_local_cxx}({c_var}, {c_var} + *{c_var_size});"
        ],
        "c_post_call": [
            "*{c_var_size} = {c_local_cxx}->size()"
        ],
        "c_local": [
            "cxx"
        ],
        "notimplemented": true
    },
    {
        "alias": [
            "c_out_vector<native>_buf_malloc",
            "c_out_vector<native>*_buf_malloc",
            "c_out_vector<native>&_buf_malloc"
        ],
        "notes": [
            "Create empty local vector then copy result to",
            "malloc allocated array.",
            "XXX - need to test scalar and pointer versions"
        ],
        "mixin": [
            "c_mixin_header_cstring",
            "c_mixin_out_vector_buf_malloc",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}> {c_local_cxx};"
        ],
        "c_post_call": [
            "size_t {c_local_bytes} =\t {c_local_cxx}.size()*sizeof({c_local_cxx}[0]);",
            "*{c_var} = static_cast<{targs[0].cxx_type} *>\t(std::malloc({c_local_bytes}));",
            "std::memcpy(*{c_var},\t {c_local_cxx}.data(),\t {c_local_bytes});",
            "*{c_var_size} = {c_local_cxx}.size();"
        ],
        "c_local": [
            "cxx",
            "bytes"
        ]
    },
    {
        "alias": [
            "c_inout_vector<native>_buf_malloc",
            "c_inout_vector<native>*_buf_malloc",
            "c_inout_vector<native>&_buf_malloc"
        ],
        "notes": [
            "Create local vector from arguments then copy result to",
            "malloc allocated array."
        ],
        "mixin": [
            "c_mixin_header_cstring",
            "c_mixin_out_vector_buf_malloc",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}> {c_local_cxx}(*{c_var}, *{c_var} + *{c_var_size});"
        ],
        "c_post_call": [
            "size_t {c_local_bytes} =\t {c_local_cxx}.size()*sizeof({c_local_cxx}[0]);",
            "*{c_var} = static_cast<{targs[0].cxx_type} *>\t(std::realloc(*{c_var},\t {c_local_bytes}));",
            "std::memcpy(*{c_var},\t {c_local_cxx}.data(),\t {c_local_bytes});",
            "*{c_var_size} = {c_local_cxx}.size();"
        ],
        "c_local": [
            "cxx",
            "bytes"
        ]
    },
    {
        "name": "c_mixin_cdesc_vector_fill",
        "comments": [
            "Fill cdesc with vector information.",
            "Return address and size of vector data."
        ],
        "c_post_call": [
            "{c_var_cdesc}->base_addr = {c_local_cxx}->empty() ? {nullptr} : &{c_local_cxx}->front();",
            "{c_var_cdesc}->type = {targs[0].sh_type};",
            "{c_var_cdesc}->elem_len = sizeof({targs[0].cxx_type});",
            "{c_var_cdesc}->size = {c_local_cxx}->size();",
            "{c_var_cdesc}->rank = 1;",
            "{c_var_cdesc}->shape[0] = {c_var_cdesc}->size;"
        ],
        "helper": [
            "type_defines"
        ]
    },
    {
        "name": "c_mixin_new_vector<native>",
        "mixin": [
            "c_mixin_destructor_new-vector",
            "c_mixin_cdesc_vector_fill"
        ],
        "comments": [
            "Create a local std::vector."
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}>\t *{c_local_cxx} = new std::vector<{cxx_T}>;"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "alias": [
            "f_out_vector<native>*_cdesc_copy",
            "c_out_vector<native>*_cdesc"
        ],
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_template_native_arg1",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_copy_array",
            "c_mixin_new_vector<native>",
            "c_mixin_arg-call-cxx"
        ],
        "notes": [
            "Not supported for C wrappers."
        ]
    },
    {
        "alias": [
            "f_out_vector<native>&_cdesc_copy",
            "c_out_vector<native>&_cdesc"
        ],
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_template_native_arg1",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_copy_array",
            "c_mixin_new_vector<native>",
            "c_mixin_arg-call-cxx-deref"
        ],
        "notes": [
            "Not supported for C wrappers."
        ]
    },
    {
        "name": "c_mixin_inout_vector<native>_cdesc",
        "mixin": [
            "f_mixin_cdesc_inout_array",
            "c_mixin_cdesc_inout_vector",
            "c_mixin_destructor_new-vector",
            "c_mixin_cdesc_vector_fill"
        ],
        "c_pre_call": [
            "std::vector<{cxx_T}> *{c_local_cxx} = \tnew std::vector<{cxx_T}>\t(\t{c_var}, {c_var} + {c_var_size});"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "f_function_vector<native>_cdesc_allocatable",
        "notes": [
            "Almost same as intent_out_buf.",
            "Similar to f_vector_out_allocatable but must declare result variable.",
            "Always return a 1-d array."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_template_native_arg1",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_allocate_1d",
            "c_mixin_destructor_new-vector",
            "c_mixin_cdesc_vector_fill",
            "f_mixin_cdesc_copy_array"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}>\t *{c_local_cxx} = new std::vector<{cxx_T}>;"
        ],
        "c_call": [
            "*{c_local_cxx} = {C_call_function};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_function_vector<native>_malloc",
        "notes": [
            "Create empty local vector then copy result to",
            "malloc allocated array.",
            "Add an argument with the length of the array."
        ],
        "mixin": [
            "c_mixin_header_cstring",
            "c_mixin_function_vector_malloc"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}>\t {c_local_cxx};"
        ],
        "c_call": [
            "{c_local_cxx} = {C_call_function};"
        ],
        "c_post_call": [
            "size_t {c_local_bytes} =\t {c_local_cxx}.size()*sizeof({c_local_cxx}[0]);",
            "{targs[0].cxx_type} *{c_var} =\t static_cast<{targs[0].cxx_type} *>\t(std::malloc({c_local_bytes}));",
            "std::memcpy({c_var},\t {c_local_cxx}.data(),\t {c_local_bytes});",
            "*{c_var_size} = {c_local_cxx}.size();"
        ],
        "c_local": [
            "cxx",
            "bytes"
        ]
    },
    {
        "alias": [
            "f_in_vector<native*>&_buf",
            "c_in_vector<native*>&_buf"
        ],
        "notes": [
            "Create a vector for pointers.",
            "Specialize for std::vector<native *>."
        ],
        "mixin": [
            "f_mixin_in_2d_vector_buf",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "std::vector<{cxx_T}> {c_local_cxx};",
            "for (size_t i=0; i < {c_var_size}; ++i) {{+",
            "{c_local_cxx}.push_back({c_var} + ({c_var_len}*i));",
            "-}}"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "f_inout_vector<native>&_cdesc_allocatable",
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_template_native_arg1",
            "f_mixin_deallocate",
            "f_mixin_cdesc_allocate_1d",
            "c_mixin_inout_vector<native>_cdesc",
            "c_mixin_arg-call-cxx-deref",
            "f_mixin_cdesc_copy_array"
        ]
    },
    {
        "name":"##### vector string mixin ##################################"
    },
    {
        "name": "f_mixin_helper_vector_string_allocatable",
        "comments": [
            "Allocate a vector<string> variable.",
            "Copy into Fortran allocated memory."
        ],
        "f_post_call": [
            "call {f_helper_cdesc_vector_string_allocatable}({f_var_cdesc}, {f_var_capsule})"
        ],
        "c_pre_call": [
            "std::vector<std::string> *{c_local_cxx} = new std::vector<std::string>;"
        ],
        "c_post_call": [
            "if ({attr_len} > 0) {{+",
            "{c_var_cdesc}->elem_len = {attr_len};",
            "-}} else {{+",
            "{c_var_cdesc}->elem_len = {c_helper_vector_string_out_len}(*{c_local_cxx});",
            "-}}",
            "{c_var_cdesc}->size      = {c_local_cxx}->size();"
        ],
        "c_local": [
            "cxx"
        ],
        "helper": [
            "cdesc_vector_string_allocatable",
            "vector_string_out_len"
        ]
    },
    {
        "name":"##### vector string ########################################"
    },
    {
        "alias": [
            "f_in_vector<string>_buf",
            "c_in_vector<string>_buf",
            "f_in_vector<string>*_buf",
            "c_in_vector<string>*_buf",
            "f_in_vector<string>&_buf",
            "c_in_vector<string>&_buf"
        ],
        "notes": [
            "XXX - need to test scalar and pointer versions"
        ],
        "mixin": [
            "f_mixin_in_string_array_buf",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "std::vector<{cxx_T}> {c_local_cxx};",
            "{{+",
            "{c_const}char *{c_local_s} = {c_var};",
            "std::vector<{cxx_T}>::size_type",
            "+{c_local_i} = 0,",
            "{c_local_n} = {c_var_size};",
            "-for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+",
            "{c_local_cxx}.push_back(\tstd::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s}, {c_var_len})));",
            "{c_local_s} += {c_var_len};",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "cxx",
            "i",
            "n",
            "s"
        ],
        "helper": [
            "char_len_trim"
        ]
    },
    {
        "alias": [
            "c_out_vector<string>_buf_copy",
            "c_out_vector<string>*_buf_copy",
            "c_out_vector<string>&_buf_copy"
        ],
        "notimplemented": true,
        "mixin": [
            "c_mixin_character-assumed-length",
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar-deref"
        ]
    },
    {
        "name": "f_out_vector_buf_targ_string_scalar",
        "mixin": [
            "f_mixin_in_string_array_buf",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "{c_const}std::vector<{cxx_T}> {c_local_var};"
        ],
        "c_post_call": [
            "{{+",
            "char *{c_local_s} = {c_var};",
            "std::vector<{cxx_T}>::size_type",
            "+{c_local_i} = 0,",
            "{c_local_n} = {c_var_size};",
            "{c_local_n} = std::min({c_local_var}.size(),{c_local_n});",
            "-for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+",
            "{c_helper_char_copy}({c_local_s}, {c_var_len},\t {c_local_var}[{c_local_i}].data(),\t {c_local_var}[{c_local_i}].size());",
            "{c_local_s} += {c_var_len};",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "cxx",
            "i",
            "n",
            "s"
        ],
        "helper": [
            "char_copy"
        ]
    },
    {
        "name": "f_inout_vector_buf_targ_string_scalar",
        "mixin": [
            "f_mixin_in_string_array_buf",
            "c_mixin_arg-call-cxx"
        ],
        "c_pre_call": [
            "std::vector<{cxx_T}> {cxx_var};",
            "{{+",
            "{c_const}char *{c_local_s} = {c_var};",
            "std::vector<{cxx_T}>::size_type",
            "+{c_local_i} = 0,",
            "{c_local_n} = {c_var_size};",
            "-for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+",
            "{cxx_var}.push_back(std::string({c_local_s},\t{c_helper_char_len_trim}({c_local_s}, {c_var_len})));",
            "{c_local_s} += {c_var_len};",
            "-}}",
            "-}}"
        ],
        "c_post_call": [
            "{{+",
            "char *{c_local_s} = {c_var};",
            "std::vector<{cxx_T}>::size_type",
            "+{c_local_i} = 0,",
            "{c_local_n} = {c_var_size};",
            "-{c_local_n} = std::min({cxx_var}.size(),{c_local_n});",
            "for(; {c_local_i} < {c_local_n}; {c_local_i}++) {{+",
            "{c_helper_char_copy}({c_local_s}, {c_var_len},\t {cxx_var}[{c_local_i}].data(),\t {cxx_var}[{c_local_i}].size());",
            "{c_local_s} += {c_var_len};",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "cxx",
            "i",
            "n",
            "s"
        ],
        "helper": [
            "char_len_trim"
        ]
    },
    {
        "alias": [
            "f_out_vector<string>&_cdesc_copy",
            "c_out_vector<string>&_cdesc"
        ],
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_template_native_arg1",
            "f_mixin_cdesc_char_fill",
            "f_mixin_cdesc_pass_to_cwrapper",
            "c_mixin_arg-call-cvar"
        ],
        "c_pre_call": [
            "{c_const}std::vector<std::string> {cxx_var};"
        ],
        "c_post_call": [
            "{c_helper_cdesc_vector_string_out}(\t{c_var_cdesc},\t {cxx_var});"
        ],
        "helper": [
            "type_defines",
            "array_context",
            "cdesc_vector_string_out"
        ]
    },
    {
        "alias": [
            "f_out_vector<string>&_cdesc_allocatable",
            "c_out_vector<string>&_cdesc_allocatable"
        ],
        "mixin": [
            "f_mixin_declare-character-arg",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_capsule_pass",
            "f_mixin_cdesc_allocate_1d_character",
            "f_mixin_helper_vector_string_allocatable",
            "c_mixin_capsule_fill_local",
            "f_mixin_capsule_dtor",
            "c_mixin_arg-call-cxx-deref"
        ]
    },
    {
        "name": "f_inout_vector<native>&_cdesc_copy",
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_template_native_arg1",
            "c_mixin_inout_vector<native>_cdesc",
            "c_mixin_arg-call-cxx-deref",
            "f_mixin_cdesc_copy_array"
        ]
    },
    {
        "alias": [
            "f_out_vector<native>*_cdesc_allocatable",
            "f_out_vector<native>&_cdesc_allocatable"
        ],
        "notes": [
            "Copy into allocated array."
        ],
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_template_native_arg1",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_allocate_1d",
            "f_mixin_cdesc_copy_array",
            "c_mixin_new_vector<native>",
            "c_mixin_arg-call-cxx-deref"
        ]
    },
    {
        "name":"##### shadow mixin #########################################"
    },
    {
        "name": "f_mixin_shadow-arg",
        "comments": [
            "Pass a shadow type to C wrapper."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "{f_type}{f_intent_attr} :: {f_var}"
        ],
        "f_arg_call": [
            "{f_var}%{F_derived_member}"
        ],
        "f_module": {
            "{f_module_name}": [
                "{f_kind}"
            ]
        },
        "f_need_wrapper": true
    },
    {
        "name": "c_mixin_shadow",
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "type({f_capsule_data_type}){i_intent_attr} :: {i_var}"
        ],
        "i_module": {
            "{f_module_name}": [
                "{f_capsule_data_type}"
            ]
        },
        "c_prototype": [
            "{c_type} *{c_var}"
        ]
    },
    {
        "name":"##### shadow ###############################################"
    },
    {
        "alias": [
            "f_in_shadow",
            "c_in_shadow"
        ],
        "mixin": [
            "f_mixin_shadow-arg",
            "c_mixin_shadow",
            "c_mixin_arg-call-cxx-deref"
        ],
        "i_dummy_decl": [
            "type({f_capsule_data_type}){i_intent_attr}, value :: {i_var}"
        ],
        "c_prototype": [
            "{c_type} {c_var}"
        ],
        "c_pre_call": [
            "{c_const}{cxx_type} *{c_local_cxx} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}.addr{cast2};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "alias": [
            "f_in_shadow*",
            "c_in_shadow*",
            "f_inout_shadow*",
            "c_inout_shadow*",
            "f_inout_shadow&",
            "c_inout_shadow&",
            "f_in_smartptr<shadow>*",
            "c_in_smartptr<shadow>*",
            "f_inout_smartptr<shadow>*",
            "c_inout_smartptr<shadow>*"
            
        ],
        "mixin": [
            "f_mixin_shadow-arg",
            "c_mixin_cast-argument",
            "c_mixin_arg-call-cxx",
            "c_mixin_shadow"
        ]
    },
    {
        "alias": [
            "f_function_shadow*_capsule",
            "c_function_shadow*_capsule",
            "f_function_shadow*_capsule_caller",
            "f_function_shadow*_capsule_library",

            "f_function_shadow&_capsule",
            "f_function_shadow&_capsule_caller",
            "f_function_shadow&_capsule_library",
            "c_function_shadow&_capsule",
            "c_function_shadow&_capsule_caller",
            "c_function_shadow&_capsule_library"
        ],
        "notes": [
            "Return a c_capsule_data_type."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_function-assign-to-local",
            "c_mixin_capsule_fill_cvar"
        ]
    },
    {
        "alias": [
            "f_function_shadow*_this",
            "c_function_shadow*_this"
        ],
        "notes": [
            "Input set return_this.",
            "Do not return anything."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine"
        ],
        "f_result_var": "as-subroutine",
        "c_call": [
            "{C_call_function};"
        ]
    },
    {
        "alias": [
            "f_in_shadow&",
            "c_in_shadow&"
        ],
        "mixin": [
            "f_mixin_shadow-arg",
            "c_mixin_shadow",
            "c_mixin_arg-call-cxx-deref"
        ],
        "c_pre_call": [
            "{c_const}{cxx_type} *{c_local_cxx} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}->addr{cast2};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "alias": [
            "c_function_shadow*_capptr",
            "c_function_shadow*_capptr_caller",
            "c_function_shadow*_capptr_library",

            "c_function_shadow&_capptr",
            "c_function_shadow&_capptr_caller",
            "c_function_shadow&_capptr_library"
        ],
        "notes": [
            "Return a c_capsule_data_type."
        ],
        "mixin": [
            "c_mixin_function_shadow_capptr",
            "c_mixin_shadow",
            "c_mixin_as-intent-out",
            "c_mixin_function-assign-to-local",
            "c_mixin_capsule_fill_cvar",
            "c_mixin_function-return-capptr"
        ]
    },
    {
        "alias": [
            "c_function_shadow*_capptr_shared"
        ],
        "notes": [
            "std::shared_ptr with a shadow class."
        ],
        "base": "c_function_shadow*_capptr"
    },
    {
        "alias": [
            "f_function_shadow_capsule_caller",
            "f_function_shadow<native>_capsule_caller"
        ],
        "notes": [
            "Return an instance by value.",
            "Create memory in c_pre_call so it will survive the return.",
            "owner=caller sets idtor flag to release the memory.",
            "c_local_var is passed in as argument."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_function-assign-to-new",
            "c_mixin_capsule_fill_cvar"
        ]
    },
    {
        "alias": [
            "c_function_shadow_capptr",
            "c_function_shadow<native>_capptr"
        ],
        "notes": [
            "Return an instance by value.",
            "Create memory in c_pre_call so it will survive the return.",
            "owner=caller sets idtor flag to release the memory.",
            "c_local_var is passed in as argument."
        ],
        "mixin": [
            "c_mixin_function_shadow_capptr",
            "c_mixin_shadow",
            "c_mixin_as-intent-out",
            "c_mixin_function-assign-to-new",
            "c_mixin_capsule_fill_cvar",
            "c_mixin_function-return-capptr"
        ]
    },
    {
        "alias": [
            "f_ctor_shadow_capsule",
            "f_ctor_shadow_capsule_caller",
            "c_ctor_shadow_capsule"
        ],
        "mixin": [
            "f_mixin_as-intent-out",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_as-intent-out"
        ],
        "c_return_type": "void",
        "c_call": [
            "{cxx_type} *{cxx_var} =\t new {cxx_type}({C_call_list});",
            "{c_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});",
            "{c_var}->idtor = {idtor};",
            "{c_var}->cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;"
        ],
        "owner": "caller"
    },
    {
        "alias": [
            "c_ctor_shadow_capptr"
        ],
        "mixin": [
            "c_mixin_function_shadow_capptr",
            "c_mixin_shadow",
            "c_mixin_as-intent-out"
        ],
        "c_call": [
            "{cxx_type} *{cxx_var} =\t new {cxx_type}({C_call_list});",
            "{c_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});",
            "{c_var}->idtor = {idtor};",
            "{c_var}->cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;"
        ],
        "owner": "caller"
    },
    {
        "name": "c_mixin_operator_assignment_basic",
        "notes": [
            "std::weak_ptr has no wrapped constructor.",
            "It must be made from a std::shared_ptr with an assignment."
        ],
        "c_body": [
            "void {C_name_assign_api}({c_type_lhs} *lhs_capsule,\t {c_type_rhs} *rhs_capsule)",
            "{{+",
            "{cxx_type_lhs} *lhs =\t static_cast<{cxx_type_lhs} *>(lhs_capsule->addr);",
            "{cxx_type_rhs} *rhs =\t static_cast<{cxx_type_rhs} *>(rhs_capsule->addr);",
            "if (lhs == nullptr) {{+",
            "lhs = new {cxx_type}(*rhs);",
            "lhs_capsule->addr = lhs;",
            "lhs_capsule->idtor = {idtor};",
            "-}} else {{+",
            "*lhs = *rhs;",
            "-}}",
            "-}}"
        ],
        "destructor_name": "assignment-{cxx_type}",
        "destructor_header": [
            "<memory>"
        ],
        "destructor": [
            "auto cxx_ptr =\t reinterpret_cast<{cxx_type}*>(ptr);",
            "delete cxx_ptr;"
        ]
    },
    {
        "name": "f_mixin_operator_assignment_basic",
        "notes": [
            "Used with options.F_assignment_api == 'basic'"
        ],
        "f_operator_body": [
            "subroutine {F_name_assign_api}(lhs, rhs)+",
            "use iso_c_binding, only : c_associated, c_f_pointer",
            "class({f_derived_type_lhs}), intent(OUT) :: lhs",
            "type({f_derived_type_rhs}), intent(IN) :: rhs",
            "interface+",
            "subroutine do_assign(lhs, rhs)\t bind(C,\t name=\"{C_name_assign_api}\")+",
            "import :: {f_interface_import}",
            "type({f_capsule_data_type_lhs}), intent(INOUT) :: lhs",
            "type({f_capsule_data_type_rhs}), intent(IN) :: rhs",
            "-end subroutine do_assign",
            "-end interface",
            "call do_assign(lhs%{F_derived_member},\t rhs%{F_derived_member})",
            "-end subroutine {F_name_assign_api}"
        ]
    },
    {
        "name": "c_mixin_operator_assignment",
        "notes": [
            "Adapts code from SWIG_assign."
        ],
        "c_body": [
            "void {C_name_assign_api}({c_type_lhs} *lhs_capsule,\t {c_type_rhs} *rhs_capsule)",
            "{{+",
            "if (lhs_capsule->addr == {nullptr}) {{+",
              "/* LHS is unassigned */",
            "if (rhs_capsule->cmemflags & SWIG_MEM_RVALUE) {{+",
            "{capture_code}",
            "-}} else {{+",
            "{alias_code}",
            "-}}",
            "-}} else if (rhs_capsule->addr == {nullptr}) {{+",
            "{destroy_code}",
            "-}} else if (lhs_capsule->addr == rhs_capsule->addr) {{+",
              "// Lhs-assignment: ignore.",
            "-}} else if (rhs_capsule->cmemflags & SWIG_MEM_RVALUE) {{+",
            "{move_alias_code}",
            "-}} else {{+",
            "{copy_alias_code}",
            "-}}",
            "-}}"
        ]
    },
    {
        "name": "c_mixin_operator_assignment_fmtdict",
        "notes": [
            "Adapts code from SWIG AssignmentPolicy."
        ],
        "fmtdict": {
            "capture_code": [
                "// Capture pointer from RHS, clear 'moving' flag.",
                "lhs_capsule->addr = rhs_capsule->addr;",
                "lhs_capsule->idtor = rhs_capsule->idtor;",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;"
            ],
            "alias_code": [
                "// Aliasing another class; clear ownership or copy smart pointer.",
                "lhs_capsule->addr = rhs_capsule->addr;",
                "lhs_capsule->idtor = rhs_capsule->idtor;",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_OWN;"
            ],
            "destroy_code": [
                "// Replace LHS with a null pointer.",
                "if (lhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "{C_memory_dtor_function}(\t({c_capsule_data_type} *) lhs_capsule);",
                "-}}",
                "lhs_capsule->addr = {nullptr};",
                "lhs_capsule->idtor = 0;",
                "lhs_capsule->cmemflags = 0;"
            ],
            "move_alias_code": [
                "// Transferred ownership from a variable that's about to be lost.",
                "// Move-assign and delete the transient data.",
                "if (lhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "{C_memory_dtor_function}(\t({c_capsule_data_type} *) lhs_capsule);",
                "-}}",
                "lhs_capsule->addr = rhs_capsule->addr;",
                "lhs_capsule->idtor = rhs_capsule->idtor;",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;"
            ],
            "copy_alias_code": [
                "// RHS shouldn't be deleted, alias to LHS.",
                "if (lhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "{C_memory_dtor_function}(\t({c_capsule_data_type} *) lhs_capsule);",
                "-}}",
                "lhs_capsule->addr = rhs_capsule->addr;",
                "lhs_capsule->idtor = rhs_capsule->idtor;",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;"
            ]
        }
    },
    {
        "name": "c_mixin_operator_assignment_fmtdict_makeshared",
        "notes": [
            "Create std::shared_ptr and point to the rhs.",
            "Adapts code from SWIG AssignmentPolicy<T, ASSIGNMENT_SMATPTR>."
        ],
        "fmtdict": {
            "capture_code": [
                "// Capture pointer from RHS, clear 'moving' flag.",
                "{cxx_type_rhs} *rhs =\t static_cast<{cxx_type_rhs}*>\t(rhs_capsule->addr);",
                "{cxx_type_lhs} *lhs =\t new {cxx_type_lhs}\t(rhs);",
                "//lhs_capsule->addr = new {cxx_type_lhs} (*static_cast<{cxx_type_lhs}*>(rhs_capsule->addr));",
                "lhs_capsule->addr = lhs;",
                "lhs_capsule->idtor = {idtor};",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;"
            ],
            "alias_code": [
                "// Aliasing another class; clear ownership or copy smart pointer.",
                "lhs_capsule->addr = new {cxx_type_lhs}\t (*static_cast<{cxx_type_lhs}*>\t(rhs_capsule->addr));",
                "lhs_capsule->idtor = {idtor};",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags | SWIG_MEM_OWN;"
            ],
            "destroy_code": [
                "// Replace LHS with a null pointer.",
                "//if (lhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "//{C_memory_dtor_function}(({c_capsule_data_type} *) lhs_capsule);",
                "//-}}",
                "{cxx_type_lhs} *lhs =\t static_cast<{cxx_type_lhs}*>\t(lhs_capsule->addr);",
                "lhs->reset();",
                "lhs_capsule->addr = {nullptr};",
                "lhs_capsule->idtor = 0;",
                "lhs_capsule->cmemflags = 0;"
            ],
            "move_alias_code": [
                "// Transferred ownership from a variable that's about to be lost.",
                "// Move-assign and delete the transient data.",
                "// LHS and RHS should both 'own' their shared pointers.",
                "{cxx_type_lhs} *lhs =\t static_cast<{cxx_type_lhs}*>\t(lhs_capsule->addr);",
                "{cxx_type_rhs} *rhs =\t static_cast<{cxx_type_rhs}*>\t(rhs_capsule->addr);",
                "lhs->reset(rhs);",
                "lhs_capsule->addr = rhs_capsule->addr;",
                "lhs_capsule->idtor = {idtor};",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;",
                "if (rhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "{C_memory_dtor_function}(\t({c_capsule_data_type} *) rhs_capsule);",
                "-}}"
            ],
            "copy_alias_code": [
                "// RHS shouldn't be deleted, alias to LHS.",
                "// LHS and RHS should both 'own' their shared pointers.",
                "{cxx_type_lhs} *lhs =\t static_cast<{cxx_type_lhs}*>\t(lhs_capsule->addr);",
                "{cxx_type_rhs} *rhs =\t static_cast<{cxx_type_rhs}*>\t(rhs_capsule->addr);",
                "lhs->reset(rhs);"
            ]
        },
        "destructor_name": "assignment-{cxx_type_lhs}",
        "destructor_header": [
            "<memory>"
        ],
        "destructor": [
            "auto cxx_ptr =\t reinterpret_cast<{cxx_type_lhs}*>(ptr);",
            "delete cxx_ptr;"
        ]
    },
    {
        "name": "c_mixin_operator_assignment_fmtdict_weak",
        "notes": [
            "std::weak_ptr has no wrapped constructor.",
            "It must be made from a std::shared_ptr with an assignment.",
            "Adapts code from SWIG AssignmentPolicy<T, ASSIGNMENT_SMATPTR>."
        ],
        "fmtdict": {
            "capture_code": [
                "// Capture pointer from RHS, clear 'moving' flag.",
                "lhs_capsule->addr = rhs_capsule->addr;",
                "lhs_capsule->idtor = rhs_capsule->idtor;",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;"
            ],
            "alias_code": [
                "// Aliasing another class; clear ownership or copy smart pointer.",
                "lhs_capsule->addr = new {cxx_type_lhs}\t (*static_cast<{cxx_type_lhs}*>\t(rhs_capsule->addr));",
                "lhs_capsule->idtor = {idtor};",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags | SWIG_MEM_OWN;"
            ],
            "destroy_code": [
                "// Replace LHS with a null pointer.",
                "if (lhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "{C_memory_dtor_function}(\t({c_capsule_data_type} *) lhs_capsule);",
                "-}}",
                "lhs_capsule->addr = {nullptr};",
                "lhs_capsule->idtor = 0;",
                "lhs_capsule->cmemflags = 0;"
            ],
            "move_alias_code": [
                "// Transferred ownership from a variable that's about to be lost.",
                "// Move-assign and delete the transient data.",
                "// LHS and RHS should both 'own' their shared pointers.",
                "{cxx_type_lhs} *lhs =\t static_cast<{cxx_type_lhs}*>\t(lhs_capsule->addr);",
                "{cxx_type_rhs} *rhs =\t static_cast<{cxx_type_rhs}*>\t(rhs_capsule->addr);",
                "*lhs = *rhs;",
                "lhs_capsule->cmemflags = rhs_capsule->cmemflags & ~SWIG_MEM_RVALUE;",
                "if (rhs_capsule->cmemflags & SWIG_MEM_OWN) {{+",
                "{C_memory_dtor_function}(\t({c_capsule_data_type} *) rhs_capsule);",
                "-}}"
            ],
            "copy_alias_code": [
                "// RHS shouldn't be deleted, alias to LHS.",
                "// LHS and RHS should both 'own' their shared pointers.",
                "{cxx_type_lhs} *lhs =\t static_cast<{cxx_type_lhs}*>\t(lhs_capsule->addr);",
                "{cxx_type_rhs} *rhs =\t static_cast<{cxx_type_rhs}*>\t(rhs_capsule->addr);",
                "*lhs = *rhs;"
            ]
        },
        "destructor_name": "assignment-{cxx_type_lhs}",
        "destructor_header": [
            "<memory>"
        ],
        "destructor": [
            "auto cxx_ptr =\t reinterpret_cast<{cxx_type_lhs}*>(ptr);",
            "delete cxx_ptr;"
        ]
    },
    {
        "name": "f_mixin_operator_assignment",
        "notes": [
            "Used with options.F_assignment_api == 'swig'",
            "lhs is intent(INOUT) so the initial value is preserved",
            "and can be deleted if necessary."
        ],
        "f_operator_body": [
            "subroutine {F_name_assign_api}(lhs, rhs)+",
            "use iso_c_binding, only : c_associated, c_f_pointer",
            "class({f_derived_type_lhs}), intent(INOUT) :: lhs",
            "type({f_derived_type_rhs}), intent(IN) :: rhs",
            "interface+",
            "subroutine do_assign(lhs, rhs)\t bind(C,\t name=\"{C_name_assign_api}\")+",
            "import :: {f_interface_import}",
            "type({f_capsule_data_type_lhs}), intent(INOUT) :: lhs",
            "type({f_capsule_data_type_rhs}), intent(IN) :: rhs",
            "-end subroutine do_assign",
            "-end interface",
            "call do_assign(lhs%{F_derived_member},\t rhs%{F_derived_member})",
            "-end subroutine {F_name_assign_api}"
        ]
    },
    {
        "alias": [
            "f_operator_assignment_shadow_basic"
        ],
        "notes": [
            "The original operator overload only worked with weak_ptr.",
            "This is for all the others which do nothing."
        ]
    },
    {
        "alias": [
            "f_operator_assignment_shadow_basic_weak"
        ],
        "mixin": [
            "f_mixin_operator_assignment_basic",
            "c_mixin_operator_assignment_basic"
        ]
    },
    {
        "alias": [
            "f_operator_assignment_shadow"
        ],
        "mixin": [
            "f_mixin_operator_assignment",
            "c_mixin_operator_assignment",
            "c_mixin_operator_assignment_fmtdict"
        ]
    },
    {
        "alias": [
            "f_operator_assignment_shadow_shared",
            "f_operator_assignment_shadow_weak"
        ],
        "mixin": [
            "f_mixin_operator_assignment",
            "c_mixin_operator_assignment",
            "c_mixin_operator_assignment_fmtdict_weak"
        ]
    },
    {
        "alias": [
            "f_operator_assignment_shadow_makeshared"
        ],
        "notes": [
            "  shared = object, create shared object, keep object"
        ],
        "mixin": [
            "f_mixin_operator_assignment",
            "c_mixin_operator_assignment",
            "c_mixin_operator_assignment_fmtdict_makeshared"
        ]
    },
    {
        "name": "#f_operator_assignment_shadow_orig",
        "notes": [
            "Used with options.F_assignment_api == 'orig'",
            "Originally attached to options.F_auto_reference_count",
            "but never worked. Included for reference."
        ],
        "f_type_bound": [
            "procedure :: {F_name_assign_api}",
            "generic :: assignment(=) => {F_name_assign_api}"
        ],
        "f_operator_body": [
            "subroutine {F_name_assign_api}(lhs, rhs)+",
            "use iso_c_binding, only : c_associated, c_f_pointer",
            "class({F_derived_name}), intent(INOUT) :: lhs",
            "class({F_derived_name}), intent(IN) :: rhs",
            "",
            "lhs%{F_derived_member} = rhs%{F_derived_member}",
            "if (c_associated(lhs%{F_derived_member}%addr)) then+",
            "call c_f_pointer(lhs%{F_derived_member}%addr, lhs%{F_derived_member})",
            "lhs%{F_derived_member}%refcount = lhs%{F_derived_member}%refcount + 1",
            "-else+",
            "nullify(lhs%{F_derived_member}%addr)",
            "-endif",
            "-end subroutine {F_name_assign_api}"
        ]
    },
    {
        "name":"#### smartptr ##############################################"
    },
    {
        "name": "c_mixin_make-shared",
        "comments": [
            "Create a std::shared_pointer on the heap to hold the pointer to the instance."
        ],
        "notes": [
            "Uses std::make_shared."
        ],
        "c_call": [
            "std::shared_ptr<{baseclass.cxx_type}> *{c_local_shared} =\t new std::shared_ptr<{baseclass.cxx_type}>;",
            "*{c_local_shared} = \t std::make_shared<{baseclass.cxx_type}>({C_call_list});",
            "{c_var}->addr = static_cast<{c_const}void *>(\t{c_local_shared});",
            "{c_var}->idtor = {idtor};",
            "{c_var}->cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;"
        ],
        "c_local": [
            "shared"
        ],
        "impl_header": [
            "<memory>"
        ],
        "owner": "shared",
        "helper": [
            "capsule_memflags"
        ]
    },
    {
        "name": "c_mixin_make-weak",
        "comments": [
            "Create a std::weak_pointer on the heap to hold the pointer to the instance."
        ],
        "notes": [
            "This does not use C_call_list since it does not create an Object.",
            "It only creates the weak_ptr."
        ],
        "c_call": [
            "{cxx_type} *{cxx_var} =\t new {cxx_type};",
            "{c_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});",
            "{c_var}->idtor = {idtor};",
            "{c_var}->cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;"
        ],
        "impl_header": [
            "<memory>"
        ],
        "owner": "shared",
        "helper": [
            "capsule_memflags"
        ]
    },
    {
        "alias": [
            "f_ctor_shadow_capsule_shared"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_destructor_new-shadow-shared",
            "c_mixin_make-shared"
        ]
    },
    {
        "alias": [
            "f_ctor_shadow_capsule_weak"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_destructor_new-shadow-shared",
            "c_mixin_make-weak"
        ]
    },
    {
        "alias": [
            "c_ctor_shadow_capptr_shared",
            "c_ctor_shadow_capptr_weak"
        ],
        "mixin": [
            "c_mixin_function_shadow_capptr",
            "c_mixin_shadow",
            "c_mixin_as-intent-out",
            "c_mixin_destructor_new-shadow-shared",
            "c_mixin_make-shared"
        ]
    },
    {
        "alias": [
            "f_function_smartptr<shadow>_capsule"
        ],
        "notes": [
            "Used with std::shared_ptr<Object>* createChildA(void)"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_function-assign-to-new",
            "c_mixin_capsule_fill_cvar"
        ]
    },
    {
        "alias": [
            "f_function_smartptr<shadow>*_capsule"
        ],
        "notes": [
            "TODO - does ownership make sense here?"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_capsule_function_shadow",
            "c_mixin_shadow",
            "c_mixin_function-assign-to-local",
            "c_mixin_capsule_fill_cvar"
        ]
    },
    {
        "alias": [
            "c_function_smartptr<shadow>_capptr"
        ],
        "notes": [
            "Used with std::shared_ptr<Object>* createChildA(void)"
        ],
        "mixin": [
            "c_mixin_function_shadow_capptr",
            "c_mixin_shadow",
            "c_mixin_as-intent-out",
            "c_mixin_function-assign-to-new",
            "c_mixin_capsule_fill_cvar",
            "c_mixin_function-return-capptr"
        ]
    },
    {
        "alias": [
            "c_function_smartptr<shadow>*_capptr"
        ],
        "mixin": [
            "c_mixin_function_shadow_capptr",
            "c_mixin_shadow",
            "c_mixin_as-intent-out",
            "c_mixin_function-assign-to-local",
            "c_mixin_capsule_fill_cvar",
            "c_mixin_function-return-capptr"
        ]
    },
    {
        "name":"#### dtor ##################################################"
    },
    {
        "alias": [
            "f_dtor",
            "c_dtor"
        ],
        "mixin": [
            "c_mixin_header_stddef"
        ],
        "f_arg_call": [],
        "c_call": [
            "if ({C_this}->cmemflags & SWIG_MEM_OWN) {{+",
            "delete {CXX_this};",
            "-}}",
            "{C_this}->addr = {nullptr};",
            "{C_this}->idtor = 0;",
            "{C_this}->cmemflags = 0;"
        ]
    },
    {
        "name":"##### struct ###############################################"
    },
    {
        "alias": [
            "f_in_struct",
            "f_in_struct*",
            "f_out_struct*",
            "f_inout_struct*",
            "c_in_struct",
            "c_in_struct*",
            "c_out_struct*",
            "c_inout_struct*"
        ],
        "notes": [
            "Used with in, out, inout.",
            "C pointer -> void pointer -> C++ pointer."
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ]
    },
    {
        "alias": [
            "f_in_struct&",
            "c_in_struct&",
            "f_out_struct&",
            "c_out_struct&",
            "f_inout_struct&",
            "c_inout_struct&"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar-deref",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ]
    },
    {
        "start-after": "start function_struct_scalar",
        "alias": [
            "f_function_struct",
            "c_function_struct"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-local-variable"
        ],
        "f_arg_call": [
            "{f_var}"
        ],
        "c_prototype": [
            "{c_type} *{c_var}"
        ],
        "c_call": [
            "*{c_var} = {C_call_function};"
        ],
        "c_need_wrapper": true,
        "end-before": "end function_struct_scalar"
    },
    {
        "alias": [
            "f_function_struct*_pointer",
            "c_function_struct*"
        ],
        "notes": [
            "C++ pointer -> void pointer -> C pointer."
        ],
        "mixin": [
            "f_mixin_function_c-ptr",
            "c_mixin_function-assign-to-cvar"
        ]
    },
    {
        "name":"##### getter ###############################################"
    },
    {
        "name": "c_mixin_getter_char*",
        "notes": [
            "Extract char* field from struct."
        ],
        "c_pre_call": [
            "char *{c_local_cxx} = {CXX_this}->{field_name};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_getter_char*_len",
        "notes": [
            "Extract char* len.",
            "The char* member may be NULL or the string must be NULL terminated."
        ],
        "mixin": [
            "c_mixin_header_cstring"
        ],
        "c_pre_call": [
            "size_t {c_local_len} = {c_local_cxx} == {nullptr} ? 0 : {stdlib}strlen({c_local_cxx});"
        ],
        "c_local": [
            "len"
        ]
    },
    {
        "name": "c_mixin_getter_string",
        "notes": [
            "Extract std::string field from struct."
        ],
        "c_pre_call": [
            "const char *{c_local_cxx} = {nullptr};",
            "size_t {c_local_len} = {CXX_this}->{field_name}.size();",
            "if ({c_local_len} != 0) {{+",
            "{c_local_cxx} =\t {CXX_this}->{field_name}.data();",
            "-}}"

        ],
        "c_local": [
            "cxx",
            "len"
        ]
    },
    {
        "name": "f_mixin_getter_argname",
        "notes": [
            "Name of getter result as an argument.",
            "Since Shroud creates the getter function,",
            "we know this name will not conflict."
        ],
        "fmtdict": {
            "f_var": "val",
            "i_var": "val",
            "c_var": "val"
        }
    },
    {
        "name": "f_getter_struct*_fapi_pointer",
        "notes": [
            "XXX - unused - the getter does not need a C wrapper if api(fapi)",
            "The getter can be done totally from Fortran for a pointer to a scalar.",
            "Return value a function result."
        ],
        "f_dummy_decl": [
            "{f_type}{f_deref_attr} :: {f_result_var}"
        ],
        "f_call": [
            "call c_f_pointer({CXX_this}%{field_name}, {f_result_var})"
        ],
        "f_module": {
            "iso_c_binding": [
                "c_f_pointer"
            ]
        },
        "f_need_wrapper": true
    },
    {
        "alias": [
            "f_setter_struct*_pointer",
            "f_setter_struct*"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ],
        "c_post_call": [
            "{CXX_this}->{field_name} = val;"
        ]
    },
    {
        "name": "f_setter_struct**",
        "mixin": [
            "c_mixin_declare-arg",
            "f_mixin_declare-fortran-arg"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "type(C_PTR), intent(IN) :: {i_var}{i_dimension}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_PTR"
            ]
        },
        "c_post_call": [
            "{CXX_this}->{field_name} = val;"
        ]
    },
    {
        "name": "f_getter_bool",
        "mixin": [
            "f_mixin_declare-local-variable",
            "c_mixin_declare-fortran-result"
        ],
        "f_arg_call": [],
        "c_return": [
            "return {CXX_this}->{field_name};"
        ]
    },
    {
        "name": "f_setter_bool",
        "mixin": [
            "c_mixin_declare-arg",
            "f_mixin_declare-fortran-arg",
            "f_mixin_declare-interface-arg",
            "f_mixin_logical-local-var",
            "f_mixin_logical-in"
        ],
        "c_post_call": [
            "{CXX_this}->{field_name} = val;"
        ]
    },
    {
        "alias": [
            "f_getter_native",
            "c_getter_native",
            "f_getter_native*_pointer",
            "c_getter_native*"
        ],
        "mixin": [
            "f_mixin_declare-local-variable",
            "c_mixin_declare-fortran-result"
        ],
        "f_arg_call": [],
        "c_return": [
            "return {CXX_this}->{field_name};"
        ],
        "c_need_wrapper": true
    },
    {
        "alias": [
            "f_setter",
            "c_setter"
        ],
        "f_arg_call": [],
        "f_call": [
            "call {f_call_function}({F_arg_c_call})"
        ]
    },
    {
        "alias": [
            "f_setter_native",
            "f_setter_native*",
            "c_setter_native",
            "f_setter_char*_buf",
            "c_setter_native*"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "f_mixin_declare-interface-arg",
            "f_mixin_declare-fortran-arg"
        ],
        "f_arg_call": [
            "{fc_var}"
        ],
        "c_post_call": [
            "{CXX_this}->{field_name} = val;"
        ]
    },
    {
        "alias": [
            "f_getter_native*_cdesc_pointer",
            "f_getter_struct*_cdesc_pointer"
        ],
        "notes": [
            "Similar to calling a function, but save field pointer instead."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_native_pointer",
            "c_mixin_cdesc_getter"
        ]
    },
    {
        "name": "f_getter_char*_cdesc_allocatable",
        "notes": [
            "Get a char* member of a class as a Fortran allocatable."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_char_allocate",
            "c_mixin_getter_char*",
            "c_mixin_getter_char*_len",
            "c_mixin_cdesc_getter_char*"
        ]
    },
    {
        "name": "f_getter_char*_cdesc_pointer",
        "notes": [
            "Get a char* member of a class as a Fortran pointer."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_char_pointer",
            "c_mixin_getter_char*",
            "c_mixin_getter_char*_len",
            "c_mixin_cdesc_getter_char*"
        ]
    },
    {
        "name": "f_getter_char*_buf_copy",
        "notes": [
            "Get a char* member of a class as a Fortran pointer."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function-as-character-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_getter_char*",
            "c_mixin_char-copyout",
            "f_mixin_getter_argname"
        ]
    },
    {
        "name": "f_getter_struct**_cdesc_raw",
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_native_raw",
            "c_mixin_cdesc_getter"
        ]
    },
    {
        "name": "f_getter_string_cdesc_allocatable",
        "notes": [
            "Get a std::string member of a class as a Fortran allocatable.",
            "XXX - check for array of std::string"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_char_allocate",
            "c_mixin_getter_string"
        ],
        "c_call": [
            "{c_var_cdesc}->base_addr = const_cast<char *>({c_local_cxx});",
            "{c_var_cdesc}->type = 0; // SH_CHAR;",
            "{c_var_cdesc}->elem_len = {c_local_len};",
            "{c_var_cdesc}->rank = 0;"
        ]
    },
    {
        "name": "f_getter_string_cdesc_pointer",
        "notes": [
            "Get a std__string member of a class as a Fortran pointer.",
            "XXX - check for array of std::string"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cdesc_pass_to_cwrapper",
            "f_mixin_cdesc_char_pointer",
            "c_mixin_getter_string"
        ],
        "c_call": [
            "{c_var_cdesc}->base_addr = const_cast<char *>({c_local_cxx});",
            "{c_var_cdesc}->type = 0; // SH_CHAR;",
            "{c_var_cdesc}->elem_len = {c_local_len};",
            "{c_var_cdesc}->rank = 0;"
        ]
    },
    {
        "name": "f_getter_string_buf_copy",
        "notes": [
            "Get a char* member of a class as a Fortran pointer."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function-as-character-arg",
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf",
            "c_mixin_getter_string",
            "c_mixin_char-copyout-len",
            "f_mixin_getter_argname"
        ]
    },
    {
        "alias": [
            "f_setter_string_buf",
            "c_setter_string_scalar_buf"
        ],
        "notes": [
            "Extract meta data and pass to C.",
            "Create std::string from Fortran meta data."
        ],
        "mixin": [
            "f_mixin_pass_character_buf",
            "c_mixin_in_character_buf"
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "character(len=*){f_intent_attr} :: {f_var}"
        ],
        "c_post_call": [
            "{CXX_this}->{field_name} = std::string({c_var},\t {c_var_len});"
        ]
    },
    {
        "name":"##### cfi mixin ############################################"
    },
    {
        "name": "f_mixin_cfi_pass_character",
        "comments": [
            "Pass argument to C wrapper"
        ],
        "f_need_wrapper": true,
        "f_arg_call": [
            "{f_var}"
        ]
    },
    {
        "name": "c_mixin_cfi_arg",
        "comments": [
            "Make the C wrapper argument a CFI_desc_t."
        ],
        "c_prototype": [
            "CFI_cdesc_t *{c_var_cfi}"
        ],
        "c_temps": [
            "cfi"
        ],
        "iface_header": [
            "ISO_Fortran_binding.h"
        ]
    },
    {
        "name": "f_mixin_cfi_character-deferred-length",
        "notes": [
            "Pass a character deferred length argument down to C",
            "This may be used with function result so do not mixin f_mixin_dummy_arg."
        ],
        "mixin": [
            "f_mixin_character-deferred-length",
            "c_mixin_dummy_arg",
            "c_mixin_character-deferred-length",
            "c_mixin_cfi_arg"
        ],
        "f_arg_call": [
            "{f_var}"
        ]
    },
    {
        "name": "c_mixin_cfi-unpack-base-addr",
        "notes": [
            "Unpack the base_addr from the CFI_desc_t variable."
        ],
        "c_pre_call": [
            "{c_type} *{c_var} = {cast_static}{c_type} *{cast1}{c_var_cfi}->base_addr{cast2};"
        ]
    },
    {
        "name": "c_mixin_cfi-unpack-base-addr-cxx",
        "c_pre_call": [
            "{cxx_type} *{c_local_cxx} = {cast_static}{cxx_type} *{cast1}{c_var_cfi}->base_addr{cast2};"
        ],
        "c_local": [
            "cxx"
        ]
    },
    {
        "name": "c_mixin_cfi-unpack-len",
        "notes": [
            "Unpack the elem_len from the CFI_desc_t variable."
        ],
        "c_pre_call": [
            "size_t {c_var_len} = {c_var_cfi}->elem_len;"
        ],
        "c_temps": [
            "len"
        ]
    },
    {
        "name": "c_mixin_cfi-unpack-len-size",
        "notes": [
            "Unpack the base_addr from the CFI_desc_t variable",
            "and the first dimension as the size.",
            "Used with 1d arrays of characters:  CHARACTER(len) var(nvar)."
        ],
        "c_pre_call": [
            "size_t {c_var_len} = {c_var_cfi}->elem_len;",
            "size_t {c_var_size} = {c_var_cfi}->dim[0].extent;"
        ],
        "c_temps": [
            "len",
            "size"
        ]
    },
    {
        "name": "c_mixin_cfi_copy-to-arg",
        "comments": [
            "Copy cxx variable into c variable."
        ],
        "c_post_call": [
            "char *{c_var} = {cast_static}char *{cast1}{c_var_cfi}->base_addr{cast2};",
            "if ({c_local_cxx}{cxx_member}empty()) {{+",
            "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {nullptr},\t 0);",
            "-}} else {{+",
            "{c_helper_char_copy}({c_var}, {c_var_cfi}->elem_len,\t {c_local_cxx}{cxx_member}data(),\t {c_local_cxx}{cxx_member}size());",
            "-}}"
        ],
        "helper": [
            "char_copy"
        ]
    },
    {
        "name": "c_mixin_cfi_arg_character",
        "comments": [
            "Character argument passed as CFI_desc_t."
        ],
        "mixin": [
            "c_mixin_cfi_arg"
        ],
        "i_dummy_decl": [
            "character(len=*){i_intent_attr} :: {i_var}"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ]
    },
    {
        "name": "f_mixin_cfi_arg-character-array",
        "comments": [
            "Character array argument passed as CFI_desc_t."
        ],
        "notes": [
            "XXX - does the interface need kind=C_CHAR and/or len=:"
        ],
        "mixin": [
            "c_mixin_cfi_arg"
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "character(len=*){f_intent_attr} :: {f_var}(:)"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "character(len=*){i_intent_attr} :: {i_var}(:)"
        ]
    },
    {
        "name": "c_mixin_cfi_char*_allocatable",
        "comments": [
            "Allocate CFI_desc_t for character."
        ],
        "c_post_call": [
            "if ({cxx_var} != {nullptr}) {{+",
            "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *) 0, \tstrlen({cxx_var}));",
            "if (SH_ret == CFI_SUCCESS) {{+",
            "{stdlib}memcpy({c_var_cfi}->base_addr, \t{cxx_var}, \t{c_var_cfi}->elem_len);",
            "-}}",
            "-}}"
        ]
    },
    {
        "name": "c_mixin_cfi_string*_pointer",
        "c_post_call": [
            "int {c_local_err};",
            "if ({c_local_cxx} == {nullptr}) {{+",
            "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});",
            "-}} else {{+",
            "CFI_CDESC_T(0) {c_local_fptr};",
            "CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};",
            "void *{c_local_cptr} = const_cast<char *>({c_local_cxx}{cxx_member}data());",
            "size_t {c_local_len} = {c_local_cxx}{cxx_member}length();",
            "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});",
            "if ({c_local_err} == CFI_SUCCESS) {{+",
            "{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;",
            "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "cptr",
            "fptr",
            "cdesc",
            "len",
            "err"
        ]
    },
    {
        "name": "c_mixin_cfi_string**_allocatable",
        "comments": [
            "Allocate CFI_desc_t for character (requires +dimension)."
        ],
        "c_post_call": [
            "if ({cxx_var} != {nullptr}) {{+",
            "{gen.c_extents_decl}int SH_ret = CFI_allocate({c_var_cfi}, \t{gen.c_lower_use}, \t{gen.c_extents_use}, \t{c_var_len});",
            "if (SH_ret == CFI_SUCCESS) {{+",
            "{c_helper_cfi_array_string_out}({c_var_cfi}, {cxx_var}, {gen.c_dimension_size});",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "extents",
            "lower"
        ],
        "helper": [
            "lower_bounds_CFI",
            "cfi_array_string_out"
        ]
    },
    {
        "name": "c_mixin_cfi_arg_native",
        "comments": [
            "Native argument which use CFI_desc_t."
        ],
        "mixin": [
            "c_mixin_cfi_arg"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "{i_type}{i_intent_attr}{f_deref_attr} :: {i_var}{f_assumed_shape}"
        ],
        "i_module": {
            "iso_c_binding": [
                "{f_kind}"
            ]
        }
    },
    {
        "sphinx-start-after": "c_mixin_cfi_native_allocatable",
        "name": "c_mixin_cfi_native_allocatable",
        "comments": [
            "Allocate copy of C pointer (requires +dimension)."
        ],
        "mixin": [
            "c_mixin_header_cstring"
        ],
        "c_post_call": [
            "if ({c_local_cxx} != {nullptr}) {{+",
            "{gen.c_extents_decl}int SH_ret = CFI_allocate({c_var_cfi}, \t{gen.c_lower_use}, \t{gen.c_extents_use}, \t0);",
            "if (SH_ret == CFI_SUCCESS) {{+",
            "{stdlib}memcpy({c_var_cfi}->base_addr, \t{c_local_cxx}, \t{c_var_cfi}->elem_len);",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "extents",
            "lower"
        ],
        "helper": [
            "lower_bounds_CFI"
        ],
        "sphinx-end-before": "c_mixin_cfi_native_allocatable"
    },
    {
        "name": "c_mixin_cfi_native_pointer",
        "comments": [
            "Convert C pointer to Fortran pointer."
        ],
        "c_post_call": [
            "{{+",
            "CFI_CDESC_T({rank}) {c_local_fptr};",
            "CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};",
            "void *{c_local_cptr} = const_cast<{c_type} *>({c_local_cxx});",
            "{gen.c_extents_decl}int {c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t {typemap.cfi_type},\t 0,\t {rank},\t {gen.c_extents_use});",
            "if ({c_local_err} == CFI_SUCCESS) {{+",
            "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {gen.c_lower_use});",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "extents",
            "lower",
            "cptr",
            "fptr",
            "cdesc",
            "err"
        ],
        "helper": [
            "lower_bounds_CFI"
        ]
    },
    {
        "name": "c_mixin_cfi_character_pointer",
        "comments": [
            "Convert C pointer to deferred-length CHARACTER Fortran scalar pointer."
        ],
        "mixin": [
            "c_mixin_header_cstring"
        ],
        "c_post_call": [
            "int {c_local_err};",
            "if ({cxx_var} == {nullptr}) {{+",
            "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {nullptr},\t {nullptr});",
            "-}} else {{+",
            "CFI_CDESC_T(0) {c_local_fptr};",
            "CFI_cdesc_t *{c_local_cdesc} = {cast_reinterpret}CFI_cdesc_t *{cast1}&{c_local_fptr}{cast2};",
            "void *{c_local_cptr} = {cxx_nonconst_ptr};",
            "size_t {c_local_len} = {stdlib}strlen({cxx_var});",
            "{c_local_err} = CFI_establish({c_local_cdesc},\t {c_local_cptr},\t CFI_attribute_pointer,\t CFI_type_char,\t {c_local_len},\t 0,\t {nullptr});",
            "if ({c_local_err} == CFI_SUCCESS) {{+",
            "{c_var_cfi}->elem_len = {c_local_cdesc}->elem_len;",
            "{c_local_err} = CFI_setpointer(\t{c_var_cfi},\t {c_local_cdesc},\t {nullptr});",
            "-}}",
            "-}}"
        ],
        "c_local": [
            "cptr",
            "fptr",
            "cdesc",
            "len",
            "err"
        ]
    },
    {
        "name":"##### cfi ##################################################"
    },
    {
        "alias": [
            "f_function_char*_cfi_allocatable",
            "f_function_char_cfi_allocatable"
        ],
        "notes": [
            "Add allocatable attribute to declaration."
        ],
        "usage": [
            "char *func(void) +deref(allocatable)"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_header_cstring",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cfi_char*_allocatable"
        ],
        "f_need_wrapper": true
    },
    {
        "alias": [
            "f_function_char_cfi_pointer",
            "f_function_char*_cfi_pointer_library"
        ],
        "usage": [
            "char *func(void) +deref(pointer)"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cfi_character_pointer"
        ],
        "f_need_wrapper": true
    },
    {
        "alias": [
            "f_function_char*_cfi_funcarg_allocatable",
            "f_function_char_cfi_funcarg_allocatable"
        ],
        "notes": [
            "Add allocatable attribute to declaration."
        ],
        "usage": [
            "char *func(void) +deref(allocatable)+funcarg"
        ],
        "mixin": [
            "f_mixin_function-to-subroutine",
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_header_cstring",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cfi_char*_allocatable"
        ]
    },
    {
        "alias": [
            "f_function_char_cfi_funcarg_pointer",
            "f_function_char*_cfi_funcarg_pointer_library"
        ],
        "usage": [
            "char *func(void) +deref(pointer)+funcarg"
        ],
        "mixin": [
            "f_mixin_function-to-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_function-assign-to-cvar",
            "c_mixin_cfi_character_pointer"
        ]
    },
    {
        "alias": [
            "f_in_native*_cfi",
            "f_inout_native*_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_native",
            "c_mixin_cfi-unpack-base-addr-cxx",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "name": "f_in_char*_cfi",
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_char-alloc",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "name": "f_out_char*_cfi",
        "notes": [
            "Allocate a local array as large as input argument plus 1.",
            "Pass the library function, then copy back to input argument",
            "and blank fill before returning."
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_char-malloc",
            "c_mixin_arg-call-cxx",
            "c_mixin_char-copyout",
            "c_mixin_char-free"
        ]
    },
    {
        "name": "f_inout_char*_cfi",
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_char-copyout",
            "c_mixin_char-alloc",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "name": "f_function_char*_cfi_copy",
        "notes": [
            "Copy result into caller's buffer."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_cfi_pass_character",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_arg-call-cxx",
            "c_mixin_function-assign-to-local",
            "c_mixin_char-copyout"
        ]
    },
    {
        "name": "f_function_char*_cfi_funcarg_copy",
        "notes": [
            "Change function result into an argument.",
            "Use F_string_result_as_arg as the argument name.",
            "was base:f_function_char*_cfi_copy"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function-as-character-arg",
            "f_mixin_cfi_pass_character",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_arg-call-cxx",
            "c_mixin_function-assign-to-local",
            "c_mixin_char-copyout"
        ]
    },
    {
        "name": "f_in_char**_cfi",
        "mixin": [
            "f_mixin_cfi_arg-character-array",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len-size",
            "c_mixin_char-array-alloc",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "name": "f_out_char**_cfi_pointer_library",
        "notes": [
            "Return a Fortran pointer to C memory."
        ],
        "mixin": [
            "f_mixin_dummy_arg",
            "f_mixin_character-deferred-length",
            "c_mixin_dummy_arg",
            "c_mixin_character-deferred-length",
            "c_mixin_cfi_arg",
            "c_mixin_local-cvar-ptr",
            "c_mixin_arg-call-cvar-address",
            "c_mixin_cfi_character_pointer"
        ]
    },
    {
        "alias": [
            "f_in_string_cfi",
            "f_in_string&_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx"
        ]
    },
    {
        "alias": [
            "f_in_string*_cfi"
        ],
        "notes": [
            "was base:f_in_string_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx-address"
        ]
    },
    {
        "alias": [
            "f_out_string*_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_local-string",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_out_string&_cfi"
        ],
        "notes": [
            "was base:f_out_string*_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_local-string",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_arg-call-cxx",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_inout_string*_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_inout_string&_cfi"
        ],
        "notes": [
            "was base:f_inout_string*_cfi"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_character",
            "c_mixin_cfi-unpack-base-addr",
            "c_mixin_cfi-unpack-len",
            "c_mixin_local-string-init-trim",
            "c_mixin_arg-call-cxx",
            "c_mixin_string-copy-out"
        ]
    },
    {
        "alias": [
            "f_function_string_cfi_copy",
            "f_function_string*_cfi_copy",
            "f_function_string&_cfi_copy"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_cfi_pass_character",
            "c_mixin_cfi_arg_character",
            "c_mixin_arg-call-cxx",
            "c_mixin_function-assign-to-local",
            "c_mixin_cfi_copy-to-arg"
        ]
    },
    {
        "alias": [
            "f_function_string_cfi_funcarg_copy",
            "f_function_string&_cfi_funcarg_copy"
        ],
        "notes": [
            "Change function result into an argument.",
            "Use F_string_result_as_arg as the argument name.",
            "was base:f_function_string_cfi_copy"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_function-as-character-arg",
            "f_mixin_cfi_pass_character",
            "c_mixin_cfi_arg_character",
            "c_mixin_arg-call-cxx",
            "c_mixin_function-assign-to-local",
            "c_mixin_cfi_copy-to-arg"
        ]
    },
    {
        "alias": [
            "f_function_string_cfi_pointer",
            "f_function_string_cfi_pointer_caller",
            "f_function_string_cfi_pointer_library"
        ],
        "notes": [
            "Return a pointer to a new variable",
            "which the caller must release via the capsule."
        ],
        "usage": [
            "std::string func() +deref(allocatable)"
        ],
        "mixin": [
            "f_mixin_add_capsule_arg_to_fwrapper",
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_function-assign-to-new",
            "c_mixin_cfi_string*_pointer",
            "c_mixin_capsule_fill_arg"
        ],
        "f_need_wrapper": true
    },
    {
        "alias": [
            "f_function_string*_cfi_pointer",
            "f_function_string&_cfi_pointer",
            "f_function_string*_cfi_pointer_caller",
            "f_function_string*_cfi_pointer_library",
            "f_function_string&_cfi_pointer_caller",
            "f_function_string&_cfi_pointer_library"
        ],
        "notes": [
            "XXX - consolidate with c_function*_cfi_pointer?",
            "XXX - via a helper to get address and length of string",
            "XXX - c_local cxx is in c_mixin_function-assign-to-local"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_function-assign-to-local",
            "c_mixin_cfi_string*_pointer"
        ],
        "f_need_wrapper": true
    },
    {
        "alias": [
            "f_function_string*_cfi_allocatable",
            "f_function_string&_cfi_allocatable",
            "f_function_string_cfi_allocatable_caller",
            "f_function_string_cfi_allocatable_library",
            "f_function_string*_cfi_allocatable_caller",
            "f_function_string*_cfi_allocatable_library",
            "f_function_string&_cfi_allocatable_caller",
            "f_function_string&_cfi_allocatable_library"
        ],
        "usage": [
            "std::string func() +deref(allocatable)"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_header_cstring",
            "c_mixin_function-assign-to-local"
        ],
        "f_need_wrapper": true,
        "c_post_call": [
            "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *) 0, \t{c_local_cxx}{cxx_member}length());",
            "if (SH_ret == CFI_SUCCESS) {{+",
            "{stdlib}memcpy({c_var_cfi}->base_addr, \t{c_local_cxx}{cxx_member}data(), \t{c_local_cxx}{cxx_member}length());",
            "-}}"
        ]
    },
    {
        "name": "f_function_string_cfi_allocatable",
        "notes": [
            "std::string & function()"
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_cfi_character-deferred-length",
            "c_mixin_header_cstring",
            "c_mixin_function-assign-to-local"
        ],
        "f_need_wrapper": true,
        "c_post_call": [
            "int SH_ret = CFI_allocate({c_var_cfi}, \t(CFI_index_t *) 0, \t(CFI_index_t *) 0, \t{c_local_cxx}.length());",
            "if (SH_ret == CFI_SUCCESS) {{+",
            "{stdlib}memcpy({c_var_cfi}->base_addr, \t{c_local_cxx}.data(), \t{c_var_cfi}->elem_len);",
            "-}}"
        ]
    },
    {
        "name": "f_out_string**_cfi_allocatable",
        "notes": [
            "std::string **strs +intent(out)+dimension(nstrs)+deref(allocatable),",
            "int *nstrs+intent(out)+hidden"
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_character-deferred-length",
            "c_mixin_dummy_arg",
            "c_mixin_cfi_arg",
            "c_mixin_local-string*",
            "c_mixin_arg-call-cvar-address",
            "c_mixin_string_max_len",
            "c_mixin_cfi_string**_allocatable"
        ]
    },
    {
        "name": "f_out_string**_cfi_copy",
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg",
            "c_mixin_local-string*",
            "c_mixin_arg-call-cvar-address"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_dummy_decl": [
            "character(*){i_intent_attr} :: {i_var}{f_assumed_shape}"
        ],
        "c_post_call": [
            "{c_helper_cfi_array_string_out}({c_var_cfi}, {cxx_var}, {gen.c_dimension_size});"
        ],
        "helper": [
            "cfi_array_string_out"
        ]
    },
    {
        "name": "f_out_native*_cfi_allocatable"
    },
    {
        "name": "f_out_native**_cfi_allocatable",
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_native",
            "c_mixin_local-cxx-ptr",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_cfi_native_allocatable"
        ]
    },
    {
        "name": "f_out_native**_cfi_pointer_library",
        "notes": [
            "Set Fortran pointer to point to c_local_cxx."
        ],
        "mixin": [
            "f_mixin_declare-fortran-arg",
            "c_mixin_cfi_arg_native",
            "c_mixin_local-cxx-ptr",
            "c_mixin_arg-call-cxx-address",
            "c_mixin_cfi_native_pointer"
        ]
    },
    {
        "name": "f_function_native*_cfi_allocatable",
        "notes": [
            "Pass result as an argument to C wrapper.",
            "Convert to subroutine and pass result as an argument.",
            "Return an allocated copy of data."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_arg-call-fvar",
            "c_mixin_cfi_arg_native",
            "c_mixin_arg-call-cxx",
            "c_mixin_function-assign-to-local",
            "c_mixin_cfi_native_allocatable"
        ]
    },
    {
        "name": "f_function_native*_cfi_pointer_library",
        "notes": [
            "Pass result as an argument to C wrapper.",
            "Convert to subroutine and pass result as an argument.",
            "Return Fortran pointer to data."
        ],
        "mixin": [
            "f_mixin_call-cwrapper-as-subroutine",
            "f_mixin_declare-local-variable",
            "f_mixin_arg-call-fvar",
            "c_mixin_cfi_arg_native",
            "c_mixin_arg-call-cxx",
            "c_mixin_function-assign-to-local",
            "c_mixin_cfi_native_pointer"
        ],
        "f_pre_call": [
            "nullify({f_var})"
        ]
    },
    {
        "name":"##### procedure mixin ######################################"
    },
    {
        "name": "f_mixin_procedure-as-funptr",
        "comments": [
            "Pass type(C_FUNPTR) argument."
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "type(C_FUNPTR){f_intent_attr} :: {f_var}"
        ],
        "f_arg_call": [
            "{f_var}"
        ],
        "f_module": {
            "iso_c_binding": [
                "C_FUNPTR"
            ]
        },
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_module": {
            "iso_c_binding": [
                "C_FUNPTR"
            ]
        }
    },
    {
        "name": "f_mixin_procedure-as-funptr-byvalue",
        "notes": [
            "Used to pass a C_FUNPTR into a function."
        ],
        "i_dummy_decl": [
            "type(C_FUNPTR), value :: {i_var}"
        ]
    },
    {
        "name": "f_mixin_procedure-as-funptr-byreference",
        "notes": [
            "Used to return a C_FUNPTR from a function."
        ],
        "i_dummy_decl": [
            "type(C_FUNPTR) :: {i_var}"
        ]
    },
    {
        "name":"##### procedure ############################################"
    },
    {
        "alias": [
            "f_in_procedure",
            "c_in_procedure"
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar"
        ],
        "f_dummy_arg": [
            "{f_var}"
        ],
        "f_dummy_decl": [
            "procedure({f_abstract_interface}) :: {f_var}"
        ],
        "f_arg_call": [
            "{f_var}"
        ],
        "i_dummy_arg": [
            "{i_var}"
        ],
        "i_import": [
            "{f_abstract_interface}"
        ],
        "i_dummy_decl": [
            "procedure({f_abstract_interface}) :: {i_var}"
        ]
    },
    {
        "alias": [
            "f_in_procedure_external",
            "c_in_procedure_external"
        ],
        "notes": [
            "EXTERNAL is not allowed in BIND(C), so force wrapper."
        ],
        "base": "f_in_procedure",
        "f_dummy_decl": [
            "external :: {f_var}"
        ],
        "f_need_wrapper": true
    },
    {
        "alias": [
            "f_in_procedure_funptr",
            "c_in_procedure_funptr"
        ],
        "notes": [
            "Accept a function pointer in an argument."
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_procedure-as-funptr",
            "f_mixin_procedure-as-funptr-byvalue"
        ]
    },
    {
        "alias": [
            "f_out_procedure*_funptr",
            "c_out_procedure*_funptr"
        ],
        "notes": [
            "Return a function pointer in an argument."
        ],
        "mixin": [
            "c_mixin_declare-arg",
            "c_mixin_arg-call-cvar",
            "f_mixin_procedure-as-funptr",
            "f_mixin_procedure-as-funptr-byreference"
        ]
    },
    {
        "name":"##### unknown ##############################################",
        "notes": [
            "Added by Shroud when a name is not found.",
            "Create dummy values to help track down how it is used."
        ]
    },
    {
        "name": "f_mixin_unknown",
        "comments": [
            "Default returned by lookup_fc_stmts when group is not found.",
            "The values will be added to generated code to mark where each group",
            "will add text."
        ],
        "f_dummy_arg": [
            "===>{f_var} f_dummy_arg<==="
        ],
        "f_dummy_decl": [
            "===>{f_var} f_dummy_decl<==="
        ],
        "f_arg_call": [
            "===>{f_var} f_arg_call<==="
        ],
        "i_dummy_arg": [
            "===>{i_var} i_dummy_arg<==="
        ],
        "i_dummy_decl": [
            "===>{i_var} i_dummy_decl<==="
        ],
        "i_result_decl": [
            "===>{i_var} i_result_decl<==="
        ],
        "c_prototype": [
            "===>{c_var} c_prototype<==="
        ],
        "c_call": [
            "===>{c_var} c_call<==="
        ]
    },
    {
        "name": "c_mixin_unknown",
        "comments": [
            "Default returned by lookup_fc_stmts when group is not found."
        ],
        "i_dummy_arg": [
            "===>{i_var} i_dummy_arg<==="
        ],
        "i_dummy_decl": [
            "===>{i_var} i_dummy_decl<==="
        ],
        "c_prototype": [
            "===>{c_var} c_prototype<==="
        ]
    },
    {
        "name":"##### unused ###############################################",
        "notes": [
            "Defined in an earlier version, should they be updated?"
        ]
    },
    {
        "alias": [
            "#f_in_vector_&_cdesc_targ_native_scalar"
        ]
    },
    {
        "alias":[
            "############################################################",
            "##### helpers ##############################################",
            "############################################################"
        ]
    },
    {
        "name": "h_mixin_unknown",
        "comments": [
            "Default returned by lookup_fc_helper when group is not found.",
            "The values will be added to generated code to mark where each group",
            "will add text."
        ]
    },
    {
        "name": "h_helper_type_defines",
        "notes": [
            "Order derived from TS 29113",
            "with the addition of unsigned types."
        ],
        "scope": "cwrap_include",
        "source": [
            "",
            "/* helper type_defines */",
            "/* Shroud type defines */",
            "#define SH_TYPE_SIGNED_CHAR 1",
            "#define SH_TYPE_SHORT       2",
            "#define SH_TYPE_INT         3",
            "#define SH_TYPE_LONG        4",
            "#define SH_TYPE_LONG_LONG   5",
            "#define SH_TYPE_SIZE_T      6",
            "",
            "#define SH_TYPE_UNSIGNED_SHORT       SH_TYPE_SHORT + 100",
            "#define SH_TYPE_UNSIGNED_INT         SH_TYPE_INT + 100",
            "#define SH_TYPE_UNSIGNED_LONG        SH_TYPE_LONG + 100",
            "#define SH_TYPE_UNSIGNED_LONG_LONG   SH_TYPE_LONG_LONG + 100",
            "",
            "#define SH_TYPE_INT8_T      7",
            "#define SH_TYPE_INT16_T     8",
            "#define SH_TYPE_INT32_T     9",
            "#define SH_TYPE_INT64_T    10",
            "",
            "#define SH_TYPE_UINT8_T    SH_TYPE_INT8_T + 100",
            "#define SH_TYPE_UINT16_T   SH_TYPE_INT16_T + 100",
            "#define SH_TYPE_UINT32_T   SH_TYPE_INT32_T + 100",
            "#define SH_TYPE_UINT64_T   SH_TYPE_INT64_T + 100",
            "",
            "/* least8 least16 least32 least64 */",
            "/* fast8 fast16 fast32 fast64 */",
            "/* intmax_t intptr_t ptrdiff_t */",
            "",
            "#define SH_TYPE_FLOAT        22",
            "#define SH_TYPE_DOUBLE       23",
            "#define SH_TYPE_LONG_DOUBLE  24",
            "#define SH_TYPE_FLOAT_COMPLEX       25",
            "#define SH_TYPE_DOUBLE_COMPLEX      26",
            "#define SH_TYPE_LONG_DOUBLE_COMPLEX 27",
            "",
            "#define SH_TYPE_BOOL       28",
            "#define SH_TYPE_CHAR       29",
            "#define SH_TYPE_CPTR       30",
            "#define SH_TYPE_STRUCT     31",
            "#define SH_TYPE_OTHER      32"
        ],
        "derived_type": [
            "",
            "! helper type_defines",
            "! Shroud type defines from helper type_defines",
            "integer, parameter, private :: &",
            "    SH_TYPE_SIGNED_CHAR= 1, &",
            "    SH_TYPE_SHORT      = 2, &",
            "    SH_TYPE_INT        = 3, &",
            "    SH_TYPE_LONG       = 4, &",
            "    SH_TYPE_LONG_LONG  = 5, &",
            "    SH_TYPE_SIZE_T     = 6, &",
            "    SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &",
            "    SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &",
            "    SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &",
            "    SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &",
            "    SH_TYPE_INT8_T    =  7, &",
            "    SH_TYPE_INT16_T   =  8, &",
            "    SH_TYPE_INT32_T   =  9, &",
            "    SH_TYPE_INT64_T   = 10, &",
            "    SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &",
            "    SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &",
            "    SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &",
            "    SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &",
            "    SH_TYPE_FLOAT       = 22, &",
            "    SH_TYPE_DOUBLE      = 23, &",
            "    SH_TYPE_LONG_DOUBLE = 24, &",
            "    SH_TYPE_FLOAT_COMPLEX      = 25, &",
            "    SH_TYPE_DOUBLE_COMPLEX     = 26, &",
            "    SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &",
            "    SH_TYPE_BOOL      = 28, &",
            "    SH_TYPE_CHAR      = 29, &",
            "    SH_TYPE_CPTR      = 30, &",
            "    SH_TYPE_STRUCT    = 31, &",
            "    SH_TYPE_OTHER     = 32"
        ]
    },
    {
        "name": "h_helper_char_copy",
        "c_fmtname": "ShroudCharCopy",
        "c_include": [
            "<string.h>"
        ],
        "cxx_include": [
            "<cstring>"
        ],
        "source": [
            "",
            "// helper ShroudCharCopy",
            "// Copy src into dest, blank fill to ndest characters",
            "// Truncate if dest is too short.",
            "// dest will not be NULL terminated.",
            "static void ShroudCharCopy(char *dest, int ndest, const char *src, int nsrc)",
            "{{+",
            "if (src == NULL) {{+",
            "{stdlib}memset(dest,' ',ndest); // convert NULL pointer to blank filled string",
            "-}} else {{+",
            "if (nsrc < 0) nsrc = {stdlib}strlen(src);",
            "int nm = nsrc < ndest ? nsrc : ndest;",
            "{stdlib}memcpy(dest,src,nm);",
            "if(ndest > nm) {stdlib}memset(dest+nm,' ',ndest-nm); // blank fill",
            "-}}",
            "-}}"
        ]
    },
    {
        "name": "h_helper_char_blank_fill",
        "c_fmtname": "ShroudCharBlankFill",
        "c_include": [
            "<string.h>"
        ],
        "cxx_include": [
            "<cstring>"
        ],
        "source": [
            "",
            "// helper char_blank_fill",
            "// blank fill dest starting at trailing NULL.",
            "static void ShroudCharBlankFill(char *dest, int ndest)",
            "{{+",
            "int nm = {stdlib}strlen(dest);",
            "if(ndest > nm) {stdlib}memset(dest+nm,' ',ndest-nm);",
            "-}}"
        ]
    },
    {
        "name": "h_helper_char_alloc",
        "notes": [
            "Used by 'const char *' arguments which need to be NULL terminated",
            "in the C wrapper."
        ],
        "c_fmtname": "ShroudCharAlloc",
        "c_include": [
            "<string.h>",
            "<stdlib.h>",
            "<stddef.h>"
        ],
        "cxx_include": [
            "<cstring>",
            "<cstdlib>"
        ],
        "source": [
            "",
            "// helper char_alloc",
            "// Copy src into new memory and null terminate.",
            "// If ntrim is 0, return NULL pointer.",
            "// If blanknull is 1, return NULL when string is blank.",
            "static char *ShroudCharAlloc(const char *src, int nsrc, int blanknull)",
            "{{+",
            "int ntrim = ShroudCharLenTrim(src, nsrc);",
            "if (ntrim == 0 && blanknull == 1) {{+",
            "return {nullptr};",
            "-}}",
            "char *rv = (char *) {stdlib}malloc(nsrc + 1);",
            "if (ntrim > 0) {{+",
            "{stdlib}memcpy(rv, src, ntrim);",
            "-}}",
            "rv[ntrim] = '\\0';",
            "return rv;",
            "-}}"
        ],
        "dependent_helpers": [
            "char_len_trim"
        ]
    },
    {
        "name": "h_helper_char_free",
        "c_fmtname": "ShroudCharFree",
        "c_include": [
            "<stdlib.h>"
        ],
        "cxx_include": [
            "<cstdlib>"
        ],
        "source": [
            "",
            "// helper char_free",
            "// Release memory allocated by ShroudCharAlloc",
            "static void ShroudCharFree(char *src)",
            "{{+",
            "if (src != NULL) {{+",
            "{stdlib}free(src);",
            "-}}",
            "-}}"
        ]
    },
    {
        "name": "h_helper_char_len_trim",
        "c_fmtname": "ShroudCharLenTrim",
        "source": [
            "",
            "// helper char_len_trim",
            "// Returns the length of character string src with length nsrc,",
            "// ignoring any trailing blanks.",
            "static int ShroudCharLenTrim(const char *src, int nsrc) {{+",
            "int i;",
            "",
            "for (i = nsrc - 1; i >= 0; i--) {{+",
            "if (src[i] != ' ') {{+",
            "break;",
            "-}}",
            "-}}",
            "",
            "return i + 1;",
            "-}}",
            ""
        ]
    },
    {
        "name": "h_helper_char_array_alloc",
        "notes": [
            "Used with 'char **' arguments.",
            "Converts a contiguous Fortran array of characters into",
            "an array of of char * pointers to NULL terminated strings."
        ],
        "c_fmtname": "ShroudStrArrayAlloc",
        "dependent_helpers": [
            "char_len_trim"
        ],
        "c_include": [
            "<string.h>",
            "<stdlib.h>"
        ],
        "cxx_include": [
            "<cstring>",
            "<cstdlib>"
        ],
        "source": [
            "",
            "{c_lstart}// helper char_array_alloc",
            "// Copy src into new memory and null terminate.",
            "// char **src +size(nsrc) +len(len)",
            "// CHARACTER(len) src(nsrc)",
            "static char **ShroudStrArrayAlloc(const char *src, int nsrc, int len)",
            "{{+",
            "char **rv = {cast_static}char **{cast1}{stdlib}malloc(sizeof(char *) *nsrc){cast2};",
            "const char *src0 = src;",
            "for(int i=0; i < nsrc; ++i) {{+",
            "int ntrim = ShroudCharLenTrim(src0, len);",
            "char *tgt = {cast_static}char *{cast1}{stdlib}malloc(ntrim+1){cast2};",
            "{stdlib}memcpy(tgt, src0, ntrim);",
            "tgt[ntrim] = '\\0';",
            "rv[i] = tgt;",
            "src0 += len;",
            "-}}",
            "return rv;",
            "-}}{c_lend}"
        ]
    },
    {
        "name": "h_helper_char_array_free",
        "c_fmtname": "ShroudStrArrayFree",
        "c_include": [
            "<stdlib.h>"
        ],
        "cxx_include": [
            "<cstdlib>"
        ],
        "source": [
            "",
            "// helper char_array_free",
            "// Release memory allocated by ShroudStrArrayAlloc",
            "static void ShroudStrArrayFree(char **src, int nsrc)",
            "{{+",
            "for(int i=0; i < nsrc; ++i) {{+",
            "{stdlib}free(src[i]);",
            "-}}",
            "{stdlib}free(src);",
            "-}}"
        ]
    },
    {
        "name": "h_helper_lower_bounds_CFI",
        "notes": [
            "Lower bounds for 1 for arrays.",
            "No need to include ISO_Fortran_binding.h since it is already",
            "included in the C wrapper header."
        ],
        "c_fmtname": "SHT_lower_CFI",
        "#include": [
            "ISO_Fortran_binding.h"
        ],
        "source": [
            "",
            "// Lower bounds of CFI arrays.",
            "static CFI_index_t SHT_lower_CFI[CFI_MAX_RANK] = {{1}};"
        ]
    },
    {
        "name": "h_helper_size_CFI",
        "notes": [
            "Find size of CFI array."
        ],
        "c_include": [
            "<stddef.h>"
        ],
        "cxx_include": [
            "<cstddef>"
        ],
        "source": [
            "",
            "// helper size_CFI",
            "// Compute number of items in CFI_cdesc_t",
            "size_t ShroudSizeCFI(CFI_cdesc_t *desc)",
            "{{+",
            "size_t nitems = 1;",
            "for (int i = 0; i < desc->rank; i++) {{+",
            "nitems *= desc->dim[i].extent;",
            "-}}",
            "return nitems;",
            "-}}"
        ]
    },
    {
        "name": "h_helper_capsule_dtor",
        "notes": [
            "Add the C prototype. The body is created Wrapc.write_capsule_code."
        ],
        "fmtdict": {
            "cnamefunc":  "{C_memory_dtor_function}",
            "cnameproto":  "void {cnamefunc}\t({c_capsule_data_type} *cap)",
            "fnamefunc":  "{C_prefix}SHROUD_capsule_dtor",
            "fnamefunc_capsule_dtor": "{fnamefunc}"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "c",
        "dependent_helpers": [
            "capsule_data"
        ],
        "proto": "{cnameproto};",
        
        "f_fmtname": "{fnamefunc}",
        "interface": [
            "",
            "interface+",
            "! helper {hname}",
            "! Delete memory in a capsule.",
            "subroutine {fnamefunc}(ptr)\tbind(C, name=\"{cnamefunc}\")+",
            "import {f_capsule_data_type}",
            "implicit none",
            "type({f_capsule_data_type}), intent(INOUT) :: ptr",
            "-end subroutine {fnamefunc}",
            "-end interface"
        ]
    },
    {
        "name": "h_helper_copy_array",
        "notes": [
            "XXX - Only used with std::vector and thus C++.",
            "Create Fortran interface to helper function which copies an array.",
            "Used with sgroup='native' types.",
            "The function has C_prefix in the name since it is not file static.",
            "This allows multiple wrapped libraries to coexist.",
            "Create a single C routine which is called from Fortran",
            "via an interface for each cxx_type.",
            "XXX when f_kind == C_SIZE_T"
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudCopyArray",
            "fnamefunc": "{C_prefix}SHROUD_{hname}"
        },
        "c_fmtname": "{cnamefunc}",
        "scope": "cwrap_impl",
        "dependent_helpers": [
            "array_context"
        ],
        "c_include": [
            "<string.h>",
            "<stddef.h>"
        ],
        "cxx_include": [
            "<cstring>",
            "<cstddef>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy std::vector into array c_var(c_var_size).",
            "// Then release std::vector.",
            "// Called from Fortran.",
            "void {cnamefunc}({C_array_type} *data, \tvoid *c_var, \tsize_t c_var_size)",
            "{{+",
            "const void *cxx_var = data->base_addr;",
            "int n = c_var_size < data->size ? c_var_size : data->size;",
            "n *= data->elem_len;",
            "{stdlib}memcpy(c_var, cxx_var, n);",
            "-}}{c_lend}"
        ],
        "f_fmtname": "{fnamefunc}",
        "interface": [
            "",
            "interface+",
            "! helper {hname}",
            "! Copy contents of context into c_var.",
            "subroutine {fnamefunc}(context, c_var, c_var_size) &+",
            "bind(C, name=\"{cnamefunc}\")",
            "use iso_c_binding, only : C_PTR, C_SIZE_T",
            "import {F_array_type}",
            "type({F_array_type}), intent(IN) :: context",
            "type(C_PTR), intent(IN), value :: c_var",
            "integer(C_SIZE_T), value :: c_var_size",
            "-end subroutine {fnamefunc}",
            "-end interface"
        ]
    },
    {
        "name": "h_helper_copy_string",
        "notes": [
            "Deal with allocatable character."
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudCopyString",
            "fnamefunc": "{C_prefix}SHROUD_copy_string"
        },
        "c_fmtname": "{cnamefunc}",
        "scope": "cwrap_impl",
        "dependent_helpers": [
            "array_context"
        ],
        "c_include": [
            "<string.h>"
        ],
        "cxx_include": [
            "<cstring>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy the char* or std::string in context into c_var.",
            "// Called by Fortran to deal with allocatable character.",
            "void {cnamefunc}(\t{C_array_type} *data,\t char *c_var,\t size_t c_var_len) {{+",
            "const void *cxx_var = data->base_addr;",
            "size_t n = c_var_len;",
            "if (data->elem_len < n) n = data->elem_len;",
            "{stdlib}memcpy(c_var, cxx_var, n);",
            "-}}{c_lend}"
        ],

        "f_fmtname": "{fnamefunc}",
        "interface": [
            "",
            "interface+",
            "! helper {hname}",
            "! Copy the char* or std::string in context into c_var.",
            "subroutine {fnamefunc}(context, c_var, c_var_size) &",
            "     bind(c,name=\"{cnamefunc}\")+",
            "use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T",
            "import {F_array_type}",
            "type({F_array_type}), intent(IN) :: context",
            "character(kind=C_CHAR), intent(OUT) :: c_var(*)",
            "integer(C_SIZE_T), value :: c_var_size",
            "-end subroutine {fnamefunc}",
            "-end interface"
        ]
    },
    {
        "name":"##### helper std::string array #############################",
        "notes": [
            "Copy an array or std::vector of std::string into Fortran memory",
            "  CHARACTER(len=destlen) dest(destsize)"
        ]
    },
    {
        "name": "h_helper_cdesc_array_string_out",
        "notes": [
            "Only used with std::string and thus C++."
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudCdescArrayStringOut",
            "cnamefunc_cdesc_array_string_out": "{cnamefunc}",
            "cnameproto":  "void {cnamefunc}({C_array_type} *outdesc, std::string *src, size_t srcsize)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "cxx",
        "scope": "cwrap_impl",
        "dependent_helpers": [
            "array_context"
        ],
        "proto_include": [
            "<string>"
        ],
        "proto": "{cnameproto};",
        "cxx_include": [
            "<cstring>",
            "<cstddef>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy the array of std::string into array described by {C_array_type}.",
            "// Called by C++.",
            "//  CHARACTER(len=destlen) dest(destsize)",
            "{cnameproto}",
            "{{+",
            "size_t destsize = outdesc->size;",
            "size_t destlen = outdesc->elem_len;",
            "char *dest = static_cast<char *>(outdesc->base_addr);",
            "// Clear user memory",
            "std::memset(dest, ' ', destsize*destlen);",
            "",
            "// Copy into user memory",
            "srcsize = std::min(destsize, srcsize);",
            "for (size_t i = 0; i < srcsize; ++i) {{+",
            "std::memcpy(dest, src[i].data(), std::min(destlen, src[i].length()));",
            "dest += destlen;",
            "-}}",
            "-}}{c_lend}"
        ]
    },
    {
        "name": "h_helper_array_string_allocatable",
        "notes": [
            "Only used with std::string and thus C++.",
            "Called from Fortran to deal with allocatable character",
            "The capsule contains a pointer to a std::string",
            "which is copied into the cdesc."
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudCDescArrayStringAllocatable",
            "fnamefunc": "{C_prefix}SHROUD_cdesc_array_string_allocatable",
            "cnameproto": "void {cnamefunc}({C_array_type} *dest, {c_capsule_data_type} *src)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "c",
        "scope": "cwrap_impl",
        "dependent_helpers": [
            "capsule_data",
            "array_context",
            "cdesc_array_string_out"
        ],
        "proto": "{cnameproto};",
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy the std::string array into Fortran array.",
            "// Called by Fortran to deal with allocatable character.",
            "// out is already blank filled.",
            "{cnameproto}",
            "{{+",
            "std::string *cxxvec =\t static_cast< std::string *>\t(src->addr);",
            "{cnamefunc_cdesc_array_string_out}(dest, cxxvec, dest->size);",
            "-}}{c_lend}"
        ],

        "f_fmtname": "{fnamefunc}",
        "interface": [
            "",
            "interface+",
            "! helper {hname}",
            "subroutine {fnamefunc}(dest, src) &",
            "     bind(c,name=\"{cnamefunc}\")+",
            "import {F_array_type}, {f_capsule_data_type}",
            "type({F_array_type}), intent(IN) :: dest",
            "type({f_capsule_data_type}), intent(IN) :: src",
            "-end subroutine {fnamefunc}",
            "-end interface"
        ]
    },
    {
        "name": "h_helper_array_string_out_len",
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudArrayStringOutSize",
            "cnameproto": "size_t {cnamefunc}(std::string *in, size_t nsize)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "cxx",
        "scope": "cwrap_impl",
        "proto_include": [
            "<string>"
        ],
        "proto": "{cnameproto};",
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Return the maximum string length in a std::vector<std::string>.",
            "{cnameproto}",
            "{{+",
            "size_t len = 0;",
            "for (size_t i = 0; i < nsize; ++i) {{+",
            "len = std::max(len, in[i].length());",
            "-}}",
            "return len;",
            "-}}{c_lend}"
        ]
    },
    {
        "name": "h_helper_cdesc_vector_string_out",
        "notes": [
            "Only used with std::vector and thus C++."
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudCdescVectorStringOut",
            "fnamefunc": "{C_prefix}shroud_cdesc_vector_string_out",
            "cnamefunc_cdesc_vector_string_out": "{cnamefunc}",
            "cnameproto": "void {cnamefunc}({C_array_type} *outdesc, std::vector<std::string> &src)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "cxx",
        "scope": "cwrap_impl",
        "dependent_helpers": [
            "array_context"
        ],
        "proto_include": [
            "<string>",
            "<vector>"
        ],
        "proto": "{cnameproto};",
        "cxx_include": [
            "<cstring>",
            "<cstddef>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy the std::vector<std::string> into array described by {C_array_type}.",
            "// Called by C++.",
            "//  CHARACTER(len=destlen) dest(destsize)",
            "{cnameproto}",
            "{{+",
            "size_t destsize = outdesc->size;",
            "size_t destlen = outdesc->elem_len;",
            "char *dest = static_cast<char *>(outdesc->base_addr);",
            "// Clear user memory",
            "std::memset(dest, ' ', destsize*destlen);",
            "",
            "// Copy into user memory",
            "size_t srcsize = std::min(destsize, src.size());",
            "for (size_t i = 0; i < srcsize; ++i) {{+",
            "std::memcpy(dest, src[i].data(), std::min(destlen, src[i].length()));",
            "dest += destlen;",
            "-}}",
            "-}}{c_lend}"
        ]
    },
    {
        "name": "h_helper_cdesc_vector_string_allocatable",
        "notes": [
            "Only used with std::string and thus C++.",
            "Called from Fortran.",
            "The capsule contains a pointer to a std::vector<std::string>",
            "which is copied into the cdesc."
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}CDescShroudVectorStringAllocatable",
            "fnamefunc": "{C_prefix}SHROUD_cdesc_vector_string_allocatable",
            "cnameproto": "void {cnamefunc}({C_array_type} *dest, {c_capsule_data_type} *src)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "c",
        "scope": "cwrap_impl",
        "dependent_helpers": [
            "capsule_data",
            "array_context",
            "cdesc_vector_string_out"],
        "proto": "{cnameproto};",
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy the std::vector<std::string> into Fortran array.",
            "// Called by Fortran to deal with allocatable character.",
            "// dest is already blank filled.",
            "{cnameproto}",
            "{{+",
            "std::vector<std::string> *cxxvec =\t static_cast< std::vector<std::string> *>\t(src->addr);",
            "{cnamefunc_cdesc_vector_string_out}(dest, *cxxvec);",
            "-}}{c_lend}"
        ],
        "f_fmtname": "{fnamefunc}",
        "interface": [
            "",
            "interface+",
            "! helper {hname}",
            "! Copy the char* or std::string in context into c_var.",
            "subroutine {fnamefunc}(dest, src) &",
            "     bind(c,name=\"{cnamefunc}\")+",
            "import {f_capsule_data_type}, {F_array_type}",
            "type({F_array_type}), intent(IN) :: dest",
            "type({f_capsule_data_type}), intent(IN) :: src",
            "-end subroutine {fnamefunc}",
            "-end interface"
        ]
    },
    {
        "name": "h_helper_vector_string_out_len",
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudVectorStringOutSize",
            "cnameproto": "size_t {cnamefunc}(std::vector<std::string> &in)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "cxx",
        "scope": "cwrap_impl",
        "proto_include": [
            "<string>",
            "<vector>"
        ],
        "proto": "{cnameproto};",
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Return the maximum string length in a std::vector<std::string>.",
            "{cnameproto}",
            "{{+",
            "size_t nvect = in.size();",
            "size_t len = 0;",
            "for (size_t i = 0; i < nvect; ++i) {{+",
            "len = std::max(len, in[i].length());",
            "-}}",
            "return len;",
            "-}}{c_lend}"
        ]
    },
    {
        "name": "h_helper_cfi_array_string_out",
        "notes": [
            "Only used with std::string and thus C++."
        ],
        "fmtdict": {
            "cnamefunc": "{C_prefix}ShroudCFIArrayStringOut",
            "cnamefunc_cfi_array_string_out": "{cnamefunc}",
            "cnameproto":  "void {cnamefunc}(CFI_cdesc_t *outdesc, std::string *src, size_t srcsize)"
        },
        "c_fmtname": "{cnamefunc}",
        "api": "cxx",
        "scope": "cwrap_impl",
        "proto_include": [
            "<string>",
            "<ISO_Fortran_binding.h>"
        ],
        "proto": "{cnameproto};",
        "cxx_include": [
            "<cstring>",
            "<cstddef>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Copy the array of std::string into array described by {C_array_type}.",
            "// Called by C++.",
            "//  CHARACTER(len=destlen) dest(destsize)",
            "{cnameproto}",
            "{{+",
            "size_t destsize = outdesc->dim[0].extent;",
            "size_t destlen = outdesc->elem_len;",
            "char *dest = static_cast<char *>(outdesc->base_addr);",
            "// Clear user memory",
            "std::memset(dest, ' ', destsize*destlen);",
            "",
            "// Copy into user memory",
            "srcsize = std::min(destsize, srcsize);",
            "for (size_t i = 0; i < srcsize; ++i) {{+",
            "std::memcpy(dest, src[i].data(), std::min(destlen, src[i].length()));",
            "dest += destlen;",
            "-}}",
            "-}}{c_lend}"
        ]
    },
    {
        "name":"############################################################"
    },
    {
        "name": "h_helper_pointer_string",
        "notes": [
            "Set Fortran POINTER to string.",
            "Must be a function (or a F2008 BLOCK) since fptr must",
            "be declared after the string length is known."
        ],
        "fmtdict": {
            "fnamefunc": "{C_prefix}SHROUD_pointer_string"
        },
        "dependent_helpers": [
            "array_context"
        ],
        "f_fmtname": "{fnamefunc}",
        "f_source": [
            "",
            "{f_lstart}! helper {hname}",
            "! Assign context to an assumed-length character pointer",
            "subroutine {fnamefunc}(context, var)+",
            "use iso_c_binding, only : c_associated, c_f_pointer, C_PTR",
            "implicit none",
            "type({F_array_type}), intent(IN) :: context",
            "character(len=:), pointer, intent(OUT) :: var",
            "character(len=context%elem_len), pointer :: fptr",
            "if (c_associated(context%base_addr)) then+",
            "call c_f_pointer(context%base_addr, fptr)",
            "var => fptr",
            "-else+",
            "nullify(var)",
            "-endif",
            "-end subroutine {fnamefunc}{f_lend}"
        ]
    },
    {
        "name": "h_helper_string_to_cdesc",
        "fmtdict": {
            "cnamefunc": "ShroudStringToCdesc"
        },
        "c_fmtname": "{cnamefunc}",
        "dependent_helpers": [
            "array_context"
        ],
        "cxx_include": [
            "<cstring>",
            "<cstddef>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "// Save std::string metadata into array to allow Fortran to access values.",
            "// CHARACTER(len=elem_size) src",
            "static void {cnamefunc}(\t{C_array_type} *cdesc,\t const std::string *src)",
            "{{+",
            "if (src->empty()) {{+",
            "cdesc->base_addr = NULL;",
            "cdesc->elem_len = 0;",
            "-}} else {{+",
            "cdesc->base_addr =\t const_cast<char *>(\tsrc->data());",
            "cdesc->elem_len = src->length();",
            "-}}",
            "cdesc->size = 1;",
            "cdesc->rank = 0;  // scalar",
            "-}}{c_lend}"
        ]
    },
    {
        "name": "h_helper_capsule_data_basic",
        "notes": [
            "Share info with C++ to allow Fortran to release memory.",
            "Used with shadow classes and std::vector.",
            "Used when option.F_assignment_api=basic."
        ],
        "scope": "cwrap_include",
        "source": [
            "",
            "// helper {hname}",
            "struct s_{c_capsule_data_type} {{+",
            "void *addr;     /* address of C++ memory */",
            "int idtor;      /* index of destructor */",
            "-}};",
            "typedef struct s_{c_capsule_data_type} {c_capsule_data_type};"
        ],
        "f_fmtname": "{f_capsule_data_type}",
        "derived_type": [
            "",
            "{f_lstart}! helper {hname}",
            "type, bind(C) :: {f_capsule_data_type}+",
            "type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory",
            "integer(C_INT) :: idtor = 0       ! index of destructor",
            "-end type {f_capsule_data_type}{f_lend}"
        ],
        "modules": {
            "iso_c_binding": ["C_PTR", "C_INT", "C_NULL_PTR"]
        }
    },
    {
        "name": "h_helper_capsule_data",
        "notes": [
            "Share info with C++ to allow Fortran to release memory.",
            "Used with shadow classes and std::vector."
        ],
        "scope": "cwrap_include",
        "source": [
            "",
            "// helper {hname}",
            "struct s_{c_capsule_data_type} {{+",
            "void *addr;     /* address of C++ memory */",
            "int idtor;      /* index of destructor */",
            "int cmemflags;  /* memory flags */",
            "-}};",
            "typedef struct s_{c_capsule_data_type} {c_capsule_data_type};"
        ],
        "f_fmtname": "{f_capsule_data_type}",
        "derived_type": [
            "",
            "{f_lstart}! helper {hname}",
            "type, bind(C) :: {f_capsule_data_type}+",
            "type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory",
            "integer(C_INT) :: idtor = 0       ! index of destructor",
            "integer(C_INT) :: cmemflags = 0   ! memory flags",
            "-end type {f_capsule_data_type}{f_lend}"
        ],
        "modules": {
            "iso_c_binding": ["C_PTR", "C_INT", "C_NULL_PTR"]
        }
    },
    {
        "name": "h_helper_capsule_helper",
        "notes": [
            "Used when the user owns C++ memory.",
            "Allows the memory to be deleted from Fortran.",
            "Fortran cannot be declared with both PRIVATE and BIND(C) attributes"
        ],
        "dependent_helpers": [
            "capsule_data",
            "capsule_dtor"
        ],
        "derived_type": [
            "",
            "! helper {hname}",
            "type :: {F_capsule_type}+",
            "private",
            "type({f_capsule_data_type}) :: mem",
            "-contains",
            "+final :: {F_capsule_final_function}",
            "procedure :: delete => {F_capsule_delete_function}",
            "-end type {F_capsule_type}"
        ],
        "f_source": [
            "",
            "! helper {hname}",
            "! finalize a static {f_capsule_data_type}",
            "subroutine {F_capsule_final_function}(cap)+",
            "type({F_capsule_type}), intent(INOUT) :: cap",
            "call {fnamefunc_capsule_dtor}(cap%mem)",
            "-end subroutine {F_capsule_final_function}",
            "",
            "subroutine {F_capsule_delete_function}(cap)+",
            "class({F_capsule_type}) :: cap",
            "call {fnamefunc_capsule_dtor}(cap%mem)",
            "-end subroutine {F_capsule_delete_function}"
        ]
    },
    {
        "name": "h_helper_capsule_memflags",
        "notes": [
            "Flags used to give properties to the addr field.",
            "This helper is added in wrapf.py Wrapf.wrap_class",
            "instead of adding to lots of other groups."
        ],
        "scope": "cwrap_include",
        "source": [
            "",
            "enum SwigMemFlags {{+",
            "SWIG_MEM_OWN = 0x01,",
            "SWIG_MEM_RVALUE = 0x02,",
            "-}};"
        ]
    },
    {
        "name": "h_helper_array_context",
        "notes": [
            "XXX - Create a union for addr to avoid some casts.",
            "And help with debugging since ccharp will display contents.",
            "Create a derived type used to communicate with C wrapper.",
            "Should never be exposed to user.",
            "Inspired by futher interoperability with C.",
            "XXX - shape is C_LONG, maybe it should be C_PTRDIFF_T."
        ],
        "c_fmtname": "{C_array_type}",
        "scope": "cwrap_include",
        "include": [
            "<stddef.h>"
        ],
        "source": [
            "",
            "{c_lstart}// helper {hname}",
            "struct s_{C_array_type} {{+",
            "void *base_addr;",
            "int type;        /* type of element */",
            "size_t elem_len; /* bytes-per-item or character len in c++ */",
            "size_t size;     /* size of data in c++ */",
            "int rank;        /* number of dimensions, 0=scalar */",
            "long shape[7];",
            "-}};",
            "typedef struct s_{C_array_type} {C_array_type};{c_lend}"
        ],
        "dependent_helpers": [
            "type_defines"
        ],
        "f_fmtname": "{F_array_type}",
        "derived_type": [
            "",
            "{f_lstart}! helper {hname}",
            "type, bind(C) :: {F_array_type}+",
            "! address of data",
            "type(C_PTR) :: base_addr = C_NULL_PTR",
            "! type of element",
            "integer(C_INT) :: type",
            "! bytes-per-item or character len of data in cxx",
            "integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T",
            "! size of data in cxx",
            "integer(C_SIZE_T) :: size = 0_C_SIZE_T",
            "! number of dimensions",
            "integer(C_INT) :: rank = -1",
            "integer(C_LONG) :: shape(7) = 0",
            "-end type {F_array_type}{f_lend}"
        ],
        "modules": {
            "iso_c_binding": ["C_NULL_PTR", "C_PTR", "C_SIZE_T", "C_INT", "C_LONG"]
        }
    }
]
